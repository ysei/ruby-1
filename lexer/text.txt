Then /^I should see an action item link to "([^"]*)"$/ do |link|
  page.should have_css('.action_item a', :text => link)
end

Then /^I should not see an action item link to "([^"]*)"$/ do |link|
  page.should_not have_css('.action_item a', :text => link)
end
Then /^I should see a member link to "([^"]*)"$/ do |name|
  page.should have_css("a.member_link", :text => name)
end

Then /^I should not see a member link to "([^"]*)"$/ do |name|
  %{Then I should not see "#{name}" within "a.member_link"}
end
Then /^I should see a table header with "([^"]*)"$/ do |content|
  page.should have_xpath('//th', :text => content)
end

Then /^I should not see a table header with "([^"]*)"$/ do |content|
  page.should_not have_xpath('//th', :text => content)
end

Then /^I should see a sortable table header with "([^"]*)"$/ do |content|
  page.should have_css('th.sortable', :text => content)
end

Then /^I should not see a sortable table header with "([^"]*)"$/ do |content|
  page.should_not have_css('th.sortable', :text => content)
end

Then /^I should not see a sortable table header$/ do
  step "I should not see \"th.sortable\""
end

Then /^the table "([^"]*)" should have (\d+) rows/ do |selector, count|
  table = page.find(selector)
  table.all(:css, 'tr').size.should == count.to_i
end

Then /^the table "([^"]*)" should have (\d+) columns/ do |selector, count|
  table = page.find(selector)
  row = table.find('tr:first')
  row.all(:css, "td").size.should == count.to_i
end

Then /^there should be (\d+) "([^"]*)" tags$/ do |count, tag|
  page.all(:css, tag).size.should == count.to_i
end

Then /^I should see a link to "([^"]*)"$/ do |link|
  if page.respond_to? :should
    page.should have_xpath('//a', :text => link)
  else
    assert page.has_xpath?('//a', :text => link)
  end
end

Then /^I should see a link to \/([^\/]*)\/$/ do |regexp|
  regexp = Regexp.new(regexp)
  if page.respond_to? :should
    page.should have_xpath('//a', :text => regexp)
  else
    assert page.has_xpath?('//a', :text => regexp)
  end
end

Then /^an "([^"]*)" exception should be raised when I follow "([^"]*)"$/ do |error, link|
  lambda {
    step "I follow \"#{link}\""
  }.should raise_error(error.constantize)
end

Then /^I should be in the resource section for (.+)$/ do |resource_name|
  current_url.should include(resource_name.gsub(' ', '').underscore.pluralize)
end

Then /^I should wait and see "([^"]*)"(?: within "([^"]*)")?$/ do |text, selector|
  sleep 1
  step 'show me the page'
  selector ||= "*"
  locate(:xpath, "//#{selector}[text()='#{text}']")
end

Then /^I should see the page title "([^"]*)"$/ do |title|
  within('h2#page_title') do
    page.should have_content(title)
  end
end

Then /^I should see a fieldset titled "([^"]*)"$/ do |title|
  page.should have_css('fieldset legend', :text => title)
end

Then /^the "([^"]*)" field should contain the option "([^"]*)"$/ do |field, option|
  field = find_field(field)
  field.should have_css("option", :text => option)
end

Then /^I should see the content "([^"]*)"$/ do |content|
  page.should have_css("#active_admin_content", :text => content)
end

Then /^I should see a validation error "([^"]*)"$/ do |error_message|
  page.should have_css(".inline-errors", :text => error_message)
end

Then /^I should see a table with id "([^"]*)"$/ do |dom_id|
  page.should have_css('table', :id => dom_id)
end
Then /^I should see the css file "([^"]*)"$/ do |path|
  step %{I should see the css file "#{path}" of media "screen"}  
end

Then /^I should see the css file "([^"]*)" of media "([^"]*)"$/ do |path, media|
  page.should have_xpath("//link[contains(@href, /stylesheets/#{path}) and contains(@media, #{media})]")
end

Then /^I should see the js file "([^"]*)"$/ do |path|
  page.should have_xpath("//script[contains(@src, /javascripts/#{path})]")
end
Then /^I should see the attribute "([^"]*)" with "([^"]*)"$/ do |title, value|
  page.should have_css('.attributes_table th', :text => title)
  page.should have_css('.attributes_table td', :text => value)
end

Then /^I should see the attribute "([^"]*)" with a nicely formatted datetime$/ do |title|
  th = page.find('.attributes_table th', :text => title)
  page.find(:xpath, th.path.gsub(/th$/, 'td')).text.should =~ /\w+ \d{1,2}, \d{4} \d{2}:\d{2}/
end

Then /^I should not see the attribute "([^"]*)"$/ do |title|
  page.should_not have_css('.attributes_table th', :text => title)
end
Then /^I (should|should not) see the batch action "([^"]*)"$/ do |maybe, title|
  %{Then I #{maybe} see the batch action :#{title.gsub(' ','').gsub(" Selected", "").underscore} "#{title}"}
end

Then /^I (should|should not) be asked to confirm "([^"]*)" for "([^"]*)"$/ do |maybe, confirmation, title|
  within "#batch_actions_popover" do
    unless maybe == "should not"
      link = page.find "a.batch_action", :text => title
      link["data-confirm"].should match( confirmation )
    else
      page.should_not have_css("a.batch_action", :text => title)
    end
  end
end

Then /^I (should|should not) see the batch action :([^\s]*) "([^"]*)"$/ do |maybe, sym, title|
  within "#batch_actions_selector" do
    unless maybe == "should not"
      link = page.find "a.batch_action", :text => title
      link["data-action"].should match( sym )
      link[:href].should match( "#" )
    else
      page.should_not have_css("a.batch_action", :text => title)
    end
  end
end

Then /^the (\d+)(?:st|nd|rd|th) batch action should be "([^"]*)"$/ do |index, title|
  within "#batch_actions_selector" do
    page.all( "a.batch_action" )[index.to_i - 1].text.should match( title )
  end
end

When /^I check the (\d+)(?:st|nd|rd|th) record$/ do |index|
  page.all( "table.index_table input[type=checkbox]" )[index.to_i].set( true )
end

When /^I uncheck the (\d+)(?:st|nd|rd|th) record$/ do |index|
  page.all( "table.index_table input[type='checkbox']" )[index.to_i].set( false )
end

When /^I toggle the collection selection$/ do
  toggle_box = page.find( "#collection_selection_toggle_all" )
  toggle_box.click
end

Then /^I should see (\d+) record(?:s)? selected$/ do |count|
  within "table.index_table" do
    unless count.to_i == 0
      page.should have_xpath(".//input[@type='checkbox' and @checked='checked']", :count => count)
    else
      page.should have_no_xpath(".//input[@type='checkbox' and @checked='checked']")
    end
  end
end

Then /^I should see that the batch action button is disabled$/ do
  page.should have_css("#batch_actions_selector .dropdown_menu_button.disabled")
end

Then /^I (should|should not) see the batch action button$/ do |maybe|
  if maybe == "should not"
    page.should_not have_css("div.table_tools #batch_actions_selector .dropdown_menu_button")
  else
    page.should have_css("div.table_tools #batch_actions_selector .dropdown_menu_button")
  end
end

Then "I should not see the batch actions selector" do
  page.should_not have_css("div.table_tools #batch_actions_selector")
end

Then /^I should see the batch action popover exists$/ do
  page.should have_css("#batch_actions_selector")
end

Given /^I submit the batch action form with "([^"]*)"$/ do |action|
  page.find(:css, "#batch_action").set(action)

  within("#main_content") do
    @params = page.all("input").reduce({}) do |acc, input|
      param_key = input['name']
      param_value = input['value']

      if param_key == 'collection_selection[]'
        # the collection_selection should be sent as an array containing only IDs of checked rows
        acc[param_key] ||= Array.new
        acc[param_key] << param_value if input.checked?
      else
        # other inputs, just send the value normally
        acc.store(param_key, param_value)
      end
      acc
    end
  end

  form = page.find("#collection_selection")

  page.driver.submit(form['method'].to_sym, form['action'], @params)
end

Then /^I should not see checkboxes in the table$/ do
  page.should_not have_css( ".paginated_collection table input[type=checkbox]" )
end
Then /^I should see a link to "([^"]*)" in the breadcrumb$/ do |text|
  within ".breadcrumb" do
    page.should have_css("a", :text => text)
  end
end
Then /^I should see a comment by "([^"]*)"$/ do |name|
  step %{I should see "#{name}" within ".active_admin_comment_author"}
end

When /^I add a comment "([^"]*)"$/ do |comment|
  step %{I fill in "active_admin_comment_body" with "#{comment}"}
  step  %{I press "Add Comment"}
end


Given /^a tag with the name "([^"]*)" exists$/ do |tag_name|
  Tag.create(:name => tag_name)
end
module ActiveAdminReloading

  def load_active_admin_configuration(configuration_content)
    ActiveAdmin::Event.dispatch ActiveAdmin::Application::BeforeLoadEvent, ActiveAdmin.application
    eval(configuration_content)
    ActiveAdmin::Event.dispatch ActiveAdmin::Application::AfterLoadEvent, ActiveAdmin.application
    Rails.application.reload_routes!
    ActiveAdmin.application.namespaces.values.each{|n| n.reset_menu! }
  end

end

module ActiveAdminContentsRollback

  def self.recorded_files
    @files ||= {}
  end

  # Records the contents of a file the first time we are
  # about to change it
  def self.record(filename)
    contents = File.read(filename) rescue nil
    recorded_files[filename] = contents unless recorded_files.has_key?(filename)
  end

  # Rolls the recorded files back to their original states
  def self.rollback!
    recorded_files.each do |filename, contents|
      # contents will be nil if the file didin't exist
      if contents.present?
        File.open(filename, "w") {|f| f << contents }
      else
        File.delete(filename)

        # Delete parent directories
        begin
          dir = File.dirname(filename)
          until dir == Rails.root
            Dir.rmdir(dir)
            dir = dir.split('/')[0..-2].join('/')
          end
        rescue Errno::ENOTEMPTY
          # Directory not empty
        end

      end
    end

    @files = {}
  end

end

World(ActiveAdminReloading)

After do
  ActiveAdminContentsRollback.rollback!
end

Given /^a configuration of:$/ do |configuration_content|
  load_active_admin_configuration(configuration_content)
end

Given /^an index configuration of:$/ do |configuration_content|
  load_active_admin_configuration(configuration_content)

  step 'I am logged in'
  step "I am on the index page for posts"
end

Given /^a show configuration of:$/ do |configuration_content|
  resource = configuration_content.match(/ActiveAdmin\.register (\w+)/)[1]
  load_active_admin_configuration(configuration_content)

  case resource
  when "Post"
    step 'I am logged in'
    step "I am on the index page for posts"
    step 'I follow "View"'
  when "Tag"
    step 'I am logged in'
    Tag.create!
    visit admin_tag_path(Tag.last)
  else
    raise "#{resource} is not supported"
  end
end

Given /^"([^"]*)" contains:$/ do |filename, contents|
  require 'fileutils'
  filepath = Rails.root + filename
  FileUtils.mkdir_p File.dirname(filepath)
  ActiveAdminContentsRollback.record(filepath)

  File.open(filepath, 'w+'){|f| f << contents }
end

Given /^I add "([^"]*)" to the "([^"]*)" model$/ do |code, model_name|
  filename = File.join(Rails.root, "app", "models", "#{model_name}.rb")
  ActiveAdminContentsRollback.record(filename)

  # Update the file
  contents = File.read(filename)
  File.open(filename, "w+") do |f|
    f << contents.gsub(/^(class .+)$/, "\\1\n  #{code}\n")
  end

  ActiveSupport::Dependencies.clear
end
Then /^I should see the default welcome message$/ do
  step %{I should see "Welcome to Active Admin" within "#dashboard_default_message"}
end

Then /^I should not see the default welcome message$/ do
  step %{I should not see "Welcome to Active Admin"}
end

Then /^I should see a dashboard widget "([^"]*)"$/ do |name|
  page.should have_css('.dashboard .panel h3', :text => name) 
end

Then /^I should not see a dashboard widget "([^"]*)"$/ do |name|
  page.should_not have_css('.dashboard .panel h3', :text => name) 
end
Given /^a post with the title "([^"]*)" exists$/ do |title|
  Post.create! :title => title
end

Given /^a post with the title "([^"]*)" and body "([^"]*)" exists$/ do |title, body|
  Post.create! :title => title, :body => body
end

Given /^a (published )?post with the title "([^"]*)" written by "([^"]*)" exists$/ do |published, title, author_name|
  first, last = author_name.split(' ')
  author = User.find_or_create_by_first_name_and_last_name(first, last, :username => author_name.gsub(' ', '').underscore)
  published_at = published ? Time.now : nil
  Post.create! :title => title, :author => author, :published_at => published_at
end

Given /^(\d+)( published)? posts? written by "([^"]*)" exist$/ do |count, published, author_name|
  first, last = author_name.split(' ')
  author = User.find_or_create_by_first_name_and_last_name(first, last, :username => author_name.gsub(' ', '').underscore)
  (0...count.to_i).each do |i|
    Post.create! :title => "Hello World #{i}", :author => author, :published_at => (published ? Time.now : nil)
  end
end

Given /^(\d+)( published)? posts? exists?$/ do |count, published|
  (0...count.to_i).each do |i|
    Post.create! :title => "Hello World #{i}", :published_at => (published ? Time.now : nil)
  end
end

Given /^a category named "([^"]*)" exists$/ do |name|
  Category.create! :name => name
end

Given /^a (user|publisher) named "([^"]*)" exists$/ do |type, name|
  first, last = name.split(" ")
  type = type.camelize.constantize
  type.create! :first_name => first, :last_name => last, :username => name
end

Given /^I create a new post with the title "([^"]*)"$/ do |title|
  click_link "Posts"
  click_link "New Post"
  fill_in :title, :with => title
  click_button "Create Post"
end

Given /^a store named "([^"]*)" exists$/ do |name|
  Store.create! :name => name
end
Then /^I should see a select filter for "([^"]*)"$/ do |label|
  page.should have_css(".filter_select label", :text => label)
end

Then /^I should see a string filter for "([^"]*)"$/ do |label|
  page.should have_css(".filter_string label", :text => "Search #{label}")
end

Then /^I should see a date range filter for "([^"]*)"$/ do |label|
  page.should have_css(".filter_date_range label", :text => label)
end

Then /^I should see the following filters:$/ do |table|
  table.rows_hash.each do |label, type|
    step "I should see a #{type} filter for \"#{label}\""
  end
end
Then /^I should see a flash with "([^"]*)"$/ do |text|
  page.should have_content(text)
end

Then /^I should see a successful create flash$/ do
  page.should have_css('div.flash_notice', :text => /was successfully created/)
end

Then /^I should not see a successful create flash$/ do
  page.should_not have_css('div.flash_notice', :text => /was successfully created/)
end
CSVLib = if RUBY_VERSION =~ /^1.8/
            require 'fastercsv'
            FasterCSV
          else
            require 'csv'
            CSV
          end

Then "I should see nicely formatted datetimes" do
  page.body.should =~ /\w+ \d{1,2}, \d{4} \d{2}:\d{2}/
end

Then /^I should see a link to download "([^"]*)"$/ do |format_type|
  page.should have_css("#index_footer a", :text => format_type)
end

Then /^I should not see a link to download "([^"]*)"$/ do |format_type|
  page.should_not have_css("#index_footer a", :text => format_type)
end

# Check first rows of the displayed CSV.
Then /^I should download a CSV file with "([^"]*)" separator for "([^"]*)" containing:$/ do |sep, resource_name, table|
  page.response_headers['Content-Type'].should == 'text/csv; charset=utf-8'
  csv_filename = "#{resource_name}-#{Time.now.strftime("%Y-%m-%d")}.csv"
  page.response_headers['Content-Disposition'].should == %{attachment; filename="#{csv_filename}"}
  body = page.driver.response.body

  begin
    csv = CSVLib.parse(body, :col_sep => sep)
    table.raw.each_with_index do |expected_row, row_index|
      expected_row.each_with_index do |expected_cell, col_index|
        cell = csv.try(:[], row_index).try(:[], col_index)
        if expected_cell.blank?
          cell.should be_nil
        else
          (cell || '').should match(/#{expected_cell}/)
        end
      end
    end
  rescue
    puts "Expecting:"
    p table.raw
    puts "to match:"
    p csv
    raise $!
  end
end

Then /^I should download a CSV file for "([^"]*)" containing:$/ do |resource_name, table|
  step "I should download a CSV file with \",\" separator for \"#{resource_name}\" containing:", table
end

Then /^the CSV file should contain "([^"]*)" in quotes$/ do |text|
  body = page.driver.response.body
  body.should match(/\"#{text}\"/)
end
When /^I set my locale to "([^"]*)"$/ do |lang|
  I18n.locale = lang
end
Then /^I should see the scope "([^"]*)"$/ do |name|
  step %{I should see "#{name}" within ".scopes"}
end

Then /^I should not see the scope "([^"]*)"$/ do |name|
  step %{I should not see "#{name}" within ".scopes"}
end

Then /^I should see the scope "([^"]*)" selected$/ do |name|
  step %{I should see "#{name}" within ".scopes .selected"}
end

Then /^I should see the scope "([^"]*)" not selected$/ do |name|
  step %{I should see the scope "#{name}"}
  page.should_not have_css('.scopes .selected', :text => name)
end

Then /^I should see the scope "([^"]*)" with the count (\d+)$/ do |name, count|
  step %{I should see "#{count}" within ".scopes .#{name.gsub(" ", "").underscore.downcase} .count"}
end

Then /^I should see the scope "([^"]*)" with no count$/ do |name|
  page.should have_css(".scopes .#{name.gsub(" ", "").underscore.downcase}")
  page.should_not have_css(".scopes .#{name.gsub(" ", "").underscore.downcase} .count")
end

Then /^I should see (\d+) ([\w]*) in the table$/ do |count, resource_type|
  begin
    page.should have_css("table#index_table_#{resource_type} tr > td:first", :count => count.to_i)
  rescue
    current_count = 0

    all("table#index_table_#{resource_type} tr > td:first").each { current_count += 1 }

    raise "There were #{current_count} rows in the table not #{count}"
  end
end
When /^I click "(.*?)"$/ do |link|
  click_link(link)
endThen /^I should see the Active Admin layout$/ do
  page.should have_css("#active_admin_content #main_content_wrapper")
end
Then /^I should see an action item button "([^"]*)"$/ do |content|
  page.should have_css(".action_items a", :text => content)
end

Then /^I should not see an action item button "([^"]*)"$/ do |content|
  page.should_not have_css(".action_items", :text => content)
end
Then /^I should see a menu item for "([^"]*)"$/ do |name|
  page.should have_css('#tabs li a', :text => name)
end

Then /^I should not see a menu item for "([^"]*)"$/ do |name|
  page.should_not have_css('#tabs li a', :text => name)
end

Then /^I should see a nested menu item for "([^"]*)"$/ do |name|
  page.should have_css('#tabs > li > ul > li > a', :text => name)
end
Then /^I should not see pagination$/ do
  page.should_not have_css(".pagination")
end

Then /^I should see pagination with (\d+) pages$/ do |count|
  step %{I should see "#{count}" within ".pagination a"}
  step %{I should not see "#{count.to_i + 1}" within ".pagination a"}
end
Then /^I should see a sidebar titled "([^"]*)"$/ do |title|
  page.should have_css(".sidebar_section h3", :text => title)
end

Then /^I should not see a sidebar titled "([^"]*)"$/ do |title|
  page.all(:css, "##{title.gsub(" ", '').underscore}_sidebar_section").count.should == 0
end
Then /^I should see the site title "([^"]*)"$/ do |title|
  page.should have_css('h1#site_title', :text => title)
end

Then /^I should not see the site title "([^"]*)"$/ do |title|
  page.should_not have_css('h1#site_title', :text => title)
end

Then /^I should see the site title image "([^"]*)"$/ do |image|
  page.should have_css('h1#site_title img', :src => image)
end

Then /^I should see the site title image linked to "([^"]*)"$/ do |url|
  page.should have_css('h1#site_title a', :href => url)
endThen /^the "([^"]*)" tab should be selected$/ do |name|
  step %{I should see "#{name}" within "ul#tabs li.current"}
end
class HtmlTableToTextHelper
  def initialize(html, table_css_selector = "table")
    @html = html
    @selector = table_css_selector
  end

  def to_array
    rows = Nokogiri::HTML(@html).css("#{@selector} tr")
    rows.map do |row|
      row.css('th, td').map do |td|
        cell_to_string(td)
      end
    end 
  end

  private

  def cell_to_string(td)
    str = ""
    input = td.css('input').last

    if input
      str << input_to_string(input)
    end

    str << td.content.strip.gsub("\n", ' ')
  end

  def input_to_string(input)
    case input.attribute("type").value
    when "checkbox"
      if input.attribute("disabled")
        "_"
      else
        if input.attribute("checked")
          "[X]"
        else
          "[ ]"
        end
      end
    when "text"
      if input.attribute("value").present?
        "[#{input.attribute("value")}]"
      else
        "[ ]"
      end
    when "submit"
      input.attribute("value")
    else
      raise "I don't know what to do with #{input}"
    end
  end
end

module TableMatchHelper


  # @param table [Array[Array]]
  # @param expected_table [Array[Array[String]]]
  # The expected_table values are String. They are converted to
  # Regexp when they start and end with a '/'
  # Example:
  #
  #   assert_table_match(
  #     [["Name", "Date"], ["Philippe", "Feb 08"]],
  #     [["Name", "Date"], ["Philippe", "/\w{3} \d{2}/"]]
  #   )
  def assert_tables_match(table, expected_table)
    expected_table.each_index do |row_index|
      expected_table[row_index].each_index do |column_index|
        expected_cell = expected_table[row_index][column_index]
        cell = table.try(:[], row_index).try(:[], column_index)
        begin
          assert_cells_match(cell, expected_cell)
        rescue
          puts "Cell at line #{row_index} and column #{column_index}: #{cell.inspect} does not match #{expected_cell.inspect}"
          puts "Expecting:"
          table.each { |row| puts row.inspect }
          puts "to match:"
          expected_table.each { |row| puts row.inspect }
          raise $!
        end
      end
    end
  end

  def assert_cells_match(cell, expected_cell)
    if expected_cell =~ /^\/.*\/$/
      cell.should match(Regexp.new(expected_cell[1..-2]))
    else
      (cell || "").strip.should == expected_cell
    end
  end

end # module TableMatchHelper

World(TableMatchHelper)


# Usage:
#
#   I should see the "invoices" table:
#     | Invoice #    | Date     | Total Amount |
#     |    /\d+/     | 27/01/12 |       $30.00 |
#     |    /\d+/     | 12/02/12 |       $25.00 |
#
Then /^I should see the "([^"]*)" table:$/ do |table_id, expected_table|
  page.should have_css("table##{table_id}")

  assert_tables_match(
    HtmlTableToTextHelper.new(page.body, "table##{table_id}").to_array,
    expected_table.raw
  )
end
Given /^I am logged out$/ do
  if page.all(:css, "a", :text => "Logout").size > 0
    click_link "Logout"
  end
end

Given /^I am logged in$/ do
  create_admin_user_and_logout_if_needed
  user = AdminUser.find_by_email "admin@example.com"
  login_as(user)
end

# only for @requires-reloading scenario
Given /^I am logged in with capybara$/ do
  create_admin_user_and_logout_if_needed

  visit new_admin_user_session_path
  fill_in "Email", :with => "admin@example.com"
  fill_in "Password", :with => "password"
  click_button "Login"
end

def create_admin_user_and_logout_if_needed
  step 'an admin user "admin@example.com" exists'

  if page.all(:css, "a", :text => "Logout").size > 0
    click_link "Logout"
  end
end

Given /^an admin user "([^"]*)" exists$/ do |admin_email|
  user = AdminUser.find_or_create_by_email :email => admin_email,
                                           :password => "password",
                                           :password_confirmation => "password"

  unless user.persisted?
    puts "Coult not create an admin user #{admin_email}: #{user.errors.full_messages}"
    raise "Could not create an admin user"
  end
end

Given /^an admin user "([^"]*)" exists with (expired )?reset password token "(.*?)"$/ do |admin_email, expired, token|
  user = AdminUser.find_or_create_by_email :email => admin_email,
                                           :password => "password",
                                           :password_confirmation => "password"

  unless user.persisted?
    puts "Coult not create an admin user #{admin_email}: #{user.errors.full_messages}"
    raise "Could not create an admin user"
  end

  user.reset_password_token = token
  user.reset_password_sent_at = 1.minute.ago unless expired
  user.save
end
# TL;DR: YOU SHOULD DELETE THIS FILE
#
# This file was generated by Cucumber-Rails and is only here to get you a head start
# These step definitions are thin wrappers around the Capybara/Webrat API that lets you
# visit pages, interact with widgets and make assertions about page content.
#
# If you use these step definitions as basis for your features you will quickly end up
# with features that are:
#
# * Hard to maintain
# * Verbose to read
#
# A much better approach is to write your own higher level step definitions, following
# the advice in the following blog posts:
#
# * http://benmabey.com/2008/05/19/imperative-vs-declarative-scenarios-in-user-stories.html
# * http://dannorth.net/2011/01/31/whose-domain-is-it-anyway/
# * http://elabs.se/blog/15-you-re-cuking-it-wrong
#


require 'uri'
require 'cgi'
require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "paths"))
require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "selectors"))

module WithinHelpers
  def with_scope(locator)
    locator ? within(*selector_for(locator)) { yield } : yield
  end
end
World(WithinHelpers)

# Single-line step scoper
When /^(.*) within (.*[^:])$/ do |step_name, parent|
  with_scope(parent) { step step_name }
end

# Multi-line step scoper
When /^(.*) within (.*[^:]):$/ do |step_name, parent, table_or_string|
  with_scope(parent) { step "#{step_name}:", table_or_string }
end

Given /^(?:|I )am on (.+)$/ do |page_name|
  visit path_to(page_name)
end

When /^(?:|I )go to (.+)$/ do |page_name|
  visit path_to(page_name)
end

When /^(?:|I )press "([^"]*)"$/ do |button|
  click_button(button)
end

When /^(?:|I )follow "([^"]*)"$/ do |link|
  click_link(link)
end

When /^(?:|I )fill in "([^"]*)" with "([^"]*)"$/ do |field, value|
  fill_in(field, :with => value)
end

When /^(?:|I )fill in "([^"]*)" for "([^"]*)"$/ do |value, field|
  fill_in(field, :with => value)
end

# Use this to fill in an entire form with data from a table. Example:
#
#   When I fill in the following:
#     | Account Number | 5002       |
#     | Expiry date    | 2009-11-01 |
#     | Note           | Nice guy   |
#     | Wants Email?   |            |
#
# TODO: Add support for checkbox, select og option
# based on naming conventions.
#
When /^(?:|I )fill in the following:$/ do |fields|
  fields.rows_hash.each do |name, value|
    When %{I fill in "#{name}" with "#{value}"}
  end
end

When /^(?:|I )select "([^"]*)" from "([^"]*)"$/ do |value, field|
  select(value, :from => field)
end

When /^(?:|I )check "([^"]*)"$/ do |field|
  check(field)
end

When /^(?:|I )uncheck "([^"]*)"$/ do |field|
  uncheck(field)
end

When /^(?:|I )choose "([^"]*)"$/ do |field|
  choose(field)
end

When /^(?:|I )attach the file "([^"]*)" to "([^"]*)"$/ do |path, field|
  attach_file(field, File.expand_path(path))
end

Then /^(?:|I )should see "([^"]*)"$/ do |text|
  if page.respond_to? :should
    page.should have_content(text)
  else
    assert page.has_content?(text)
  end
end

Then /^(?:|I )should see \/([^\/]*)\/$/ do |regexp|
  regexp = Regexp.new(regexp)

  if page.respond_to? :should
    page.should have_xpath('//*', :text => regexp)
  else
    assert page.has_xpath?('//*', :text => regexp)
  end
end

Then /^(?:|I )should not see "([^"]*)"$/ do |text|
  if page.respond_to? :should
    page.should have_no_content(text)
  else
    assert page.has_no_content?(text)
  end
end

Then /^(?:|I )should not see \/([^\/]*)\/$/ do |regexp|
  regexp = Regexp.new(regexp)

  if page.respond_to? :should
    page.should have_no_xpath('//*', :text => regexp)
  else
    assert page.has_no_xpath?('//*', :text => regexp)
  end
end

Then /^the "([^"]*)" field(?: within (.*))? should contain "([^"]*)"$/ do |field, parent, value|
  with_scope(parent) do
    field = find_field(field)
    field_value = (field.tag_name == 'textarea') ? field.text : field.value
    if field_value.respond_to? :should
      field_value.should =~ /#{value}/
    else
      assert_match(/#{value}/, field_value)
    end
  end
end

Then /^the "([^"]*)" field(?: within (.*))? should not contain "([^"]*)"$/ do |field, parent, value|
  with_scope(parent) do
    field = find_field(field)
    field_value = (field.tag_name == 'textarea') ? field.text : field.value
    if field_value.respond_to? :should_not
      field_value.should_not =~ /#{value}/
    else
      assert_no_match(/#{value}/, field_value)
    end
  end
end

Then /^the "([^"]*)" checkbox(?: within (.*))? should be checked$/ do |label, parent|
  with_scope(parent) do
    field_checked = find_field(label)['checked']
    if field_checked.respond_to? :should
      field_checked.should be_true
    else
      assert field_checked
    end
  end
end

Then /^the "([^"]*)" checkbox(?: within (.*))? should not be checked$/ do |label, parent|
  with_scope(parent) do
    field_checked = find_field(label)['checked']
    if field_checked.respond_to? :should
      field_checked.should be_false
    else
      assert !field_checked
    end
  end
end
 
Then /^(?:|I )should be on (.+)$/ do |page_name|
  current_path = URI.parse(current_url).path
  if current_path.respond_to? :should
    current_path.should == path_to(page_name)
  else
    assert_equal path_to(page_name), current_path
  end
end

Then /^(?:|I )should have the following query string:$/ do |expected_pairs|
  query = URI.parse(current_url).query
  actual_params = query ? CGI.parse(query) : {}
  expected_params = {}
  expected_pairs.rows_hash.each_pair{|k,v| expected_params[k] = v.split(',')} 
  
  if actual_params.respond_to? :should
    actual_params.should == expected_params
  else
    assert_equal expected_params, actual_params
  end
end

Then /^show me the page$/ do
  save_and_open_page
end
# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a 
# newer version of cucumber-rails. Consider adding your own code to a new file 
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

ENV["RAILS_ENV"] ||= "cucumber"
ENV['BUNDLE_GEMFILE'] = File.expand_path('../../../Gemfile', __FILE__)
require "rubygems"
require "bundler"
Bundler.setup

require File.expand_path('../../../spec/support/detect_rails_version', __FILE__)
ENV["RAILS"] = detect_rails_version

ENV['RAILS_ROOT'] = File.expand_path("../../../spec/rails/rails-#{ENV["RAILS"]}", __FILE__)


# Create the test app if it doesn't exists
unless File.exists?(ENV['RAILS_ROOT'])
  system 'rake setup'
end

# Ensure the Active Admin load path is happy
require 'rails'
require 'active_admin'
ActiveAdmin.application.load_paths = [ENV['RAILS_ROOT'] + "/app/admin"]

require ENV['RAILS_ROOT'] + '/config/environment'

# Setup autoloading of ActiveAdmin and the load path
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
autoload :ActiveAdmin, 'active_admin'

require 'cucumber/rails'

require 'capybara/rails'
require 'capybara/cucumber'
require 'capybara/session'
# Capybara defaults to XPath selectors rather than Webrat's default of CSS3. In
# order to ease the transition to Capybara we set the default here. If you'd
# prefer to use XPath just remove this line and adjust any selectors in your
# steps to use the XPath syntax.
Capybara.default_selector = :css

# If you set this to false, any error raised from within your app will bubble 
# up to your step definition and out to cucumber unless you catch it somewhere
# on the way. You can make Rails rescue errors and render error pages on a
# per-scenario basis by tagging a scenario or feature with the @allow-rescue tag.
#
# If you set this to true, Rails will rescue all errors and render error
# pages, more or less in the same way your application would behave in the
# default production environment. It's not recommended to do this for all
# of your scenarios, as this makes it hard to discover errors in your application.
ActionController::Base.allow_rescue = false

# If you set this to true, each scenario will run in a database transaction.
# You can still turn off transactions on a per-scenario basis, simply tagging 
# a feature or scenario with the @no-txn tag. If you are using Capybara,
# tagging with @culerity or @javascript will also turn transactions off.
#
# If you set this to false, transactions will be off for all scenarios,
# regardless of whether you use @no-txn or not.
#
# Beware that turning transactions off will leave data in your database 
# after each scenario, which can lead to hard-to-debug failures in 
# subsequent scenarios. If you do this, we recommend you create a Before
# block that will explicitly put your database in a known state.
Cucumber::Rails::World.use_transactional_fixtures = false
# How to clean your database when transactions are turned off. See
# http://github.com/bmabey/database_cleaner for more info.
if defined?(ActiveRecord::Base)
  begin
    require 'database_cleaner'
    require 'database_cleaner/cucumber'
    DatabaseCleaner.strategy = :truncation
  rescue LoadError => ignore_if_database_cleaner_not_present
  end
end

def add_default_dashboard
  begin
    dashboard_file = ENV['RAILS_ROOT'] + "/app/admin/dashboard.rb"
    dashboard_template = File.expand_path('../../../lib/generators/active_admin/install/templates/dashboard.rb', __FILE__)
    cmd = "cp #{dashboard_template} #{dashboard_file}"
    system cmd
  rescue
    p $!
    raise $!
  end
end

def delete_default_dashboard
  begin
    dashboard_file = ENV['RAILS_ROOT'] + "/app/admin/dashboard.rb"
    File.delete(dashboard_file) if File.exists?(dashboard_file)
  rescue
    p $!
    raise $!
  end
end

# Warden helpers to speed up login
# See https://github.com/plataformatec/devise/wiki/How-To:-Test-with-Capybara
include Warden::Test::Helpers

After do
  add_default_dashboard
  Warden.test_reset!

  # Reset back to the default auth adapter
  ActiveAdmin.application.namespace(:admin).
    authorization_adapter = ActiveAdmin::AuthorizationAdapter
end

Before '@dashboard' do
  delete_default_dashboard
end

Before do
  add_default_dashboard

  begin
    # We are caching classes, but need to manually clear references to
    # the controllers. If they aren't clear, the router stores references
    ActiveSupport::Dependencies.clear

    # Reload Active Admin
    ActiveAdmin.unload!
    ActiveAdmin.load!
  rescue
    p $!
    raise $!
  end
end

# improve the performance of the specs suite by not logging anything
# see http://blog.plataformatec.com.br/2011/12/three-tips-to-improve-the-performance-of-your-test-suite/
Rails.logger.level = 4
module NavigationHelpers
  # Maps a name to a path. Used by the
  #
  #   When /^I go to (.+)$/ do |page_name|
  #
  # step definition in web_steps.rb
  #
  def path_to(page_name)
    case page_name

    when /the home\s?page/
      '/'
    when /the dashboard/
      "/admin"
    when /the new post page/
      "/admin/posts/new"
    when /the admin password reset form with reset password token "([^"]*)"/
      "/admin/password/edit?reset_password_token=#{$1}"

    # the index page for posts in the root namespace
    # the index page for posts in the user_admin namespace
    when /^the index page for (.*) in the (.*) namespace$/
      if $2 != 'root'
        send(:"#{$2}_#{$1}_path")
      else
        send(:"#{$1}_path")
      end

    # same as above, except defaults to admin namespace
    when /^the index page for (.*)$/
      send(:"admin_#{$1}_path")

    when /^the last author's posts$/
      admin_user_posts_path(User.last)

    when /^the last author's last post page$/
      admin_user_post_path(User.last, Post.where(:author_id => User.last.id).last)

    when /^the last post's edit page$/
      edit_admin_post_path(Post.last)

    # Add more mappings here.
    # Here is an example that pulls values out of the Regexp:
    #
    #   when /^(.*)'s profile page$/i
    #     user_profile_path(User.find_by_login($1))

    else
      begin
        page_name =~ /the (.*) page/
        path_components = $1.split(/\s+/)
        self.send(path_components.push('path').join('_').to_sym)
      rescue Object => e
        raise "Can't find mapping from \"#{page_name}\" to a path.\n" +
          "Now, go and add a mapping in #{__FILE__}"
      end
    end
  end
end

World(NavigationHelpers)
module HtmlSelectorsHelpers
  # Maps a name to a selector. Used primarily by the
  #
  #   When /^(.+) within (.+)$/ do |step, scope|
  #
  # step definitions in web_steps.rb
  #
  def selector_for(locator)
    case locator

    when "the page"
      "html > body"

    # Add more mappings here.
    # Here is an example that pulls values out of the Regexp:
    #
    #  when /^the (notice|error|info) flash$/
    #    ".flash.#{$1}"

    # You can also return an array to use a different selector
    # type, like:
    #
    #  when /the header/
    #    [:xpath, "//header"]

    when "index grid"
      [:css, "table.index_grid"]

    when /^the "([^"]*)" sidebar$/
      [:css, "##{$1.gsub(" ", '').underscore}_sidebar_section"]

    # This allows you to provide a quoted selector as the scope
    # for "within" steps as was previously the default for the
    # web steps:
    when /^"(.+)"$/
      $1

    else
      raise "Can't find mapping from \"#{locator}\" to a selector.\n" +
        "Now, go and add a mapping in #{__FILE__}"
    end
  end
end

World(HtmlSelectorsHelpers)
module ActiveAdmin
  class AbstractViewFactory
    @@default_views = {}

    def self.register(view_hash)
      view_hash.each do |view_key, view_class|
        @@default_views[view_key] = view_class
      end
    end

    def initialize
      @views = {}
    end

    # Register a new view key with the view factory
    #
    # eg:
    #   
    #   factory = AbstractViewFactory.new
    #   factory.register :my_view => SomeViewClass
    #
    # You can setup many at the same time:
    #
    #   factory.register  :my_view => SomeClass,
    #                     :another_view => OtherViewClass
    #
    def register(view_hash)
      view_hash.each do |view_key, view_class|
        @views[view_key] = view_class
      end
    end

    def default_for(key)
      @@default_views[key.to_sym]
    end

    def has_key?(key)
      @views.has_key?(key.to_sym) || @@default_views.has_key?(key.to_sym)
    end

    def [](key)
      get_view_for_key(key)
    end

    def []=(key, value)
      set_view_for_key(key, value)
    end

    # Override respond to to include keys
    def respond_to?(method)
      key = key_from_method_name(method)
      if has_key?(key)
        true
      else
        super
      end
    end

    private

    def method_missing(method, *args)
      key = key_from_method_name(method)
      if has_key?(key)
        if method.to_s.include?('=')
          self.class_eval <<-EOS
            def #{key}=(value)
              set_view_for_key(:#{key}, value)
            end
          EOS
        else
          self.class_eval <<-EOS
            def #{key}
              get_view_for_key(:#{key})
            end
          EOS
        end
        self.send(method, *args)
      else
        super
      end
    end

    def key_from_method_name(method)
      method.to_s.gsub('=', '').to_sym
    end

    def get_view_for_key(key)
      @views[key.to_sym] || @@default_views[key.to_sym]
    end

    def set_view_for_key(key, view)
      @views[key.to_sym] = view
    end
  end
end
require 'active_admin/router'
require 'active_admin/helpers/settings'

module ActiveAdmin
  class Application
    include Settings

    # Adds settings to both the Application and the Namespace instance
    # so that they can be configured independantly.
    def self.inheritable_setting(name, default)
      Namespace.setting name, nil
      setting name, default
    end

    def self.deprecated_inheritable_setting(name, default)
      Namespace.deprecated_setting name, nil
      deprecated_setting name, default
    end

    # The default namespace to put controllers and routes inside. Set this
    # in config/initializers/active_admin.rb using:
    #
    #   config.default_namespace = :super_admin
    #
    setting :default_namespace, :admin

    # A hash of all the registered namespaces
    setting :namespaces, {}

    # Load paths for admin configurations. Add folders to this load path
    # to load up other resources for administration. External gems can
    # include their paths in this load path to provide active_admin UIs
    setting :load_paths, [File.expand_path('app/admin', Rails.root)]

    # The default number of resources to display on index pages
    inheritable_setting :default_per_page, 30

    # The title which gets displayed in the main layout
    inheritable_setting :site_title, ""

    # Set the site title link href (defaults to AA dashboard)
    inheritable_setting :site_title_link, ""

    # Set the site title image displayed in the main layout (has precendence over :site_title)
    inheritable_setting :site_title_image, ""

    # The view factory to use to generate all the view classes. Take
    # a look at ActiveAdmin::ViewFactory
    inheritable_setting :view_factory, ActiveAdmin::ViewFactory.new

    # The method to call in controllers to get the current user
    inheritable_setting :current_user_method, false

    # The method to call in the controllers to ensure that there
    # is a currently authenticated admin user
    inheritable_setting :authentication_method, false

    # The path to log user's out with. If set to a symbol, we assume
    # that it's a method to call which returns the path
    inheritable_setting :logout_link_path, :destroy_admin_user_session_path

    # The method to use when generating the link for user logout
    inheritable_setting :logout_link_method, :get

    # Whether the batch actions are enabled or not
    inheritable_setting :batch_actions, false

    # Whether filters are enabled
    inheritable_setting :filters, true

    # The namespace root.
    inheritable_setting :root_to, 'dashboard#index'

    # Default CSV options
    inheritable_setting :csv_options, {}

    # Default Download Links options
    inheritable_setting :download_links, true

    # The authorization adapter to use
    inheritable_setting :authorization_adapter, ActiveAdmin::AuthorizationAdapter

    # A proc to be used when a user is not authorized to view the current resource
    inheritable_setting :on_unauthorized_access, :rescue_active_admin_access_denied

    # Active Admin makes educated guesses when displaying objects, this is
    # the list of methods it tries calling in order
    setting :display_name_methods, [ :display_name,
                                      :full_name,
                                      :name,
                                      :username,
                                      :login,
                                      :title,
                                      :email,
                                      :to_s ]

    # == Deprecated Settings

    # @deprecated Default CSV separator will be removed in 0.6.0. Use `csv_options = { :col_sep => ',' }` instead.
    deprecated_inheritable_setting :csv_column_separator, ','

    # @deprecated The default sort order for index pages
    deprecated_setting :default_sort_order, 'id_desc'

    # DEPRECATED: This option is deprecated and will be removed. Use
    # the #allow_comments_in option instead
    attr_accessor :admin_notes

    include AssetRegistration

    # Event that gets triggered on load of Active Admin
    BeforeLoadEvent = 'active_admin.application.before_load'.freeze
    AfterLoadEvent = 'active_admin.application.after_load'.freeze

    def setup!
      register_default_assets
    end

    def prepare!
      remove_active_admin_load_paths_from_rails_autoload_and_eager_load
      attach_reloader
      generate_stylesheets
    end

    # Registers a brand new configuration for the given resource.
    def register(resource, options = {}, &block)
      ns_name = namespace_name(options)
      namespace(ns_name).register resource, options, &block
    end

    # Creates a namespace for the given name
    #
    # Yields the namespace if a block is given
    #
    # @returns [Namespace] the new or existing namespace
    def namespace(name)
      name ||= :root

      if namespaces[name]
        namespace = namespaces[name]
      else
        namespace = namespaces[name] = Namespace.new(self, name)
        ActiveAdmin::Event.dispatch ActiveAdmin::Namespace::RegisterEvent, namespace
      end

      yield(namespace) if block_given?

      namespace
    end

    # Register a page
    #
    # @param name [String] The page name
    # @options [Hash] Accepts option :namespace.
    # @&block The registration block.
    #
    def register_page(name, options = {}, &block)
      ns_name = namespace_name(options)
      namespace(ns_name).register_page name, options, &block
    end

    # Whether all configuration files have been loaded
    def loaded?
      @@loaded ||= false
    end

    # Removes all defined controllers from memory. Useful in
    # development, where they are reloaded on each request.
    def unload!
      namespaces.values.each{ |namespace| namespace.unload! }
      @@loaded = false
    end

    # Loads all ruby files that are within the load_paths setting.
    # To reload everything simply call `ActiveAdmin.unload!`
    def load!
      unless loaded?
        ActiveAdmin::Event.dispatch BeforeLoadEvent, self # before_load hook
        files.each{ |file| load file }                    # load files
        namespace(nil)                                    # init AA resources
        ActiveAdmin::Event.dispatch AfterLoadEvent, self  # after_load hook
        @@loaded = true
      end
    end

    # Returns ALL the files to be loaded
    def files
      load_paths.flatten.compact.uniq.map{ |path| Dir["#{path}/**/*.rb"] }.flatten
    end

    def router
      @router ||= Router.new(self)
    end

    # One-liner called by user's config/routes.rb file
    def routes(rails_router)
      load!
      router.apply(rails_router)
    end

    # Add before, around and after filters to each registered resource and pages.
    # For example:
    #   ActiveAdmin.before_filter :authenticate_admin!
    #
    %w(before_filter skip_before_filter after_filter around_filter).each do |name|
      define_method name do |*args, &block|
        BaseController.send name, *args, &block
      end
    end

    # Helper method to add a dashboard section
    def dashboard_section(name, options = {}, &block)
      ActiveAdmin::Dashboards.add_section(name, options, &block)
    end

    private

    # Return either the passed in namespace or the default
    def namespace_name(options)
      options.fetch(:namespace){ default_namespace }
    end

    def register_default_assets
      register_stylesheet 'active_admin.css', :media => 'screen'
      register_stylesheet 'active_admin/print.css', :media => 'print'

      unless ActiveAdmin.use_asset_pipeline?
        register_javascript 'jquery.min.js'
        register_javascript 'jquery-ui.min.js'
        register_javascript 'jquery_ujs.js'
      end

      register_javascript 'active_admin.js'
    end

    # Since we're dealing with all our own file loading, we need
    # to remove our paths from the ActiveSupport autoload paths.
    # If not, file naming becomes very important and can cause clashes.
    def remove_active_admin_load_paths_from_rails_autoload_and_eager_load
      ActiveSupport::Dependencies.autoload_paths.reject!{|path| load_paths.include?(path) }
      # Don't eagerload our configs, we'll deal with them ourselves
      Rails.application.config.eager_load_paths = Rails.application.config.eager_load_paths.reject do |path|
        load_paths.include?(path)
      end
    end

    def attach_reloader
      ActiveAdmin::Reloader.build(Rails.application, self, Rails.version).attach!
    end

    def generate_stylesheets
      # Create our own asset pipeline in Rails 3.0
      if ActiveAdmin.use_asset_pipeline?
        # Add our mixins to the load path for SASS
        ::Sass::Engine::DEFAULT_OPTIONS[:load_paths] <<  File.expand_path("../../../app/assets/stylesheets", __FILE__)
      else
        require 'active_admin/sass/css_loader'
        ::Sass::Plugin.add_template_location(File.expand_path("../../../app/assets/stylesheets", __FILE__))
        ::Sass::Plugin.add_template_location(File.expand_path("../sass", __FILE__))
      end
    end
  end
end
module ActiveAdmin
  module AssetRegistration

    # Stylesheets

    def register_stylesheet(*args)
      stylesheets << ActiveAdmin::Stylesheet.new(*args)
    end

    def stylesheets
      @stylesheets ||= []
    end

    def clear_stylesheets!
      @stylesheets = []
    end


    # Javascripts

    def register_javascript(name)
      javascripts << name
    end

    def javascripts
      @javascripts ||= []
    end

    def clear_javascripts!
      @javascripts = []
    end

  end
  
  # Wrapper class for stylesheet registration
  class Stylesheet
    
    attr_reader :options, :path
    
    def initialize(*args)
      @options = args.extract_options!
      @path = args.first if args.first
    end
    
  end
  
end
module ActiveAdmin

  # Default Authorization permissions for Active Admin
  module Authorization
    READ    = :read
    CREATE  = :create
    UPDATE  = :update
    DESTROY = :destroy
  end

  Auth = Authorization


  # Active Admin's default authorization adapter. This adapter returns true
  # for all requests to `#authorized?`. It should be the starting point for
  # implementing your own authorization adapter.
  #
  # To view an example subclass, check out `ActiveAdmin::CanCanAdapter`
  class AuthorizationAdapter
    attr_reader :resource, :user


    # Initialize a new authorization adapter. This happens on each and
    # every request to a controller.
    #
    # @param [ActiveAdmin::Resource, ActiveAdmin::Page] resource The resource
    #        that the user is currently on. Note, we may be authorizing access
    #        to a different subject, so don't rely on this other than to
    #        pull configuration information from.
    #
    # @param [any] user The current user. The user is set to whatever is returned
    #        from `#current_active_admin_user` in the controller.
    #
    def initialize(resource, user)
      @resource = resource
      @user = user
    end

    # Returns true of false depending on if the user is authorized to perform
    # the action on the subject.
    #
    # @param [Symbol] action The name of the action to perform. Usually this will be
    #        one of the `ActiveAdmin::Auth::*` symbols.
    #
    # @param [any] subject The subject the action is being performed on usually this
    #        is a model object. Note, that this is NOT always in instance, it can be 
    #        the class of the subject also. For example, Active Admin uses the class
    #        of the resource to decide if the resource should be displayed in the 
    #        global navigation. To deal with this nicely in a case statement, take
    #        a look at `#normalized(klasss)`
    #
    # @returns [Boolean]
    def authorized?(action, subject = nil)
      true
    end


    # A hook method for authorization libraries to scope the collection. By
    # default, we just return the same collection. The returned scope is used
    # as the starting point for all queries to the db in the controller.
    #
    # @param [ActiveRecord::Relation] collection The collection the user is
    #        attempting to view.
    #
    # @returns [ActiveRecord::Relation] A new collection, scoped to the 
    #          objects that the current user has access to.
    def scope_collection(collection)
      collection
    end

    private

    # The `#authorized?` method's subject can be set to both instances as well
    # as classes of objects. This can make it much difficult to create simple
    # case statements for authorization since you have to handle both the 
    # class level match and the instance level match.
    #
    # For example:
    #
    #     class MyAuthAdapter < ActiveAdmin::AuthorizationAdapter
    #
    #       def authorized?(action, subject = nil)
    #         case subject
    #         when Post
    #           true
    #         when Class
    #           if subject == Post
    #             true
    #           end
    #         end
    #       end
    #
    #     end
    #
    # To handle this, the normalized method takes care of returning a object
    # which implements `===` to be matched in a case statement.
    #
    # The above now becomes:
    #
    #     class MyAuthAdapter < ActiveAdmin::AuthorizationAdapter
    #
    #       def authorized?(action, subject = nil)
    #         case subject
    #         when normalized(Post)
    #           true
    #         end
    #       end
    #
    #     end
    def normalized(klass)
      NormalizedMatcher.new(klass)
    end

    class NormalizedMatcher

      def initialize(klass)
        @klass = klass
      end

      def ===(other)
        @klass == other || other.is_a?(@klass)
      end

    end

  end

end
module ActiveAdmin

  # Exception class to raise when there is an authorized access
  # exception thrown. The exception has a few goodies that may 
  # be useful for capturing / recognizing security issues.
  class AccessDenied < StandardError
    attr_reader :user, :action, :subject

    def initialize(user, action, subject)
      @user, @action, @subject = user, action, subject

      super()
    end

    def message
      I18n.t("active_admin.access_denied.message")
    end
  end


  class BaseController < ::InheritedResources::Base
    module Authorization
      include MethodOrProcHelper
      extend ActiveSupport::Concern

      ACTIONS_DICTIONARY = {
        :index   => ActiveAdmin::Authorization::READ,
        :show    => ActiveAdmin::Authorization::READ,
        :new     => ActiveAdmin::Authorization::CREATE,
        :create  => ActiveAdmin::Authorization::CREATE,
        :edit    => ActiveAdmin::Authorization::UPDATE,
        :update  => ActiveAdmin::Authorization::UPDATE,
        :destroy => ActiveAdmin::Authorization::DESTROY
      }

      included do
        rescue_from ActiveAdmin::AccessDenied, :with => :dispatch_active_admin_access_denied

        helper_method :authorized?
        helper_method :authorize!
      end

      protected

      # Authorize the action and subject. Available in the controller
      # as well as all the views. 
      #
      # @param [Symbol] action The action to check if the user has permission
      #                 to perform on the subject.
      #
      # @param [any] subject The subject that the user is trying to perform
      #                 the action on.
      #
      # @returns [Boolean]
      #
      def authorized?(action, subject = nil)
        active_admin_authorization.authorized?(action, subject)
      end


      # Authorize the action and subject. Available in the controller
      # as well as all the views. If the action is not allowd, it raises
      # an ActiveAdmin::AccessDenied exception.
      #
      # @param [Symbol] action The action to check if the user has permission
      #                 to perform on the subject.
      #
      # @param [any] subject The subject that the user is trying to perform
      #                 the action on.
      #
      # @returns [Boolean] True if authorized, otherwise raises
      #                 an ActiveAdmin::AccessDenied.
      def authorize!(action, subject = nil)
        unless authorized? action, subject
          raise ActiveAdmin::AccessDenied.new(current_active_admin_user,
                                              action,
                                              subject)
        end
      end

      # Performs authorization on the resource using the current controller
      # action as the permission action.
      #
      def authorize_resource!(resource)
        permission = action_to_permission(params[:action])
        authorize! permission, resource
      end

      # Retrieve or instantiate the authorization instance for this resource
      #
      # @returns [ActiveAdmin::AuthorizationAdapter]
      def active_admin_authorization
        @active_admin_authorization ||= active_admin_authorization_adapter.new(active_admin_config, current_active_admin_user)
      end

      # Returns the class to be used as the authorization adapter
      #
      # @returns [Class]
      def active_admin_authorization_adapter
        if active_admin_namespace.authorization_adapter.is_a?(String)
          ActiveSupport::Dependencies.constantize(active_admin_namespace.authorization_adapter)
        else
          active_admin_namespace.authorization_adapter
        end
      end

      # Converts a controller action into one of the correct Active Admin
      # authorization names. Uses the ACTIONS_DICTIONARY to convert the
      # action name to permission.
      #
      # @param [String, Symbol] action The controller action name.
      #
      # @returns [Symbol] The permission name to use.
      def action_to_permission(action)
        return nil unless action

        action = action.to_sym

        if Authorization::ACTIONS_DICTIONARY.has_key?(action)
          Authorization::ACTIONS_DICTIONARY[action]
        else
          action
        end
      end

      def dispatch_active_admin_access_denied(exception)
        call_method_or_exec_proc active_admin_namespace.on_unauthorized_access, exception
      end

      def rescue_active_admin_access_denied(exception)
        error_message = exception.message

        respond_to do |format|
          format.html do
            flash[:error] = error_message

            if request.headers.keys.include?("HTTP_REFERER")
              redirect_to :back
            else
              controller, action = active_admin_namespace.root_to.split("#")
              redirect_to :controller => controller, :action => action
            end
          end

          format.csv { render :text => error_message, :status => :unauthorized}
          format.json { render :json => { :error => error_message }, :status => :unauthorized}
          format.xml { render :xml => "<error>#{error_message}</error>", :status => :unauthorized}
        end
      end

    end
  end
end
module ActiveAdmin
  class BaseController < ::InheritedResources::Base
    module Menu
      extend ActiveSupport::Concern

      included do
        before_filter :set_current_tab
        helper_method :current_menu
      end

      protected

      def current_menu
        active_admin_config.navigation_menu
      end

      # Set's @current_tab to be name of the tab to mark as current
      # Get's called through a before filter
      def set_current_tab
        @current_tab = if current_menu && active_admin_config.belongs_to? && parent?
          parent_item = active_admin_config.belongs_to_config.target.menu_item
          if current_menu.include? parent_item
            parent_item
          else
            active_admin_config.menu_item
          end
        else
          active_admin_config.menu_item
        end
      end

    end
  end
end
require 'inherited_resources'

require 'active_admin/base_controller/authorization'
require 'active_admin/base_controller/menu'

module ActiveAdmin
  # BaseController for ActiveAdmin. 
  # It implements ActiveAdmin controllers core features.
  class BaseController < ::InheritedResources::Base
    helper ::ActiveAdmin::ViewHelpers

    layout :determine_active_admin_layout

    before_filter :only_render_implemented_actions
    before_filter :authenticate_active_admin_user

    class << self
      # Ensure that this method is available for the DSL
      public :actions

      # Reference to the Resource object which initialized
      # this controller
      attr_accessor :active_admin_config
    end

    # By default Rails will render un-implemented actions when the view exists. Becuase Active
    # Admin allows you to not render any of the actions by using the #actions method, we need
    # to check if they are implemented.
    def only_render_implemented_actions
      raise AbstractController::ActionNotFound unless action_methods.include?(params[:action])
    end

    include Menu
    include Authorization

    private

    # Calls the authentication method as defined in ActiveAdmin.authentication_method
    def authenticate_active_admin_user
      send(active_admin_namespace.authentication_method) if active_admin_namespace.authentication_method
    end

    def current_active_admin_user
      send(active_admin_namespace.current_user_method) if active_admin_namespace.current_user_method
    end
    helper_method :current_active_admin_user

    def current_active_admin_user?
      !current_active_admin_user.nil?
    end
    helper_method :current_active_admin_user?

    def active_admin_config
      self.class.active_admin_config
    end
    helper_method :active_admin_config

    def active_admin_namespace
      active_admin_config.namespace
    end
    helper_method :active_admin_namespace


    ACTIVE_ADMIN_ACTIONS = [:index, :show, :new, :create, :edit, :update, :destroy]

    # Determine which layout to use.
    #
    #   1.  If we're rendering a standard Active Admin action, we want layout(false)
    #       because these actions are subclasses of the Base page (which implements
    #       all the required layout code)
    #   2.  If we're rendering a custom action, we'll use the active_admin layout so
    #       that users can render any template inside Active Admin.
    def determine_active_admin_layout
      ACTIVE_ADMIN_ACTIONS.include?(params[:action].to_sym) ? false : 'active_admin'
    end

  end
end
module ActiveAdmin
  module BatchActions
    module Controller

      # Controller Action that get's called when submitting the batch action form
      def batch_action
        if selected_batch_action
          selected_ids = params[:collection_selection]
          selected_ids ||= []
          instance_exec selected_ids, &selected_batch_action.block
        else
          raise "Couldn't find batch action \"#{params[:batch_action]}\""
        end
      end

      protected

      def selected_batch_action
        return unless params[:batch_action].present?
        active_admin_config.batch_actions.select { |action| action.sym == params[:batch_action].to_sym }.first
      end

    end
  end
end
module ActiveAdmin

  module BatchActions
    module ResourceExtension
      def initialize(*)
        super
        @batch_actions = {}
        add_default_batch_actions
      end

      # @return [Array] The set of batch actions for this resource
      def batch_actions
        batch_actions_enabled? ? @batch_actions.values.sort : []
      end

      # @return [Boolean] If batch actions are enabled for this resource
      def batch_actions_enabled?
        # If the resource config has been set, use it. Otherwise
        # return the namespace setting
        @batch_actions_enabled.nil? ? namespace.batch_actions : @batch_actions_enabled
      end

      # Disable or Enable batch actions for this resource
      # Set to `nil` to inherit the setting from the namespace
      def batch_actions=(bool)
        @batch_actions_enabled = bool
      end

      # Add a new batch item to a resource
      # @param [String] title
      # @param [Hash] options
      # => :if is a proc that will be called to determine if the BatchAction should be displayed
      # => :sort_order is used to sort the batch actions ascending
      # => :confirm is a string which the user will have to accept in order to process the action
      #
      def add_batch_action(sym, title, options = {}, &block)
        @batch_actions[sym] = ActiveAdmin::BatchAction.new(sym, title, options, &block)
      end

      # Remove a batch action
      # @param [Symbol] sym
      # @returns [ActiveAdmin::BatchAction] the batch action, if it was present
      #
      def remove_batch_action(sym)
        @batch_actions.delete(sym.to_sym)
      end

      # Clears all the existing batch actions for this resource
      def clear_batch_actions!
        @batch_actions = {}
      end

      # Path to the batch action itself
      def batch_action_path(params = {})
        [route_collection_path(params), "batch_action"].join("/")
      end

      private

      # @return [ActiveAdmin::BatchAction] The default "delete" action
      def add_default_batch_actions
        destroy_options = {
          :priority => 100,
          :confirm => proc { I18n.t('active_admin.batch_actions.delete_confirmation', :plural_model => active_admin_config.plural_resource_label.downcase) },
          :if => proc{ controller.action_methods.include?('destroy') && authorized?(ActiveAdmin::Auth::DESTROY, active_admin_config.resource_class) }
        }

        add_batch_action :destroy, proc { I18n.t('active_admin.delete') }, destroy_options do |selected_ids|
          active_admin_config.resource_class.find(selected_ids).each { |r| r.destroy }

          redirect_to active_admin_config.route_collection_path(params),
                      :notice => I18n.t("active_admin.batch_actions.succesfully_destroyed",
                                        :count => selected_ids.count,
                                        :model => active_admin_config.resource_label.downcase,
                                        :plural_model => active_admin_config.plural_resource_label.downcase)
        end
      end

    end
  end

  class BatchAction

    include Comparable

    attr_reader :block, :title, :sym, :confirm

    # Create a Batch Action
    #
    # Examples:
    #
    #   BatchAction.new :flag 
    # => Will create an action that appears in the action list popover
    #
    #   BatchAction.new( :flag ) { |selection| redirect_to collection_path, :notice => "#{selection.length} users flagged" }
    # => Will create an action that uses a block to process the request (which receives one paramater of the selected objects) 
    #
    #   BatchAction.new( "Perform Long Operation on the" ) { |selection| }
    # => You can create batch actions with a title instead of a Symbol
    #
    #   BatchAction.new( :flag, :if => proc { can? :flag, AdminUser  } ) { |selection| }
    # => You can provide an optional :if proc to optionally display the batch action
    #
    def initialize(sym, title, options = {}, &block)
      @sym, @title, @options, @block, @confirm = sym, title, options, block, options[:confirm]
      @block ||= proc {}
    end

    # Returns the display if block. If the block was not explicitly defined
    # a default block always returning true will be returned.
    def display_if_block
      @options[:if] || proc { true }
    end

    # Used for sorting
    def priority
      @options[:priority] || 10
    end

    # sort operator
    def <=>(other)
      self.priority <=> other.priority
    end

  end

end
require 'active_admin/component'

module ActiveAdmin
  module BatchActions

    # Build an BatchActionForm
    class BatchActionForm < ActiveAdmin::Component
      builder_method :batch_action_form

      attr_reader :prefix_html

      def build(options = {}, &block)
        options[:id] ||= "collection_selection"

        # Open a form
        text_node form_tag(active_admin_config.batch_action_path(params), :id => options[:id])
        input(:name => :batch_action, :id => :batch_action, :type => :hidden)

        super(options)
      end

      # Override the default to_s to include a closing form tag
      def to_s
        content + closing_form_tag
      end

      private

      def closing_form_tag
        '</form>'.html_safe
      end

    end
  end
end
require 'active_admin/views/components/action_list_popover'

module ActiveAdmin
  module BatchActions
    # Build an BatchActionPopover
    class BatchActionPopover < ActiveAdmin::Views::ActionListPopover
      builder_method :batch_action_popover

      def build(options = {}, &block)
        options[:id] ||= "batch_actions_popover"
        super(options)
      end

      def action(batch_action, options = {})
        options[:class] ||= []
        options[:class] += %w(batch_action)
        options.merge! "data-action" => batch_action.sym,
                       "data-confirm" => batch_action.confirm

        title = I18n.t("active_admin.batch_actions.labels.#{batch_action.sym}", :default => batch_action.title)
        label = I18n.t("active_admin.batch_actions.action_label", :title => title)

        super(label, "#", options)
      end

    end
  end
end
require 'active_admin/component'

module ActiveAdmin
  module BatchActions

    class BatchActionSelector < ActiveAdmin::Component
      builder_method :batch_action_selector

      # Build a new batch actions selector
      #
      # @param [Array] batch_actions An array of batch actions
      def build(batch_actions)
        @batch_actions = Array(batch_actions)
        @drop_down = build_drop_down
      end

      # We don't want to wrap the action list (or any other children) in
      # an unecessary div, so instead we just return the children
      def to_s
        children.to_s
      end

      private

      def build_drop_down
        dropdown_menu I18n.t("active_admin.batch_actions.button_label"), 
                      :id => "batch_actions_selector",
                      :button => { :class => "disabled" } do
          batch_actions_to_display.each do |batch_action|
            confirmation_text = render_or_call_method_or_proc_on(self, batch_action.confirm)

            options = {
              :class => "batch_action",
              "data-action" => batch_action.sym,
              "data-confirm" => confirmation_text
            }

            default_title = render_or_call_method_or_proc_on(self, batch_action.title)
            title = I18n.t("active_admin.batch_actions.labels.#{batch_action.sym}", :default => default_title)
            label = I18n.t("active_admin.batch_actions.action_label", :title => title)

            item label, "#", options
          end
        end
      end

      # Return the set of batch actions that should be displayed
      def batch_actions_to_display
        @batch_actions.select do |batch_action|
          call_method_or_proc_on(self, batch_action.display_if_block)
        end
      end

      # def build_batch_action_button
      #   a :class => 'table_tools_button dropdown_button disabled', :href => "#batch_actions_popover", :id => "batch_actions_button" do
      #     text_node I18n.t("active_admin.batch_actions.button_label")
      #   end
      # end

      # def build_batch_action_popover
      # end

    end

  end
end
require 'active_admin/component'

module ActiveAdmin
  module BatchActions

    # Creates the toggle checkbox used to toggle the collection selection on/off
    class ResourceSelectionToggleCell < ActiveAdmin::Component
      builder_method :resource_selection_toggle_cell

      def build
        input( :type => "checkbox", :id => "collection_selection_toggle_all", :name => "collection_selection_toggle_all", :class => "toggle_all" )
      end
    end

    # Creates the checkbox used to select a resource in the collection selection
    class ResourceSelectionCell < ActiveAdmin::Component
      builder_method :resource_selection_cell

      def build(resource)
        input :type => "checkbox", :id => "batch_action_item_#{resource.id}", :value => resource.id, :class => "collection_selection", :name => "collection_selection[]" 
      end
    end

    # Creates a wrapper panel for all index pages, except for the table, as the table has the checkbox in the thead
    class ResourceSelectionTogglePanel < ActiveAdmin::Component
      builder_method :resource_selection_toggle_panel

      def build
        super(:id => "collection_selection_toggle_panel")
        resource_selection_toggle_cell
        div(:id => "collection_selection_toggle_explaination" ) { I18n.t('active_admin.batch_actions.selection_toggle_explanation', :default => "(Toggle Selection)") }
      end

    end

  end
end
ActiveAdmin.before_load do |app|
  require "active_admin/batch_actions/resource_extension"
  require "active_admin/batch_actions/controller"

  # Add our Extensions
  ActiveAdmin::Resource.send :include, ActiveAdmin::BatchActions::ResourceExtension
  ActiveAdmin::ResourceController.send :include, ActiveAdmin::BatchActions::Controller

  # Require all the views
  require "active_admin/batch_actions/views/batch_action_form"
  require "active_admin/batch_actions/views/batch_action_popover"
  require "active_admin/batch_actions/views/selection_cells"
  require "active_admin/batch_actions/views/batch_action_selector"

  # Register the views with the view factory
  app.view_factory.register :batch_action_selector => ActiveAdmin::BatchActions::BatchActionSelector
end
module ActiveAdmin
  module Callbacks
    extend ActiveSupport::Concern

    protected

    # Simple callback system. Implements before and after callbacks for
    # use within the controllers.
    #
    # We didn't use the ActiveSupport callbacks becuase they do not support
    # passing in any arbitrary object into the callback method (which we
    # need to do)

    def call_callback_with(method, *args)
      case method
      when Symbol
        send(method, *args)
      when Proc
        instance_exec(*args, &method)
      else
        raise "Please register with callbacks using a symbol or a block/proc."
      end
    end

    module ClassMethods

      # Define a new callback.
      #
      # Example:
      #
      #   class MyClassWithCallbacks
      #     include ActiveAdmin::Callbacks
      #
      #     define_active_admin_callbacks :save
      #
      #     before_save do |arg1, arg2|
      #       # runs before save
      #     end
      #
      #     after_save :call_after_save
      #
      #     def save
      #       # Will run before, yield, then after
      #       run_save_callbacks :arg1, :arg2 do
      #         save!
      #       end
      #     end
      #
      #     protected
      #
      #     def call_after_save(arg1, arg2)
      #       # runs after save
      #     end
      #   end
      #     
      def define_active_admin_callbacks(*names)
        names.each do |name|
          [:before, :after].each do |type|

            # Define a method to set the callback
            class_eval(<<-EOS, __FILE__, __LINE__ + 1)
              # def self.before_create_callbacks
              def self.#{type}_#{name}_callbacks
                @#{type}_#{name}_callbacks ||= []
              end

              # def self.before_create
              def self.#{type}_#{name}(method = nil, &block)
                #{type}_#{name}_callbacks << (method || block)
              end
            EOS
          end

          # Define a method to run the callbacks
          class_eval(<<-EOS, __FILE__, __LINE__ + 1)
            def run_#{name}_callbacks(*args)
              self.class.before_#{name}_callbacks.each{|callback| call_callback_with(callback, *args)}
              value = yield if block_given?
              self.class.after_#{name}_callbacks.each{|callback| call_callback_with(callback, *args)}
              return value
            end
            EOS
         end
       end
    end
  end
end
require 'cancan'

# Add a setting to the application to configure the ability
ActiveAdmin::Application.inheritable_setting :cancan_ability_class, "Ability"

module ActiveAdmin

  class CanCanAdapter < AuthorizationAdapter

    def authorized?(action, subject = nil)
      cancan_ability.can?(action, subject)
    end

    def cancan_ability
      @cancan_ability ||= initialize_cancan_ability
    end

    def scope_collection(collection)
      collection.accessible_by(cancan_ability)
    end

    private

    # The setting allows the class to be stored as a string
    # to enable reloading in development.
    def initialize_cancan_ability
      ability_class_name = resource.namespace.cancan_ability_class

      if ability_class_name.is_a?(String)
        ability_class = ActiveSupport::Dependencies.constantize(ability_class_name)
      else
        ability_class = ability_class_name
      end

      ability_class.new(user)
    end

  end

end
require 'kaminari/models/active_record_extension'

module ActiveAdmin

  # manually initialize kaminari for this model
  ::ActiveRecord::Base.send :include, Kaminari::ActiveRecordExtension

  class Comment < ActiveRecord::Base
    belongs_to :resource, :polymorphic => true
    belongs_to :author, :polymorphic => true

    attr_accessible :resource, :resource_id, :resource_type, :body, :namespace

    validates_presence_of :resource
    validates_presence_of :body
    validates_presence_of :namespace

    # @returns [String] The name of the record to use for the polymorphic relationship
    def self.resource_type(record)
      record.class.base_class.name.to_s
    end

    def self.resource_id_cast(record)
      # Postgres adapters won't compare strings to numbers (issue 34)
      if resource_id_type == :string
        record.id.to_s
      else
        record.id
      end
    end

    def self.find_for_resource_in_namespace(resource, namespace)
      where(:resource_type => resource_type(resource),
            :resource_id => resource_id_cast(resource),
            :namespace => namespace.to_s)
    end

    def self.resource_id_type
      columns.select { |i| i.name == "resource_id" }.first.type
    end

    def self.table_name
      @table_name ||= ActiveRecord::Migrator.proper_table_name("active_admin_comments")
    end

  end

end

module ActiveAdmin
  module Comments

    module NamespaceHelper

      # Returns true of the namespace allows comments
      def comments?
        allow_comments == true
      end

    end

  end
end
module ActiveAdmin
  module Comments

    module ResourceHelper
      extend ActiveSupport::Concern

      included do
        attr_accessor :comments
      end

      def comments?
        namespace.comments? && comments != false
      end
    end

  end
end
module ActiveAdmin
  module Comments

    # Adds #active_admin_comments to the show page for use
    # and sets it up on the default main content
    module ShowPageHelper

      # Add admin comments to the main content if they are
      # turned on for the current resource
      def default_main_content
        super
        active_admin_comments if active_admin_config.comments?
      end

      # Display the comments for the resource. Same as calling
      # #active_admin_comments_for with the current resource
      def active_admin_comments(*args, &block)
        active_admin_comments_for(resource, *args, &block)
      end
    end

  end
end
require 'active_admin/views'
require 'active_admin/views/components/panel'

module ActiveAdmin
  module Comments
    module Views

      class Comments < ActiveAdmin::Views::Panel
        builder_method :active_admin_comments_for

        def build(record)
          @record = record
          super(title_content, :for => record)
          build_comments
        end

        protected

        def title_content
          I18n.t('active_admin.comments.title_content', :count => record_comments.count)
        end

        def record_comments
          @record_comments ||= ActiveAdmin::Comment.find_for_resource_in_namespace(@record, active_admin_namespace.name)
        end

        def build_comments
          if record_comments.count > 0
            record_comments.each do |comment|
              build_comment(comment)
            end
          else
            build_empty_message
          end
          build_comment_form
        end

        def build_comment(comment)
          div :for => comment do
            div :class => "active_admin_comment_meta" do
              user_name = comment.author ? auto_link(comment.author) : "Anonymous"
              h4(user_name, :class => "active_admin_comment_author")
              span(pretty_format(comment.created_at))
            end
            div :class => "active_admin_comment_body" do
              simple_format(comment.body)
            end
            div :style => "clear:both;"
          end
        end

        def build_empty_message
          span :class => "empty" do
            I18n.t('active_admin.comments.no_comments_yet')
          end
        end

        def comment_form_url
          if active_admin_namespace.root?
            comments_path
          else
            send(:"#{active_admin_namespace.name}_comments_path")
          end
        end

        def build_comment_form
          self << active_admin_form_for(ActiveAdmin::Comment.new, :url => comment_form_url, :html => {:class => "inline_form"}) do |form|
            form.inputs do
              form.input :resource_type, :input_html => { :value => ActiveAdmin::Comment.resource_type(@record) }, :as => :hidden
              form.input :resource_id, :input_html => { :value => @record.id }, :as => :hidden
              form.input :body, :input_html => { :size => "80x8" }, :label => false
            end
            form.actions do
              form.action :submit, :label => I18n.t('active_admin.comments.add'), :button_html => { :value => I18n.t('active_admin.comments.add') }
            end
          end
        end

        def default_id_for_prefix
          'active_admin_comments_for'
        end
      end

    end
  end
end
require 'active_admin/views'
require 'active_admin/comments/views/active_admin_comments'
require 'active_admin/comments/views/active_admin_comment'
require 'active_admin/comments/comment'
require 'active_admin/comments/views'
require 'active_admin/comments/show_page_helper'
require 'active_admin/comments/namespace_helper'
require 'active_admin/comments/resource_helper'

# Add the comments configuration
ActiveAdmin::Application.inheritable_setting :allow_comments, true

# Add the comments module to ActiveAdmin::Namespace
ActiveAdmin::Namespace.send :include, ActiveAdmin::Comments::NamespaceHelper

# Add the comments module to ActiveAdmin::Resource
ActiveAdmin::Resource.send :include, ActiveAdmin::Comments::ResourceHelper

# Add the module to the show page
ActiveAdmin.application.view_factory.show_page.send :include, ActiveAdmin::Comments::ShowPageHelper

# Walk through all the loaded resources after they are loaded
ActiveAdmin.after_load do |app|
  app.namespaces.values.each do |namespace|
    if namespace.comments?
      namespace.register ActiveAdmin::Comment, :as => "Comment" do
        actions :index, :show, :create

        # Ensure filters are turned on
        config.filters = true

        # Don't display in the menu
        menu false

        # Don't allow comments on comments
        config.comments = false

        # Filter Comments by date
        filter :resource_type
        filter :body
        filter :created_at

        # Only view comments in this namespace
        scope :all, :default => true do |comments|
          comments.where(:namespace => active_admin_config.namespace.name.to_s)
        end

        # Always redirect to the resource on show
        before_filter :only => :show do
          flash[:notice] = flash[:notice].dup if flash[:notice]
          comment = ActiveAdmin::Comment.find(params[:id])
          resource_config = active_admin_config.namespace.resource_for(comment.resource.class)
          redirect_to send(resource_config.route_instance_path, comment.resource)
        end

        # Store the author and namespace
        before_save do |comment|
          comment.namespace = active_admin_config.namespace.name
          comment.author = current_active_admin_user
        end

        # Redirect to the resource show page when failing to add a comment
        # TODO: Provide helpers to make such kind of customization much simpler
        controller do
          def create
            create! do |success, failure|
              failure.html do 
                resource_config = active_admin_config.namespace.resource_for(@comment.resource.class)
                flash[:error] = I18n.t('active_admin.comments.errors.empty_text')
                redirect_to send(resource_config.route_instance_path, @comment.resource)
              end
            end
          end
        end

        # Display as a table
        index do
          column(I18n.t('active_admin.comments.resource')){|comment| auto_link(comment.resource) }
          column(I18n.t('active_admin.comments.author')){|comment| auto_link(comment.author) }
          column(I18n.t('active_admin.comments.body')){|comment| comment.body }
        end
      end
    end
  end
end

# @deprecated #allow_comments_on - Remove in 0.5.0
ActiveAdmin::Application.deprecated_setting :allow_comments_in, [], 'The "allow_comments_in = []" setting is deprecated and will be remove by Active Admin 0.5.0. Please use "allow_comments = true|false" instead.'
module ActiveAdmin
  class Component < Arbre::Component

  end
end
module ActiveAdmin
  class ControllerAction
    attr_reader :name
    def initialize(name, options = {})
      @name, @options = name, options
    end

    def http_verb
      @options[:method] ||= :get
    end
  end
end
module ActiveAdmin
  # CSVBuilder stores CSV configuration
  #
  # Usage example:
  #
  #   csv_builder = CSVBuilder.new
  #   csv_builder.column :id
  #   csv_builder.column("Name") { |resource| resource.full_name }
  #
  #   csv_builder = CSVBuilder.new :separator => ";"
  #   csv_builder.column :id
  #
  #
  class CSVBuilder

    # Return a default CSVBuilder for a resource
    # The CSVBuilder's columns would be Id followed by this
    # resource's content columns
    def self.default_for_resource(resource)
      new.tap do |csv_builder|
        csv_builder.column(:id)
        resource.content_columns.each do |content_column|
          csv_builder.column(content_column.name.to_sym)
        end
      end
    end

    attr_reader :columns, :column_separator, :options

    def initialize(options={}, &block)
      @columns          = []
      @column_separator = options.delete(:separator)
      @options          = options.delete(:options)
      instance_eval &block if block_given?
    end

    # Add a column
    def column(name, &block)
      @columns << Column.new(name, block)
    end

    class Column
      attr_reader :name, :data
      
      def initialize(name, block = nil)
        @name = name.is_a?(Symbol) ? name.to_s.titleize : name
        @data = block || name.to_sym
      end
    end
  end
end
module ActiveAdmin
  module Dashboards
    module DashboardController
      def index
        @dashboard_sections = find_sections
        render 'active_admin/dashboard/index'
      end

      private

      def set_current_tab
        @current_tab = I18n.t("active_admin.dashboard")
      end

      def find_sections
        sections = ActiveAdmin::Dashboards.sections_for_namespace(namespace)        
        sections.select do |section|
          if section.options.has_key?(:if)
            symbol_or_proc = section.options[:if]
            case symbol_or_proc
            when Symbol, String then self.send(symbol_or_proc)
            when Proc           then instance_exec(&symbol_or_proc)
            else symbol_or_proc
            end
          else
            true
          end
        end
      end
      
      def namespace
        class_name = self.class.name
        if class_name.include?('::')
          self.class.name.split('::').first.underscore.to_sym
        else
          :root
        end
      end

      # Return the current menu for the view. This is a helper method
      def current_menu
        active_admin_namespace.fetch_menu(:default)
      end

      def active_admin_namespace
        ActiveAdmin.application.namespace(namespace)
      end
    end
  end
end
module ActiveAdmin
  module Dashboards
    class Section

      DEFAULT_PRIORITY = 10

      attr_accessor :name, :block
      attr_reader :namespace, :options

      def initialize(namespace, name, options = {}, &block)
        @namespace = namespace
        @name = name
        @options = options
        @block = block
      end

      def priority
        @options[:priority] || DEFAULT_PRIORITY
      end

      def icon
        @options[:icon]
      end

      # Sort by priority then by name
      def <=>(other)
        result = priority <=> other.priority
        result = name.to_s <=> other.name.to_s if result == 0
        result
      end

    end
  end
end
require 'active_admin/dashboards/dashboard_controller'
require 'active_admin/dashboards/section'

module ActiveAdmin
  module Dashboards

    @@sections = {}
    mattr_accessor :sections

    class << self

      # Eval an entire block in the context of this module to build 
      # dashboards quicker. 
      #
      # Example:
      #
      #   ActiveAdmin::Dashboards.build do
      #     section "Recent Post" do
      #       # return a list of posts
      #     end
      #   end
      #
      def build(&block)
        warn "DEPRECATION WARNING: ActiveAdmin::Dashboard is deprecated and will be removed in the next version"
        @built = true
        module_eval(&block)
      end

      def built?
        !!@built
      end

      # Add a new dashboard section to a namespace. If no namespace is given
      # it will be added to the default namespace.
      #
      # Options include:
      #   :namespace => only display for specified namespace.
      #   :if        => specify a method or block to determine whether the section is rendered at run time.
      def add_section(name, options = {}, &block)
        namespace = options.delete(:namespace) || ActiveAdmin.application.default_namespace || :root
        self.sections[namespace] ||= [] 
        self.sections[namespace] << Section.new(namespace, name, options, &block)
        self.sections[namespace].sort!
      end
      alias_method :section, :add_section

      def sections_for_namespace(namespace)
        @@sections[namespace] || []
      end

      def clear_all_sections!
        @@sections = {}
      end

      # Called from MenuBuilder to register dashboard to menu.
      def add_to_menu(namespace, menu)
        return unless ActiveAdmin::Dashboards.built?

        dashboard_path = namespace.root? ? :dashboard_path : "#{namespace.name}_dashboard_path".to_sym

        menu.add :id => "dashboard", 
                 :label => proc{ I18n.t("active_admin.dashboard") },
                 :url => dashboard_path,
                 :priority => 1
      end
    end
  end
end
require 'rails/version'

module ActiveAdmin
  module DependencyChecker
    class << self
      def check!
        if rails_3_1?
          unless meta_search_1_1? && sass_rails_3_1?
            warn "ActiveAdmin requires meta_search >= 1.1.0.pre and sass-rails ~> 3.1.0.rc to work with rails >= 3.1.0"
          end
        end

        if pry_rails_before_0_1_6?
          warn "ActiveAdmin is not compatible with pry-rails < 0.1.6. Please upgrade pry-rails."
        end
      end

      def rails_3_1?
        Rails::VERSION::MAJOR == 3 && Rails::VERSION::MINOR >= 1
      end

      def meta_search_1_1?
        Gem.loaded_specs['meta_search'].version.to_s >= "1.1"
      end

      def sass_rails_3_1?
        require 'sass/rails/version'
        ::Sass::Rails::VERSION >= "3.1"
      rescue LoadError
        false
      end

      def pry_rails_before_0_1_6?
        begin
          PryRails::VERSION < "0.1.6"
        rescue NameError
          false
        end
      end
    end
  end
end
module ActiveAdmin
  module Deprecation
    extend self

    def warn(message, callstack = caller)
      ActiveSupport::Deprecation.warn "Active Admin: #{message}", callstack
    end

    # Deprecate a method.
    #
    # @param [Module] klass the Class or Module to deprecate the method on
    # @param [Symbol] method the method to deprecate
    # @param [String] message the message to display to the end user
    #
    # Example:
    #
    #     class MyClass
    #       def my_method
    #         # ...
    #       end
    #       ActiveAdmin::Deprecation.deprecate self, :my_method,
    #         "MyClass#my_method is being removed in the next release"
    #     end
    #
    def deprecate(klass, method, message)
      klass.class_eval <<-EOC, __FILE__, __LINE__
        alias_method :"deprecated_#{method}", :#{method}
        def #{method}(*args)
          ActiveAdmin::Deprecation.warn('#{message}', caller)
          send(:deprecated_#{method}, *args)
        end
      EOC
    end

  end
end
require 'devise'

module ActiveAdmin
  module Devise

    def self.config
      config = {
        :path => ActiveAdmin.application.default_namespace,
        :controllers => ActiveAdmin::Devise.controllers,
        :path_names => { :sign_in => 'login', :sign_out => "logout" }
      }

      if ::Devise.respond_to?(:sign_out_via)
        logout_methods = [::Devise.sign_out_via, ActiveAdmin.application.logout_link_method].flatten.uniq
        config.merge!( :sign_out_via => logout_methods)
      end

      config
    end

    def self.controllers
      {
        :sessions => "active_admin/devise/sessions",
        :passwords => "active_admin/devise/passwords",
        :unlocks => "active_admin/devise/unlocks"
      }
    end

    module Controller
      extend ::ActiveSupport::Concern
      included do
        layout 'active_admin_logged_out'
        helper ::ActiveAdmin::ViewHelpers
      end

      # Redirect to the default namespace on logout
      def root_path
        namespace = ActiveAdmin.application.default_namespace.presence
        root_path_method = [namespace, :root_path].compact.join('_')

        url_helpers = Rails.application.routes.url_helpers

        path = if url_helpers.respond_to? root_path_method
                 url_helpers.send root_path_method
               else
                 # Guess a root_path when url_helpers not helpful
                 "/#{namespace}"
               end

        # NOTE: `relative_url_root` is deprecated by rails.
        #       Remove prefix here if it is removed completely.
        prefix = Rails.configuration.action_controller[:relative_url_root] || ''
        prefix + path
      end
    end

    class SessionsController < ::Devise::SessionsController
      include ::ActiveAdmin::Devise::Controller
    end

    class PasswordsController < ::Devise::PasswordsController
      include ::ActiveAdmin::Devise::Controller
    end

    class UnlocksController < ::Devise::UnlocksController
      include ::ActiveAdmin::Devise::Controller
    end

  end
end
module ActiveAdmin

  #
  # The Active Admin DSL. This class is where all the registration blocks
  # are instance eval'd. This is the central place for the API given to 
  # users of Active Admin
  #
  class DSL

    def initialize(config)
      @config = config
    end

    # Runs the registration block inside this object
    def run_registration_block(&block)
      instance_eval &block if block_given?
    end

    # The instance of ActiveAdmin::Config that's being registered
    # currently. You can use this within your registration blocks to
    # modify options:
    #
    # eg:
    # 
    #   ActiveAdmin.register Post do
    #     config.sort_order = "id_desc"
    #   end
    #
    def config
      @config
    end

    # Include a module with this resource. The modules's `included` method
    # is called with the instance of the `ActiveAdmin::DSL` passed into it.
    #
    # eg:
    #
    #   module HelpSidebar
    #
    #     def self.included(dsl)
    #       dsl.sidebar "Help" do
    #         "Call us for Help"
    #       end
    #     end
    #
    #   end
    #
    #   ActiveAdmin.register Post do
    #     include HelpSidebar
    #   end
    #
    # @param [Module] mod A module to include
    #
    # @returns [Nil]
    def include(mod)
      mod.included(self)
    end

    # Returns the controller for this resource. If you pass a
    # block, it will be eval'd in the controller
    #
    # Example:
    #
    #   ActiveAdmin.register Post do
    #
    #     controller do
    #       def some_method_on_controller
    #         # Method gets added to Admin::PostsController
    #       end
    #     end
    #
    #   end
    #
    def controller(&block)
      @config.controller.class_eval(&block) if block_given?
      @config.controller
    end

    # Add a new action item to the resource
    #
    # @param [Hash] options valid keys include:
    #                 :only:  A single or array of controller actions to display
    #                         this action item on.
    #                 :except: A single or array of controller actions not to
    #                          display this action item on.
    def action_item(options = {}, &block)
      config.add_action_item(options, &block)
    end

    # Add a new batch action item to the resource
    # Provide a symbol/string to register the action, options, & block to execute on request
    # 
    # To unregister an existing action, just provide the symbol & pass false as the second param
    #
    # @param [Symbol or String] title
    # @param [Hash] options valid keys include:
    # => :if is a proc that will be called to determine if the BatchAction should be displayed
    # => :sort_order is used to sort the batch actions ascending
    # => :confirm is a string which the user will have to accept in order to process the action
    #
    def batch_action(title, options = {}, &block)
      # Create symbol & title information
      if title.is_a?( String )
        sym = title.titleize.gsub(' ', '').underscore.to_sym
      else
        sym = title
        title = sym.to_s.titleize
      end
      
      # Either add/remove the batch action
      unless options == false
        config.add_batch_action( sym, title, options, &block )
      else
        config.remove_batch_action sym
      end
    end

    # Set the options that are available for the item that will be placed in the global
    # navigation of the menu.
    def menu(options = {})
      config.menu_item_options = options
    end

    # Set the name of the navigation menu to display. This is mainly used in conjuction with the
    # `#belongs_to` functionality.
    #
    # @param [Symbol] menu_name The name of the menu to display as the global navigation
    #                 when viewing this resource. Defaults to a menu named `:default`.
    #
    # Pass a block returning the name of a menu you want rendered for the request, being
    # executed in the context of the controller
    #
    def navigation_menu(menu_name=nil, &block)
      config.navigation_menu_name = menu_name || block
    end

    # Rewrite breadcrumb links.
    # Block will be executed inside controller.
    # Block must return an array if you want to rewrite breadcrumb links.
    #
    # Example:
    #   ActiveAdmin.register Post do
    #
    #     breadcrumb do
    #       [
    #         link_to('my piece', '/my/link/to/piece')
    #       ]
    #     end
    #   end
    #
    def breadcrumb(&block)
      config.breadcrumb = block
    end

    def sidebar(name, options = {}, &block)
      config.sidebar_sections << ActiveAdmin::SidebarSection.new(name, options, &block)
    end

    def decorate_with(decorator_class)
      # Force storage as a string. This will help us with reloading issues.
      # Assuming decorator_class.to_s will return the name of the class allows
      # us to handle a string or a class.
      config.decorator_class_name = "::#{ decorator_class }"
    end
  end
end
module ActiveAdmin
  class Engine < Rails::Engine
    if Rails.version > "3.1"
      initializer "ActiveAdmin precompile hook", :group => :all do |app|
        app.config.assets.precompile += %w(active_admin.js active_admin.css active_admin/print.css)
      end
    end
  end
end
module ActiveAdmin

  class EventDispatcher
    def initialize
      @events = {}
    end

    def clear_all_subscribers!
      @events = {}
    end

    def subscribe(*event_names, &block)
      event_names.each do |event|
        @events[event] ||= []
        @events[event] << block
      end
    end

    def subscribers(event)
      @events[event] || []
    end

    def dispatch(event, *args)
      subscribers(event).each do |subscriber|
        subscriber.call(*args)
      end
    end
  end

  # ActiveAdmin::Event is set to a dispatcher
  Event = EventDispatcher.new

end
module ActiveAdmin
  module Filters
    module DSL

      # For docs, please see ActiveAdmin::Filters::ResourceExtension#add_filter
      def filter(attribute, options = {})
        config.add_filter(attribute, options)
      end

      # For docs, please see ActiveAdmin::Filters::ResourceExtension#remove_filter
      def remove_filter(attribute)
        config.remove_filter(attribute)
      end

      # For docs, please see ActiveAdmin::Filters::ResourceExtension#preserve_default_filters!
      def preserve_default_filters!
        config.preserve_default_filters!
      end
    end
  end
end
module ActiveAdmin
  module Filters

    # This form builder defines methods to build filter forms such
    # as the one found in the sidebar of the index page of a standard resource.
    class FormBuilder < ::ActiveAdmin::FormBuilder

      def filter(method, options = {})
        return "" if method.blank? ||
                     (options[:as] ||= default_input_type(method)).nil?
        content = input(method, options)
        form_buffers.last << content.html_safe if content
      end

      protected

      # Returns the default filter type for a given attribute
      def default_input_type(method, options = {})
        if (column = column_for(method))
          case column.type
          when :date, :datetime
            return :date_range
          when :string, :text
            return :string
          when :integer
            return :select if reflection_for(method.to_s.gsub('_id','').to_sym)
            return :numeric
          when :float, :decimal
            return :numeric
          when :boolean
            return :boolean
          end
        end

        if (reflection = reflection_for(method))
          return :select if reflection.macro == :belongs_to && !reflection.options[:polymorphic]
        end
      end

      def custom_input_class_name(as)
        "Filter#{as.to_s.camelize}Input"
      end

      def active_admin_input_class_name(as)
        "ActiveAdmin::Inputs::Filter#{as.to_s.camelize}Input"
      end

      # Returns the column for an attribute on the object being searched
      # if it exists. Otherwise returns nil
      def column_for(method)
        @object.base.columns_hash[method.to_s] if @object.base.respond_to?(:columns_hash)
      end

      # Returns the association reflection for the method if it exists
      def reflection_for(method)
        @object.base.reflect_on_association(method) if @object.base.respond_to?(:reflect_on_association)
      end

    end


    # This module is included into the view
    module ViewHelper

      # Helper method to render a filter form
      def active_admin_filters_form_for(search, filters, options = {})
        options[:builder] ||= ActiveAdmin::Filters::FormBuilder
        options[:url] ||= collection_path
        options[:html] ||= {}
        options[:html][:method] = :get
        options[:html][:class] ||= "filter_form"
        options[:as] = :q
        clear_link = link_to(I18n.t('active_admin.clear_filters'), "#", :class => "clear_filters_btn")
        form_for search, options do |f|
          filters.group_by{ |o| o[:attribute] }.each do |attribute, array|
            options      = array.last # grab last-defined `filter` call from DSL
            if_block     = options[:if]     || proc{ true }
            unless_block = options[:unless] || proc{ false }
            if call_method_or_proc_on(self, if_block) && !call_method_or_proc_on(self, unless_block)
              f.filter options[:attribute], options.except(:attribute, :if, :unless)
            end
          end

          buttons = content_tag :div, :class => "buttons" do
            f.submit(I18n.t('active_admin.filter')) +
              clear_link +
              hidden_field_tags_for(params, :except => [:q, :page])
          end

          f.form_buffers.last + buttons
        end
      end

    end

  end
end
module ActiveAdmin
  module Filters

    module ResourceExtension

      def initialize(*)
        super
        add_filters_sidebar_section
      end

      # Returns the filters for this resource. If filters are not enabled,
      # it will always return an empty array.
      #
      # @return [Array] Filters that apply for this resource
      def filters
        return [] unless filters_enabled?
        filter_lookup
      end

      # Setter to enable / disable filters on this resource.
      #
      # Set to `nil` to inherit the setting from the namespace
      def filters=(bool)
        @filters_enabled = bool
      end

      # @return [Boolean] If filters are enabled for this resource
      def filters_enabled?
        @filters_enabled.nil? ? namespace.filters : @filters_enabled
      end

      def preserve_default_filters!
        @preserve_default_filters = true
      end

      def preserve_default_filters?
        @preserve_default_filters == true
      end

      # Remove a filter for this resource. If filters are not enabled, this method
      # will raise a RuntimeError
      #
      # @param [Symbol] attribute The attribute to not filter on
      def remove_filter(attribute)
        unless filters_enabled?
          raise RuntimeError, "Can't remove a filter when filters are disabled. Enable filters with 'config.filters = true'"
        end

        @filters_to_remove ||= []
        @filters_to_remove << attribute
      end

      # Add a filter for this resource. If filters are not enabled, this method
      # will raise a RuntimeError
      #
      # @param [Symbol] attribute The attribute to filter on
      # @param [Hash] options The set of options that are passed through to
      #                       metasearch for the field definition.
      def add_filter(attribute, options = {})
        unless filters_enabled?
          raise RuntimeError, "Can't add a filter when filters are disabled. Enable filters with 'config.filters = true'"
        end

        @filters ||= []
        @filters << options.merge({ :attribute => attribute })
      end

      # Reset the filters to use defaults
      def reset_filters!
        @filters = nil
        @filters_to_remove = nil
      end

      private

      # Collapses the waveform, if you will, of which filters should be displayed.
      # Removes filters and adds in default filters as desired.
      def filter_lookup
        filters = @filters.try(:dup) || []
        filters.push *default_filters if filters.empty? || preserve_default_filters?

        if @filters_to_remove
          @filters_to_remove.each do |attr|
            filters.delete_if{ |f| f.fetch(:attribute) == attr }
          end
        end

        filters
      end

      # @return [Array] The array of default filters for this resource
      def default_filters
        default_association_filters + default_content_filters
      end

      # Returns a default set of filters for the associations
      def default_association_filters
        if resource_class.respond_to?(:reflections)
          resource_class.reflections.collect{|name, r| { :attribute => name }}
        else
          []
        end
      end

      # Returns a default set of filters for the content columns
      def default_content_filters
        if resource_class.respond_to?(:content_columns)
          resource_class.content_columns.collect{|c| { :attribute => c.name.to_sym } }
        else
          []
        end
      end

      def add_filters_sidebar_section
        self.sidebar_sections << filters_sidebar_section
      end

      def filters_sidebar_section
        ActiveAdmin::SidebarSection.new(:filters, :only => :index, :if => proc{ active_admin_config.filters.any? } ) do
          active_admin_filters_form_for assigns[:search], active_admin_config.filters
        end
      end

    end

  end
end
require 'active_admin/filters/dsl'
require "active_admin/filters/resource_extension"
require 'active_admin/filters/forms'

# Add our Extensions
ActiveAdmin::ResourceDSL.send :include, ActiveAdmin::Filters::DSL
ActiveAdmin::Resource.send    :include, ActiveAdmin::Filters::ResourceExtension
ActiveAdmin::ViewHelpers.send :include, ActiveAdmin::Filters::ViewHelper
module ActiveAdmin
  class FormBuilder < ::Formtastic::FormBuilder

    attr_reader :form_buffers

    def initialize(*args)
      @form_buffers = ["".html_safe]
      super
    end

    def inputs(*args, &block)
      @inputs_with_block = block_given?
      form_buffers.last << with_new_form_buffer{ super }
    end

    # If this `input` call is inside a `inputs` block, add the content
    # to the form buffer. Else, return it directly.
    def input(method, *args)
      content = with_new_form_buffer{ super }
      @inputs_with_block ? form_buffers.last << content : content
    end

    def cancel_link(url = {:action => "index"}, html_options = {}, li_attrs = {})
      li_attrs[:class] ||= "cancel"
      li_content = template.link_to I18n.t('active_admin.cancel'), url, html_options
      form_buffers.last << template.content_tag(:li, li_content, li_attrs)
    end

    def actions(*args, &block)
      form_buffers.last << with_new_form_buffer do
        block_given? ? super : super{ commit_action_with_cancel_link }
      end
    end

    def action(*args)
      form_buffers.last << with_new_form_buffer{ super }
    end

    def commit_action_with_cancel_link
      action(:submit)
      cancel_link
    end

    def has_many(association, options = {}, &block)
      options = { :for => association }.merge(options)
      options[:class] ||= ""
      options[:class] << "inputs has_many_fields"

      # Add Delete Links
      form_block = proc do |has_many_form|
        # @see https://github.com/justinfrench/formtastic/blob/2.2.1/lib/formtastic/helpers/inputs_helper.rb#L373
        contents = if block.arity == 1  # for backwards compatibility with REE & Ruby 1.8.x
          block.call(has_many_form)
        else
          index = parent_child_index(options[:parent]) if options[:parent]
          block.call(has_many_form, index)
        end

        if has_many_form.object.new_record?
          contents += template.content_tag(:li) do
            template.link_to I18n.t('active_admin.has_many_delete'), "#", :onclick => "$(this).closest('.has_many_fields').remove(); return false;", :class => "button"
          end
        end

        contents
      end

      form_buffers.last << with_new_form_buffer do
        template.content_tag :div, :class => "has_many #{association}" do
          form_buffers.last << template.content_tag(:h3, object.class.reflect_on_association(association).klass.model_name.human(:count => 1.1))
          inputs options, &form_block

          form_buffers.last << js_for_has_many(association, form_block, template)
        end
      end
    end

    def semantic_errors(*args)
      form_buffers.last << with_new_form_buffer{ super }
    end

    # These methods are deprecated and removed from Formtastic, however are
    # supported here to help with transition.
    module DeprecatedMethods

      # Formtastic has depreciated #commit_button in favor of #action(:submit)
      def commit_button(*args)
        ::ActiveSupport::Deprecation.warn("f.commit_button is deprecated in favour of f.action(:submit)")

        options = args.extract_options!
        if String === args.first
          options[:label] = args.first unless options.has_key?(:label)
        end

        action(:submit, options)
      end

      def commit_button_with_cancel_link
        # Formtastic has depreciated #buttons in favor of #actions
        ::ActiveSupport::Deprecation.warn("f.commit_button_with_cancel_link is deprecated in favour of f.commit_action_with_cancel_link")

        commit_action_with_cancel_link
      end

      # The buttons method always needs to be wrapped in a new buffer
      def buttons(*args, &block)
        # Formtastic has depreciated #buttons in favor of #actions
        ::ActiveSupport::Deprecation.warn("f.buttons is deprecated in favour of f.actions")

        actions args, &block
      end

    end
    include DeprecatedMethods

    protected

    def active_admin_input_class_name(as)
      "ActiveAdmin::Inputs::#{as.to_s.camelize}Input"
    end

    # prevent exceptions in production environment for better performance
    def input_class_with_const_defined(as)
      input_class_name = custom_input_class_name(as)

      if ::Object.const_defined?(input_class_name)
        input_class_name.constantize
      elsif ActiveAdmin::Inputs.const_defined?(input_class_name)
        active_admin_input_class_name(as).constantize
      elsif Formtastic::Inputs.const_defined?(input_class_name)
        standard_input_class_name(as).constantize
      else
        raise Formtastic::UnknownInputError
      end
    end

    # use auto-loading in development environment
    def input_class_by_trying(as)
      begin
        begin
          custom_input_class_name(as).constantize
        rescue NameError
          begin
            active_admin_input_class_name(as).constantize
          rescue NameError
            standard_input_class_name(as).constantize
          end
        end
      end
    rescue NameError
      raise Formtastic::UnknownInputError
    end

    # This method calls the block it's passed (in our case, the `f.inputs` block)
    # and wraps the resulting HTML in a fieldset. If your block happens to return
    # nil (but it otherwise built the form correctly), the below override passes
    # the most recent part of the Active Admin form buffer.
    def field_set_and_list_wrapping(*args, &block)
      block_given? ? super{ yield || form_buffers.last } : super
    end

    private

    def with_new_form_buffer
      form_buffers << ''.html_safe
      return_value = (yield || '').html_safe
      form_buffers.pop
      return_value
    end

    # Capture the ADD JS
    def js_for_has_many(association, form_block, template)
      assoc_reflection = object.class.reflect_on_association(association)
      assoc_name       = assoc_reflection.klass.model_name
      placeholder      = "NEW_#{assoc_name.upcase.split(' ').join('_')}_RECORD"
      opts = {
        :for         => [association, assoc_reflection.klass.new],
        :class       => "inputs has_many_fields",
        :for_options => { :child_index => placeholder }
      }
      js = with_new_form_buffer{ inputs_for_nested_attributes opts, &form_block }
      js = template.escape_javascript js

      onclick = "$(this).before('#{js}'.replace(/#{placeholder}/g, new Date().getTime())); return false;"
      text    = I18n.t 'active_admin.has_many_new', :model => assoc_name.human

      template.link_to(text, "#", :onclick => onclick, :class => "button").html_safe
    end

  end
end
module ActiveAdmin
  module Helpers
    module Collection
      # Works around this issue: https://github.com/rails/rails/issues/7121
      #
      # GROUP BY + COUNT drops SELECT statement. This leads to SQL error when
      # the ORDER statement mentions a column defined in the SELECT statement.
      #
      # We remove the ORDER statement to work around this issue.
      def collection_size(collection=collection)
        size = collection.reorder("").count
        # when GROUP BY is used, AR returns Hash instead of Fixnum for .size
        size = size.size if size.kind_of?(Hash)

        size
      end

      def collection_is_empty?(collection=collection)
        collection_size(collection) == 0
      end
    end
  end
end
module ActiveAdmin

  # Shareable module to give a #display_on?(action) method
  # which returns true or false depending on an options hash.
  #
  # The options hash accepts:
  #
  # :only => :index
  # :only => [:index, :show]
  # :except => :index
  # :except => [:index, :show]
  #
  # call #normalize_display_options! after @options has been set
  # to ensure that the display options are setup correctly

  module OptionalDisplay
    def display_on?(action, render_context = nil)
      return false if @options[:only] && !@options[:only].include?(action.to_sym)
      return false if @options[:except] && @options[:except].include?(action.to_sym)
      if @options[:if]
        symbol_or_proc = @options[:if]
        return case symbol_or_proc
        when Symbol, String
          render_context ? render_context.send(symbol_or_proc) : self.send(symbol_or_proc)
        when Proc
          render_context ? render_context.instance_exec(&symbol_or_proc) : instance_exec(&symbol_or_proc)
        else symbol_or_proc
        end
      end
      true
    end

    private

    def normalize_display_options!
      @options[:only] = Array(@options[:only]) if @options[:only]
      @options[:except] = Array(@options[:except]) if @options[:except]
    end
  end
end
module ActiveAdmin
  module ScopeChain
    # Scope an ActiveRecord::Relation chain
    #
    # Example:
    #   scope_chain(Scope.new(:published), Article)
    #   # => Article.published
    #
    # @param scope The <ActiveAdmin::Scope> we want to scope on
    # @param chain The ActiveRecord::Relation chain or ActiveRecord::Base class to scope
    # @return <ActiveRecord::Relation or ActiveRecord::Base> The scoped relation chain
    #
    def scope_chain(scope, chain)
      if scope.scope_method
        chain.send(scope.scope_method)
      elsif scope.scope_block
        instance_exec chain, &scope.scope_block
      else
        chain
      end
    end
  end
end
require 'active_support/concern'

module ActiveAdmin

  # Adds a class method to a class to create settings with default values.
  #
  # Example:
  #
  #   class Configuration
  #     include ActiveAdmin::Settings
  #
  #     setting :site_title, "Default Site Title"
  #   end
  #
  #   conf = Configuration.new
  #   conf.site_title #=> "Default Site Title"
  #   conf.site_title = "Override Default"
  #   conf.site_title #=> "Override Default"
  #
  module Settings
    extend ActiveSupport::Concern

    def read_default_setting(name)
      default_settings[name]
    end

    private

    def default_settings
      self.class.default_settings
    end

    module ClassMethods

      def setting(name, default)
        default_settings[name] = default
        attr_accessor(name)

        # Create an accessor that grabs from the defaults
        # if @name has not been set yet
        class_eval <<-EOC, __FILE__, __LINE__ + 1
          def #{name}
            if instance_variable_defined? :@#{name}
              @#{name}
            else
              read_default_setting(:#{name})
            end
          end
        EOC
      end

      def deprecated_setting(name, default, message = nil)
        message = message || "The #{name} setting is deprecated and will be removed."
        setting(name, default)

        ActiveAdmin::Deprecation.deprecate self, name, message
        ActiveAdmin::Deprecation.deprecate self, :"#{name}=", message
      end

      def default_settings
        @default_settings ||= {}
      end

    end
  end
end
module ActiveAdmin
  module Iconic
    ICONS = {
      :arrow_down => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M32,16.016l-5.672-5.664c0,0-3.18,3.18-6.312,6.312V0h-8.023v16.664l-6.32-6.32L0,16.016L16,32    L32,16.016z"/></svg>',
      :arrow_down_alt1 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M32,16c0-8.835-7.164-16-16-16S0,7.165,0,16c0,8.837,7.164,16,16,16S32,24.837,32,16z M8,16.031h6V8h4v8.031    h5.969L16,24L8,16.031z"/></svg>',
      :arrow_down_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="arrow_x5F_up_x5F_alt2_x5F_32x32">    <path fill="{fill}"d="M32,16c0-8.836-7.165-16-16-16C7.163,0,0,7.164,0,16s7.163,16,16,16C24.835,32,32,24.836,32,16z M12,22h2V6h4v16h2l-4,4        L12,22z"/></g></svg>',
      :arrow_left => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M15.984,32l5.672-5.672c0,0-3.18-3.18-6.312-6.312H32v-8.023H15.344l6.312-6.32L15.984,0L0,16    L15.984,32z"/></svg>',
      :arrow_left_alt1 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M16,32.001c8.834,0,16-7.164,16-16c0-8.836-7.165-16-16-16c-8.837,0-16,7.164-16,16    C0,24.837,7.164,32.001,16,32.001z M15.969,8v6H24v4h-8.031v5.969L8,16L15.969,8z"/></svg>',
      :arrow_left_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="arrow_x5F_left_x5F_alt2_x5F_32x32">    <path fill="{fill}"d="M16,32c8.837,0,16-7.164,16-16S24.837,0,16,0C7.165,0,0,7.164,0,16S7.165,32,16,32z M10,12v2h16v4H10v2l-4-4L10,12z"/></g></svg>',
      :arrow_right => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 31.999" style="enable-background:new 0 0 32 31.999;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16.016,0l-5.668,5.672c0,0,3.18,3.18,6.312,6.312H0v8.023h16.66l-6.316,6.319l5.672,5.672L32,16    L16.016,0z"/></svg>',
      :arrow_right_alt1 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M16.001,0.002c-8.834,0-16,7.164-16,16s7.165,16,16,16c8.837,0,16-7.163,16-16S24.838,0.002,16.001,0.002z     M16.032,24.003v-6H8.001v-4.001h8.031V8.033l7.969,7.969L16.032,24.003z"/></svg>',
      :arrow_right_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="arrow_x5F_right_x5F_alt2_x5F_32x32">    <path fill="{fill}"d="M16,0C7.165,0,0,7.164,0,16s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0z M22,20v-2H6v-4h16v-2l4,4L22,20z"/></g></svg>',
      :arrow_up => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32.005" style="enable-background:new 0 0 32 32.005;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M0,15.984l5.672,5.667c0,0,3.18-3.178,6.312-6.315v16.669h8.023V15.336l6.32,6.325L32,15.984L16,0    L0,15.984z"/></svg>',
      :arrow_up_alt1 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M0.001,16.002c0,8.834,7.164,16,16,16c8.836,0,15.999-7.165,15.999-16c0-8.837-7.163-16-15.999-16    C7.166,0.002,0.001,7.166,0.001,16.002z M24.002,15.971h-6v8.031h-4v-8.031H8.033l7.969-7.969L24.002,15.971z"/></svg>',
      :arrow_up_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="arrow_x5F_down_x5F_alt2_x5F_32x32">    <path fill="{fill}"d="M0,16c0,8.836,7.163,16,16,16c8.835,0,16-7.164,16-16S24.835,0,16,0C7.163,0,0,7.164,0,16z M20,10h-2v16h-4V10h-2l4-4        L20,10z"/></g></svg>',
      :article => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="32,4 0,4 0,0 32,0 32,4     "/>    <polygon style="{style}" points="20,12 0,12 0,8 20,8 20,12     "/>    <polygon style="{style}" points="32,24 0,24 0,20 32,20 32,24     "/>    <polygon style="{style}" points="24,32 0,32 0,28 24,28 24,32     "/>    <path fill="{fill}"style="{style}" d="M32,30c0,1.104-0.898,2-2,2c-1.109,0-2.004-0.896-2.004-2s0.895-2,2.004-2        C31.102,28,32,28.896,32,30z"/></g></svg>',
      :at => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="ampersand_x5F_32x32">    <path fill="{fill}" d="M29.844,24C31.214,21.646,32,18.922,32,16c0-8.836-7.164-16-16-16S0,7.164,0,16s7.164,16,16,16        c4.417,0,8.417-1.789,11.312-4.688l-2.833-2.833C22.308,26.656,19.308,28,16,28C9.383,28,4,22.617,4,16S9.383,4,16,4        s12,5.383,12,12c0,1.422-0.273,2.781-0.734,4.047L27.234,20H24V8.042h-8c-4.422,0-8,3.583-8,8c0,4.419,3.578,8,8,8        c1.836,0,3.508-0.644,4.859-1.683C21.586,23.328,22.695,24,24,24H29.844z M20,14.008v2.034c0,2.208-1.797,4-4,4s-4-1.792-4-4        c0-2.206,1.797-4,4-4h4V14.008z"/></g></svg>',
      :battery_charging => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 16" enable-background="new 0 0 32 16" xml:space="preserve"><path fill="{fill}"d="M28,4V2c0-1.099-0.897-2-2-2H2C0.899,0,0,0.901,0,2v4.043h6.391c0.821-2.324,3.02-4,5.629-4V4h3.984v2H12.02v4h4.067v2    H12.02v2.043c-2.609,0-4.808-1.676-5.629-4H0V14c0,1.1,0.899,2,2,2h24c1.103,0,2-0.9,2-2v-2h4V4H28z"/></svg>',
      :battery_empty => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 16" enable-background="new 0 0 32 16" xml:space="preserve"><path fill="{fill}"d="M32,4h-4V2c0-1.099-0.897-2-2-2H2C0.899,0,0,0.901,0,2v12c0,1.099,0.899,2,2,2h24c1.103,0,2-0.901,2-2v-2h4V4z M24,12H4V4    h20V12z"/></svg>',
      :battery_full => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 16" enable-background="new 0 0 32 16" xml:space="preserve"><path fill="{fill}"d="M32,4h-4V2c0-1.099-0.897-2-2-2H2C0.899,0,0,0.901,0,2v12c0,1.102,0.899,2,2,2h24c1.103,0,2-0.898,2-2v-2h4V4z"/></svg>',
      :battery_half => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 16" enable-background="new 0 0 32 16" xml:space="preserve"><path fill="{fill}"d="M32,4h-4V2c0-1.099-0.897-2-2-2H2C0.899,0,0,0.901,0,2v12c0,1.1,0.899,2,2,2h24c1.103,0,2-0.9,2-2v-2h4V4z M24,12h-8V4h8V12    z"/></svg>',
      :beaker => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 16 32" style="enable-background:new 0 0 16 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M14,0H2C0.895,0,0,0.896,0,2v22c0,4.417,3.582,8,8,8s8-3.583,8-8V2C16,0.896,15.105,0,14,0z M10,24    c-1.105,0-2-0.896-2-2s0.895-2,2-2s2,0.896,2,2S11.105,24,10,24z M12,16h-1.945c-0.016-1.104-0.914-2-2.023-2s-2.008,0.896-2.023,2    H4V4h8V16z"/></svg>',
      :beaker_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 16 32" style="enable-background:new 0 0 16 32;" xml:space="preserve"><g>    <circle style="{style}" cx="9" cy="9" r="0.969"/>    <path fill="{fill}"style="{style}" d="M14,0H2C0.895,0,0,0.896,0,2v22c0,4.417,3.582,8,8,8s8-3.583,8-8V2C16,0.896,15.105,0,14,0z         M5.031,20c-0.535,0-0.969-0.433-0.969-0.969s0.434-0.969,0.969-0.969S6,18.495,6,19.031S5.566,20,5.031,20z M10,24        c-1.105,0-2-0.896-2-2s0.895-2,2-2s2,0.896,2,2S11.105,24,10,24z M12,16h-1.945c-0.016-1.104-0.914-2-2.023-2s-2.008,0.896-2.023,2        H4V4h8V16z"/></g></svg>',
      :bolt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="bolt_x5F_32x32">    <polygon fill="{fill}" points="32,0 8,16 14,20 0,32 24,20 18,16     "/></g></svg>',
      :book => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 28 32" style="enable-background:new 0 0 28 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M4,0C1.792,0,0,1.792,0,4v24c0,2.209,1.792,4,4,4h24V0H4z M24,28H8V4h3.984v8.039l4-4l4.031,4.031V4    H24V28z"/></svg>',
      :book_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 31.969" style="enable-background:new 0 0 32 31.969;" xml:space="preserve"><g>    <rect x="11.99" y="7.992" style="{style}" width="7.99" height="4.028"/>    <path fill="{fill}"style="{style}" d="M27.975,8.039L32,4.011h-4.025V0H3.996C1.787,0,0,1.789,0,3.995v23.979        c0,2.206,1.787,3.995,3.996,3.995h23.979V12.036h3.994L27.975,8.039z M23.975,27.974H7.99V3.995h15.984V27.974z"/></g></svg>',
      :box => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="box_x5F_32x32">    <g>        <rect y="12" fill="{fill}" width="32" height="20"/>        <polygon fill="{fill}" points="18,8 32,8 28,0 18,0         "/>        <polygon fill="{fill}" points="14,0 4,0 0,8 14,8         "/>    </g></g></svg>',
      :calendar => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="23.918,4 23.918,0 19.918,0 19.918,4 11.918,4 11.918,0 7.918,0 7.918,4 0,4 0,8 7.918,8         11.918,8 19.918,8 23.918,8 32,8 32,4     "/>    <rect x="4" y="20" style="{style}" width="24" height="4"/>    <rect x="4" y="12" style="{style}" width="24" height="4"/>    <polygon style="{style}" points="24,32 4,32 4,28 28,28     "/></g></svg>',
      :calendar_alt_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M26,4v2.047c0,2.211-1.789,4-4,4s-4-1.789-4-4V4h-4v2.047c0,2.211-1.789,4-4,4s-4-1.789-4-4V4H0v28        h32V4H26z M10,28H6v-4h4V28z M10,20H6v-4h4V20z M18,28h-4v-4h4V28z M18,20.008h-4v-4h4V20.008z M22,28v-4h4L22,28z M26,20h-4v-4h4        V20z"/>    <path fill="{fill}"style="{style}" d="M8,6V2c0-1.104,0.895-2,2-2s2,0.896,2,2v4c0,1.104-0.895,2-2,2S8,7.104,8,6z"/>    <path fill="{fill}"style="{style}" d="M20,6V2c0-1.104,0.895-2,2-2s2,0.896,2,2v4c0,1.104-0.895,2-2,2S20,7.104,20,6z"/></g></svg>',
      :calendar_alt_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="32,32 0,32 0,4 4,4 4,28 28,28 28,4 32,4 32,32     "/>    <rect x="6" y="12" style="{style}" width="4" height="4"/>    <rect x="14" y="12.008" style="{style}" width="4" height="4"/>    <rect x="22" y="12" style="{style}" width="4" height="4"/>    <rect x="6" y="20" style="{style}" width="4" height="4"/>    <rect x="14" y="20" style="{style}" width="4" height="4"/>    <polygon style="{style}" points="22,24 22,20 26,20     "/>    <path fill="{fill}"style="{style}" d="M8,6V2c0-1.104,0.895-2,2-2s2,0.896,2,2v4c0,1.104-0.895,2-2,2S8,7.104,8,6z"/>    <path fill="{fill}"style="{style}" d="M20,6V2c0-1.104,0.895-2,2-2s2,0.896,2,2v4c0,1.104-0.895,2-2,2S20,7.104,20,6z"/></g></svg>',
      :cd => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0z M16.031,19.934            c-2.188,0-3.965-1.773-3.965-3.965c0-2.195,1.777-3.969,3.965-3.969C18.227,12,20,13.773,20,15.969            C20,18.16,18.227,19.934,16.031,19.934z"/>    </g></g></svg>',
      :chat => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="chat_x5F_32x32">    <path fill="{fill}" d="M24,12V8c0-5.523-4-8-8-8H8C4,0,0,2.125,0,8c0,5.75,4,8,8,8h0.926C8.359,17.099,8,18.406,8,20v4        c0,4.418,3.582,8,8,8c0-2.209,1.797-4,4-4h4c4,0,8-2.25,8-8C32,14.125,28,12,24,12z M8,12c-4,0-4-3.012-4-4c0-1.199,0-4,4-4h8        c1.5,0,4,0.52,4,4v4c0,1.307-0.625,2.471-1.609,3.2C16.931,13.258,14.609,12,12,12H8z M24,24h-4c-2.609,0-4.938,1.258-6.397,3.199        C12.629,26.469,12,25.305,12,24v-4c0-1.831,0.91-2.941,1.816-3.512C15.098,17.156,16,18.457,16,20c2.957,0,5.509-1.621,6.895-4.004        c-0.004,0.001-0.004,0.001-0.004,0.004H24c4,0,4,2.802,4,4C28,20.989,28,24,24,24z M23.719,13.994        c-0.027,0.092-0.059,0.182-0.085,0.271C23.66,14.176,23.696,14.086,23.719,13.994z"/></g></svg>',
      :chat_alt_fill => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="chat_x5F_alt_x5F_fill_x5F_32x32">    <g>        <g>            <path fill="{fill}" d="M24,12c0,4.418-3.578,8-8,8c0-2.207-1.793-4-4-4H8c-4,0-8-2.25-8-8c0-5.875,4-8,8-8h8c4,0,8,2.479,8,8V12                z"/>        </g>        <path fill="{fill}" d="M12,12"/>        <path fill="{fill}" d="M12,12"/>        <g>            <g>                <path fill="{fill}" d="M25.984,12.213C25.863,17.625,21.438,22,16,22h-2v-2c0-1.104-0.897-2-2-2H8.203                    C8.078,18.619,8,19.281,8,20v4c0,4.418,3.582,8,8,8c0-2.209,1.797-4,4-4h4c4,0,8-2.25,8-8C32,15.106,29.219,12.84,25.984,12.213                    z"/>            </g>        </g>    </g></g></svg>',
      :chat_alt_stroke => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="chat_x5F_alt_x5F_stroke_x5F_32x32">    <g>        <g>            <path fill="{fill}" d="M25.978,12.213c-0.024,1.386-0.337,2.695-0.884,3.889C27.978,16.582,28,18.93,28,20c0,0.989,0,4-3.996,4                H20c-2.605,0-4.938,1.258-6.397,3.2C12.634,26.471,12,25.307,12,24v-4c0-0.792,0.141-1.414,0.359-1.928                C12.243,18.051,12.125,18,12,18H8.203c-0.125,0.619-0.199,1.281-0.199,2v4c0,4.418,3.578,8,7.996,8c0-2.209,1.79-4,4-4h4.004                C28,28,32,25.75,32,20C32,15.106,29.219,12.84,25.978,12.213z"/>        </g>        <path fill="{fill}" d="M16,4c1.493,0,4,0.52,4,4v4c0,1.309-0.632,2.471-1.601,3.2C16.938,13.26,14.609,12,12,12H8.004            C4,12,4,8.989,4,8c0-1.195,0-4,4.004-4H16 M16,0H8.004C4,0,0,2.125,0,8c0,5.75,4,8,8.004,8H12c2.212,0,4,1.793,4,4            c4.422,0,8.004-3.582,8.004-8V8C24.004,2.479,20,0,16,0L16,0z"/>    </g></g></svg>',
      :check => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 25.754" style="enable-background:new 0 0 32 25.754;" xml:space="preserve"><g>    <polygon style="{style}" points="11.941,25.754 0,13.812 5.695,8.117 11.941,14.363 26.305,0 32,5.695 11.941,25.754     "/></g></svg>',
      :check_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0z M13.52,23.383L6.16,16.02    l2.828-2.828l4.532,4.535l9.617-9.618l2.828,2.828L13.52,23.383z"/></svg>',
      :clock => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M16,4c6.617,0,12,5.383,12,12s-5.383,12-12,12S4,22.617,4,16S9.383,4,16,4 M16,0        C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0L16,0z"/>    <path fill="{fill}"style="{style}" d="M21.422,18.578L18,15.152V8h-4.023v7.992c0,0.602,0.277,1.122,0.695,1.493l3.922,3.922        L21.422,18.578z"/></g></svg>',
      :cloud => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 20" enable-background="new 0 0 32 20" xml:space="preserve"><path fill="{fill}" d="M24,4c-0.379,0-0.738,0.062-1.103,0.11C21.507,1.648,18.929,0,16,0c-2.988,0-5.566,1.665-6.941,4.101    C8.71,4.054,8.355,4,8,4c-4.41,0-8,3.586-8,8c0,4.414,3.59,8,8,8h16c4.413,0,8-3.586,8-8C32,7.586,28.413,4,24,4z M24,16H8    c-2.207,0-4-1.797-4-4c0-2.195,1.944-3.883,4.007-3.945C8.012,9,8.179,9.922,8.507,10.797l3.743-1.399C12.085,8.953,12,8.484,12,8    c0-2.204,1.793-4,4-4c1.293,0,2.465,0.641,3.199,1.64C17.272,7.101,16,9.395,16,12h4c0-2.204,1.793-4,4-4c2.21,0,4,1.796,4,4    C28,14.203,26.21,16,24,16z"/></svg>',
      :cog => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M32,20v-8h-4.734c-0.141-0.391-0.289-0.771-0.469-1.146l3.344-3.339l-5.656-5.661l-3.344,3.344    C20.777,5.026,20.375,4.933,20,4.792V0h-8v4.792c-0.383,0.141-0.781,0.234-1.145,0.406l-3.34-3.344l-5.66,5.661l3.34,3.339    C5.02,11.229,4.871,11.609,4.734,12H0v8h4.734c0.137,0.391,0.285,0.771,0.461,1.146l-3.34,3.339l5.66,5.661l3.34-3.344    c0.363,0.172,0.762,0.266,1.145,0.406V32h8v-4.792c0.375-0.141,0.777-0.234,1.141-0.406l3.344,3.344l5.656-5.661l-3.344-3.339    c0.18-0.375,0.328-0.755,0.469-1.146H32z M16,20.083c-2.211,0-4-1.791-4-4c0-2.208,1.789-4,4-4c2.207,0,4,1.792,4,4    C20,18.292,18.207,20.083,16,20.083z"/></svg>',
      :cog_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="cog_x5F_alt_x5F_32x32">    <path fill="{fill}" d="M32,17.969v-4l-4.781-1.992c-0.133-0.375-0.273-0.737-0.445-1.094l1.93-4.805L25.875,3.25l-4.763,1.961        c-0.362-0.175-0.734-0.323-1.117-0.461L17.969,0h-4l-1.977,4.734c-0.398,0.141-0.781,0.289-1.161,0.469L6.078,3.294L3.25,6.122        l1.938,4.711C5,11.219,4.847,11.614,4.703,12.021L0,14.031v4l4.706,1.961c0.146,0.406,0.302,0.802,0.489,1.188l-1.903,4.742        L6.12,28.75l4.724-1.945c0.378,0.18,0.766,0.325,1.164,0.461L14.031,32h4l1.979-4.758c0.38-0.141,0.755-0.289,1.114-0.461        l4.797,1.922l2.828-2.828l-1.969-4.773c0.167-0.359,0.305-0.722,0.438-1.094L32,17.969z M15.969,22c-3.312,0-6-2.688-6-6        s2.688-6,6-6s6,2.688,6,6S19.281,22,15.969,22z"/></g></svg>',
      :comment_alt1_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M0,19.992C0,26.626,5.375,32,12.008,32v-4.015c0-2.203,1.789-4,4-4h3.996        C26.625,23.985,32,18.624,32,11.999S26.625,0,20.004,0h-9.996c-5.52,0-9.996,4.47-9.996,9.999v9.993H0z"/></g></svg>',
      :comment_alt1_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M20.004,8c2.203,0,4,1.789,4,3.995c0,2.203-1.797,3.997-4,3.997h-3.996c-3.07,0-5.875,1.164-8,3.062    v-9.06c0-1.104,0.898-1.995,2-1.995H20.004 M20.004,0h-9.996c-5.52,0-9.996,4.477-9.996,9.995v9.997H0C0,26.625,5.375,32,12.008,32    v-4.008c0-2.211,1.789-4,4-4h3.996C26.625,23.992,32,18.617,32,11.995C32,5.37,26.625,0,20.004,0L20.004,0z"/></svg>',
      :comment_alt2_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32.001 24.002" style="enable-background:new 0 0 32.001 24.002;"     xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M29.938,20.002c0,0,2.062-4.001,2.062-8.001C32.001,2,24.005,0,16.005,0            C-6.37,0,0.011,20.002,4.011,24.002c4-4,4-4,9.996-4H29.938z"/>    </g></g></svg>',
      :comment_alt2_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M16,4c11.074,0,12,4.129,12,8c0,1.344-0.359,2.805-0.75,4H14c-4.703,0-6.734,0.195-9,1.758        c-0.938-2.572-1.535-6.046-0.375-8.84C5.975,5.656,9.803,4,16,4 M16,0C-6.369,0,0.012,20,4.006,24c4-4,4-4,9.994-4h15.938        c0,0,2.062-4,2.062-8C32,2,24,0,16,0L16,0z"/></g></svg>',
      :comment_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" style="enable-background:new 0 0 32 28;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M0,20c0,4.417,3.586,8,8,8c0-2.211,1.792-4,4-4h8c6.629,0,12-5.375,12-12S26.629,0,20,0H10        C4.477,0,0,4.477,0,10V20z"/></g></svg>',
      :comment_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" style="enable-background:new 0 0 32 28;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M20,4c4.414,0,8,3.586,8,8s-3.586,8-8,8h-8c-2.609,0-4.933,1.258-6.394,3.203    C4.633,22.469,4,21.305,4,20V10c0-3.308,2.695-6,6-6H20 M20,0H10C4.477,0,0,4.477,0,10v10c0,4.417,3.586,8,8,8c0-2.211,1.793-4,4-4    h8c6.629,0,12-5.375,12-12S26.629,0,20,0L20,0z"/></svg>',
      :compass => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g>    <path fill="{fill}"d="M16,4c6.618,0,12,5.383,12,12s-5.382,12-12,12C9.384,28,4,22.617,4,16S9.384,4,16,4 M16,0C7.165,0,0,7.164,0,16        s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0L16,0z"/>    <g>        <path fill="{fill}"d="M18.125,13.879c0.797,0.798,1.009,1.93,0.719,2.944L24,8l-8.703,5.138C16.281,12.896,17.359,13.109,18.125,13.879z"/>        <path fill="{fill}"d="M13.884,18.121c-0.774-0.771-0.984-1.85-0.743-2.836L8,24l8.832-5.16C15.816,19.133,14.688,18.922,13.884,18.121z"/>    </g></g></svg>',
      :cursor => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="cursor_x5F_32x32">    <polygon fill="{fill}" points="32,28 18,14 24,8 0,0 8,23.995 14,17.995 28,32     "/></g></svg>',
      :denied => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0z M16,4    c2.59,0,4.973,0.844,6.934,2.242L6.238,22.93C4.84,20.969,4,18.586,4,16C4,9.383,9.383,4,16,4z M16,28    c-2.59,0-4.973-0.844-6.934-2.242L25.762,9.07C27.16,11.031,28,13.414,28,16C28,22.617,22.617,28,16,28z"/></svg>',
      :denied_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16c0,8.836,7.164,16,16,16s16-7.164,16-16C32,7.164,24.836,0,16,0z M16,8    c0.711,0,1.387,0.121,2.043,0.297l-9.742,9.75C8.121,17.391,8,16.71,8,16C8,11.586,11.59,8,16,8z M16,24    c-0.711,0-1.387-0.125-2.043-0.297l9.742-9.75C23.879,14.609,24,15.289,24,16C24,20.414,20.41,24,16,24z"/></svg>',
      :dial => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 31.828" enable-background="new 0 0 32 31.828" xml:space="preserve"><g id="{id}"></g><g id="dial_x5F_32x32">    <g>        <path fill="{fill}" d="M16,11.828c-2.21,0-4,1.79-4,4c0,2.208,1.79,4,4,4c2.212,0,4-1.793,4-4C20,13.617,18.212,11.828,16,11.828            z"/>        <path fill="{fill}" d="M28.556,6.047c-0.344,0.281-0.766,0.469-1.243,0.469c-1.101,0-2-0.895-2-2            c0-0.488,0.196-0.918,0.484-1.266c-2.219-1.711-4.906-2.864-7.835-3.227C17.859,1.031,17.04,1.828,16,1.828            c-1.038,0-1.871-0.808-1.96-1.828c-2.969,0.382-5.672,1.555-7.911,3.324C6.384,3.66,6.562,4.062,6.562,4.516c0,1.105-0.891,2-2,2            c-0.444,0-0.844-0.176-1.179-0.426C1.297,8.796,0,12.145,0,15.828c0,8.836,7.165,16,16,16c8.837,0,16-7.164,16-16            C32,12.113,30.688,8.746,28.556,6.047z M16,23.828c-4.418,0-8-3.582-8-8c0-2.211,0.895-4.208,2.344-5.657L16,4.515l5.649,5.645            C23.103,11.613,24,13.613,24,15.828C24,20.246,20.415,23.828,16,23.828z"/>    </g></g></svg>',
      :document_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M21.609,0H0v32l7.977-6.641L15.992,32L24,25.37L32,32V10.301L21.609,0z M18,14V4l10,10H18z"/></svg>',
      :document_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32.023" style="enable-background:new 0 0 32 32.023;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M22.016,0H0v31.961l8.053-6.582l8.016,6.645l8.016-6.637L32,32.008v-22L22.016,0z M28.021,23.955    l-3.953-3.229c0,0-0.041,0.034-0.104,0.086l-7.896,6.535L8.09,20.734l-4.084,3.221c0,0,0-17.373,0-20.016c2.1,0,7.807,0,12.006,0    v12.01h12.01C28.021,18.682,28.021,23.955,28.021,23.955z M20.016,11.945c0-1.543,0-5.918,0-8.006    c1.615,1.619,6.402,6.404,8.006,8.006C25.975,11.945,21.568,11.945,20.016,11.945z"/></svg>',
      :eject => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="0,20 16,0 32,20     "/>    <rect y="24" style="{style}" width="31.955" height="8"/></g></svg>',
      :equalizer => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M20,20h-2V2c0-1.105-0.891-2-2-2c-1.102,0-2,0.895-2,2v18h-2v4h2v6c0,1.105,0.898,2,2,2        c1.109,0,2-0.895,2-2v-6h2V20z"/>    <path fill="{fill}"style="{style}" d="M32,8h-2V2c0-1.105-0.891-2-2-2c-1.102,0-2,0.895-2,2v6h-2v4h2v18c0,1.105,0.898,2,2,2        c1.109,0,2-0.895,2-2V12h2V8z"/>    <path fill="{fill}"style="{style}" d="M8,12H6V2c0-1.105-0.891-2-2-2C2.898,0,2,0.895,2,2v10H0v4h2v14c0,1.105,0.898,2,2,2        c1.109,0,2-0.895,2-2V16h2V12z"/></g></svg>',
      :eyedropper => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="eyedropper_x5F_32x32">    <path fill="{fill}" d="M29.658,13.684c3.123-3.118,3.123-8.18,0-11.297c-1.555-1.559-3.602-2.34-5.643-2.34        c-2.045,0-4.092,0.781-5.649,2.34l-0.592,0.59L14.798,0l-2.82,2.823l2.977,2.974L0,20.761v7.247L3.931,32h7.414l14.907-14.906        l2.875,2.878l2.82-2.82l-2.875-2.878L29.658,13.684z M10.321,27.365c0.047-1.511-0.477-3.033-1.627-4.186        c-1.061-1.06-2.443-1.582-3.834-1.629L17.782,8.628l5.642,5.638L10.321,27.365z"/></g></svg>',
      :first => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="32,32 8,16 32,0     "/>    <rect y="4" style="{style}" width="8" height="24"/></g></svg>',
      :folder_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g>    <path fill="{fill}" d="M32,30c0,1.105-0.891,2-2,2H2c-1.105,0-2-0.895-2-2V12h32V30z"/>    <polygon fill="{fill}" points="12,4.003 12,0 0,0 0,8 32,8 32,4.003     "/></g></svg>',
      :folder_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M16,4V0H0v12.004v3.375V28c0,2.211,1.79,4,4,4h24c2.207,0,4-1.789,4-4V16.004v-4V4H16z M12,4L12,4v4h4h12v4    H4V4H12z M28,28H4V16h24v0.004V28z"/></svg>',
      :fork => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 28 32" enable-background="new 0 0 28 32" xml:space="preserve"><g>    <path fill="{fill}"d="M20,0v3.875c0,1.602-0.625,3.109-1.755,4.239L6.93,19.367C5.141,21.151,4.156,23.495,4.047,26H0l6,6l6-6H8.042        c0.106-1.438,0.685-2.773,1.708-3.805l11.32-11.25C22.961,9.055,24,6.547,24,3.875V0H20z"/>    <path fill="{fill}"d="M23.953,26c-0.109-2.505-1.099-4.849-2.891-6.641l-2.227-2.214L16,19.964l2.242,2.231c1.031,1.028,1.609,2.367,1.711,3.805        H16l6,6l6-6H23.953z"/></g></svg>',
      :fullscreen => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="fullscreen_x5F_32x32">    <g>        <polygon fill="{fill}" points="27.414,24.586 22.828,20 20,22.828 24.586,27.414 20,32 32,32 32,20         "/>        <polygon fill="{fill}" points="12,0 0,0 0,12 4.586,7.414 9.125,11.953 11.953,9.125 7.414,4.586         "/>        <polygon fill="{fill}" points="12,22.828 9.172,20 4.586,24.586 0,20 0,32 12,32 7.414,27.414         "/>        <polygon fill="{fill}" points="32,0 20,0 24.586,4.586 20.042,9.125 22.87,11.953 27.414,7.414 32,12         "/>    </g></g></svg>',
      :fullscreen_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="fullscreen_x5F_alt_x5F_32x32">    <g>        <polygon fill="{fill}" points="29.414,26.586 22.828,20 20,22.828 26.586,29.414 24,32 32,32 32,24         "/>        <polygon fill="{fill}" points="2.586,5.414 9.172,12 12,9.172 5.414,2.586 8,0 0,0 0,8         "/>        <polygon fill="{fill}" points="26.586,2.586 20,9.172 22.828,12 29.414,5.414 32,8 32,0 24,0         "/>        <polygon fill="{fill}" points="12,22.828 9.172,20 2.586,26.586 0,24 0,32 8,32 5.414,29.414         "/>    </g></g></svg>',
      :fullscreen_exit => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="fullscreen_x5F_exit_x5F_32x32">    <g>        <polygon fill="{fill}" points="24.586,27.414 29.172,32 32,29.172 27.414,24.586 32,20 20,20 20,32         "/>        <polygon fill="{fill}" points="0,12 12,12 12,0 7.414,4.586 2.875,0.043 0.047,2.871 4.586,7.414         "/>        <polygon fill="{fill}" points="0,29.172 2.828,32 7.414,27.414 12,32 12,20 0,20 4.586,24.586         "/>        <polygon fill="{fill}" points="20,12 32,12 27.414,7.414 31.961,2.871 29.133,0.043 24.586,4.586 20,0         "/>    </g></g></svg>',
      :fullscreen_exit_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="fullscreen_x5F_exit_x5F_alt_x5F_32x32">    <g>        <polygon fill="{fill}" points="22.586,25.414 29.172,32 32,29.172 25.414,22.586 28,20 20,20 20,28         "/>        <polygon fill="{fill}" points="6.547,9.371 4,12 11.961,11.957 12,4 9.375,6.543 2.828,0 0,2.828         "/>        <polygon fill="{fill}" points="0,29.172 2.828,32 9.414,25.414 12,28 12,20 4,20 6.586,22.586         "/>        <polygon fill="{fill}" points="28.031,12 25.438,9.404 32,2.838 29.164,0 22.594,6.566 20,3.971 20,12         "/>    </g></g></svg>',
      :headphones => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" style="enable-background:new 0 0 32 28;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M30,16h-2v-4c0-6.627-5.375-12-12-12S4,5.373,4,12v4H2c-1.105,0-2,0.895-2,2v8c0,1.105,0.895,2,2,2h6    V16v-4c0-4.411,3.586-8,8-8s8,3.589,8,8v4v12h6c1.104,0,2-0.895,2-2v-8C32,16.895,31.104,16,30,16z"/></svg>',
      :heart_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" style="enable-background:new 0 0 32 28;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M16,3.844C14.387,1.578,11.871,0,8.887,0C3.984,0,0,3.992,0,8.891v0.734L16.006,28L32,9.625V8.891            C32,3.992,28.016,0,23.115,0C20.131,0,17.615,1.578,16,3.844z"/>    </g></g></svg>',
      :heart_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" style="enable-background:new 0 0 32 28;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M23.115,4c2.453,0,4.49,1.82,4.834,4.188L16.006,21.906L4.053,8.188C4.396,5.82,6.428,4,8.887,4        c2.016,0,3.854,2.164,3.854,2.164L16,9.625l3.256-3.461C19.256,6.164,21.1,4,23.115,4 M23.115,0c-2.984,0-5.5,1.578-7.115,3.844        C14.387,1.578,11.871,0,8.887,0C3.984,0,0,3.992,0,8.891v0.734L16.006,28L32,9.625V8.891C32,3.992,28.016,0,23.115,0L23.115,0z"/></g></svg>',
      :home => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="home_x5F_32x32">    <path fill="{fill}" d="M16,0L0,16h4v16h24V16h4L16,0z M24,28h-6v-6h-4v6H8V13.656L16,8l8,5.656V28z"/></g></svg>',
      :image => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="8,24 8,16 12,12 16,16 24,8 32,16 32,24     "/>    <polygon style="{style}" points="4,28 4,0 0,4 0,28 0,32 4,32 28,32 32,28     "/></g></svg>',
      :info => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 16 32" enable-background="new 0 0 16 32" xml:space="preserve"><g id="{id}"></g><g id="Layer_21">    <g>        <path fill="{fill}" d="M2,16c1.104,0,2,0.895,2,2v8c0,1.105-0.896,2-2,2H0v4h16v-4h-1.992c-1.102,0-2-0.895-2-2L12,12H0v4H2z"/>        <circle fill="{fill}" cx="8" cy="4" r="4"/>    </g></g></svg>',
      :iphone => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 32" style="enable-background:new 0 0 24 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0H8C3.582,0,0,3.582,0,8v16c0,4.418,3.582,8,8,8h8c4.418,0,8-3.582,8-8V8C24,3.582,20.418,0,16,0    z M12,30.062c-1.138,0-2.062-0.924-2.062-2.062s0.924-2.062,2.062-2.062c1.139,0,2.062,0.924,2.062,2.062S13.139,30.062,12,30.062z     M20,24H4V8c0-2.206,1.794-4,4-4h8c2.205,0,4,1.794,4,4V24z"/></svg>',
      :key_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M22,0c-5.523,0-10,4.477-10,10c0,0.623,0.074,1.227,0.184,1.816L0,24v8h12v-4h4v-4h4v-4            l0.184-0.184C20.773,19.926,21.379,20,22,20c5.523,0,10-4.477,10-10S27.523,0,22,0z M22.008,12c-1.105,0-2-0.895-2-2s0.895-2,2-2            s2,0.895,2,2S23.113,12,22.008,12z"/>    </g></g></svg>',
      :key_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M22,4c3.309,0,6,2.691,6,6s-2.691,6-6,6c-0.312,0-0.658-0.039-1.088-0.117L18.844,15.5l-1.488,1.488        l-0.184,0.184L16,18.344V20h-4v4H8v4H4v-2.344l11.012-11.012l1.488-1.488l-0.383-2.07C16.038,10.657,16,10.312,16,10        C16,6.691,18.691,4,22,4 M22,0c-5.523,0-10,4.477-10,10c0,0.625,0.074,1.227,0.184,1.816L0,24v8h12v-4h4v-4h4v-4l0.184-0.184        C20.773,19.926,21.377,20,22,20c5.523,0,10-4.477,10-10S27.523,0,22,0L22,0z"/>    <circle style="{style}" cx="22.008" cy="10" r="2"/></g></svg>',
      :last => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="0,0 24,16 0,32     "/>    <rect x="24" y="4" style="{style}" width="8" height="24"/></g></svg>',
      :left_quote => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g id="{id}"></g><g id="left_x5F_quote_x5F_32x32">    <g>        <path fill="{fill}" d="M32,24V12h-8c0-4.411,3.587-8,8-8V0c-6.616,0-12,5.383-12,12v12H32z"/>        <path fill="{fill}" d="M12,24V12H4c0-4.411,3.587-8,8-8V0C5.384,0,0,5.383,0,12v12H12z"/>    </g></g></svg>',
      :left_quote_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g id="{id}"></g><g id="left_x5F_quote_x5F_alt_x5F_32x32">    <g>        <polygon fill="{fill}" points="32,24 32,0 20,12 20,24         "/>        <polygon fill="{fill}" points="12,24 12,0 0,12 0,24         "/>    </g></g></svg>',
      :lightbulb => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 20.051 32" style="enable-background:new 0 0 20.051 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M10.024,4.007c3.32,0,6.019,2.7,6.019,6.017c0,1.894-0.867,3.636-2.379,4.773        c-2.266,1.707-3.18,3.593-3.496,5.179H9.883c-0.313-1.586-1.23-3.473-3.493-5.179c-1.515-1.137-2.382-2.879-2.382-4.773        C4.008,6.707,6.707,4.007,10.024,4.007 M10.024,0C4.488,0,0,4.488,0,10.024c0,3.28,1.547,6.147,3.977,7.976        c1.121,0.844,2.042,1.93,2.042,3.43v2.555h8.012V21.43c0-1.5,0.922-2.586,2.043-3.43c2.43-1.829,3.977-4.696,3.977-7.976        C20.051,4.488,15.562,0,10.024,0L10.024,0z"/>    <rect x="6.02" y="27.992" style="{style}" width="8.012" height="4.008"/></g></svg>',
      :link => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="link_x5F_32x32">    <g>        <path fill="{fill}" d="M31.414,0.586c-0.781-0.781-2.047-0.781-2.828,0l-4.071,4.073C22.847,3.553,20.921,3,18.999,3            c-2.559,0-5.116,0.977-7.069,2.93l-6,6c-3.422,3.42-3.844,8.703-1.274,12.584l-4.069,4.072c-0.781,0.781-0.781,2.047,0,2.828            C0.977,31.805,1.487,32,1.999,32c0.516,0,1.024-0.195,1.415-0.586l4.069-4.072C9.155,28.447,11.077,29,12.999,29            c2.562,0,5.118-0.977,7.071-2.93l6-6c3.422-3.419,3.844-8.703,1.272-12.583l4.071-4.073C32.195,2.633,32.195,1.367,31.414,0.586z             M24.999,13c0,1.602-0.625,3.109-1.757,4.242l-6,6C16.108,24.375,14.602,25,12.999,25c-0.906,0-1.772-0.221-2.569-0.602            l2.984-2.984c0.781-0.781,0.781-2.047,0-2.828s-2.047-0.781-2.828,0L7.602,21.57C7.218,20.775,6.999,19.908,6.999,19            c0-1.602,0.625-3.109,1.759-4.242l6-6C15.89,7.625,17.398,7,18.999,7c0.906,0,1.774,0.221,2.571,0.602l-3.047,3.047            c-0.781,0.781-0.781,2.047,0,2.828c0.391,0.391,0.901,0.586,1.413,0.586c0.516,0,1.024-0.195,1.415-0.586l3.047-3.047            C24.78,11.225,24.999,12.092,24.999,13z"/>    </g></g></svg>',
      :lock_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24.006 32" style="enable-background:new 0 0 24.006 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M14.006,0c-5.508,0-10,4.485-10,10v2H0v14c0,3.309,2.693,6,6,6h12.006c3.307,0,6-2.691,6-6V10    C24.006,4.485,19.516,0,14.006,0z M12,24c-1.104,0-2-0.895-2-2s0.896-2,2-2c1.107,0,2,0.895,2,2S13.107,24,12,24z M20.006,12h-12v-2    c0-3.309,2.695-6,6-6c3.307,0,6,2.691,6,6V12z"/></svg>',
      :lock_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24.008 32" style="enable-background:new 0 0 24.008 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M14.008,0c-5.512,0-10,4.484-10,10v2H0v14c0,3.305,2.695,6,6,6h12.008c3.312,0,6-2.695,6-6V10        C24.008,4.484,19.523,0,14.008,0z M8.008,10c0-3.312,2.695-6,6-6c3.312,0,6,2.688,6,6v2h-12V10z M18.008,28H6c-1.102,0-2-0.898-2-2        V16h16.008v10C20.008,27.102,19.113,28,18.008,28z"/>    <path fill="{fill}"style="{style}" d="M14.008,22c0,1.102-0.898,2-2,2c-1.109,0-2-0.898-2-2c0-1.109,0.891-2,2-2        C13.109,20,14.008,20.891,14.008,22z"/></g></svg>',
      :loop => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 31.999 32" style="enable-background:new 0 0 31.999 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M9.804,3.677l-5.803,5.8V3.841H0v11.997h12.001v-4H7.298l5.335-5.333        c3.387-3.391,9.307-3.391,12.701,0l2.828-2.828C23.261-1.229,14.708-1.222,9.804,3.677z"/>    <path fill="{fill}"style="{style}" d="M19.999,16.033v4h4.703l-5.336,5.338c-3.389,3.395-9.307,3.395-12.701,0l-2.829,2.824        C6.287,30.648,9.55,32,13.021,32c3.469,0,6.725-1.352,9.174-3.805l5.805-5.803v5.639h4V16.033H19.999z"/></g></svg>',
      :loop_alt1 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g>    <path fill="{fill}"d="M26,12l-6,6h4c0,1.102-0.897,2-2,2H10c-1.101,0-2-0.898-2-2v-2H4v2c0,3.308,2.691,6,6,6h12c3.312,0,6-2.692,6-6h4L26,12z"        />    <path fill="{fill}"d="M22,0H10C6.691,0,4,2.692,4,6v0.062H0L6,12l6-5.938H8V6c0-1.102,0.899-2,2-2h12c1.103,0,2,0.898,2,2v2h4V6        C28,2.692,25.312,0,22,0z"/></g></svg>',
      :loop_alt2 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 28" enable-background="new 0 0 32 28" xml:space="preserve"><g>    <path fill="{fill}"d="M19.946,20l6.007-8L32,20h-4v2c0,3.308-2.688,6-6,6H10c-3.309,0-6-2.692-6-6v-2h4v2c0,1.102,0.899,2,2,2h12        c1.103,0,2-0.898,2-2v-2H19.946z"/>    <path fill="{fill}"d="M12.056,8l-6.009,8L0,8h4V6c0-3.308,2.691-6,6-6h12c3.312,0,6,2.692,6,6v2h-4V6c0-1.102-0.897-2-2-2H10        C8.899,4,8,4.898,8,6v2H12.056z"/></g></svg>',
      :loop_alt3 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g>    <path fill="{fill}"d="M28,12v2c0,1.102-0.897,2-2,2H12v-4l-8,6l8,6v-4h14c3.312,0,6-2.695,6-6v-2H28z"/>    <path fill="{fill}"d="M4,10c0-1.104,0.899-2,2-2h14v4l7.993-6L20,0v4H6c-3.309,0-6,2.688-6,6v2h4V10z"/></g></svg>',
      :loop_alt4 => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g>    <path fill="{fill}"d="M28,14c0,1.102-0.899,2-2,2H7.991v-4L0,18l7.991,6v-4H26c3.309,0,6-2.695,6-6H28z"/>    <path fill="{fill}"d="M6,8h18v4l8-6l-8-6v4H6c-3.306,0-6,2.688-6,6h4C4,8.896,4.897,8,6,8z"/></g></svg>',
      :magnifying_glass => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M20.135,0C13.594,0,8.273,5.32,8.273,11.864c0,1.565,0.32,3.05,0.867,4.422L0,25.43L6.572,32    l9.146-9.148c1.367,0.555,2.854,0.875,4.416,0.875c6.537,0,11.865-5.32,11.865-11.862C32,5.32,26.672,0,20.135,0z M6.572,26.352    c-0.432-0.438-0.494-0.492-0.922-0.922c1.271-1.269,3.828-3.836,5.686-5.688c0.289,0.328,0.596,0.633,0.914,0.922    C10.4,22.516,7.844,25.078,6.572,26.352z M20.135,19.729c-4.338,0-7.869-3.526-7.869-7.865c0-4.338,3.531-7.869,7.869-7.869    c4.334,0,7.865,3.531,7.865,7.869C28,16.203,24.469,19.729,20.135,19.729z"/></svg>',
      :magnifying_glass_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 31.992 32" style="enable-background:new 0 0 31.992 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M20.127,0C13.594,0,8.268,5.32,8.268,11.864c0,1.565,0.326,3.05,0.873,4.417L0,25.427L6.57,32        l9.148-9.151c1.361,0.553,2.846,0.875,4.408,0.875c6.545,0,11.865-5.322,11.865-11.859C31.992,5.32,26.672,0,20.127,0z         M20.127,19.727c-4.33,0-7.861-3.531-7.861-7.862c0-4.338,3.531-7.869,7.861-7.869c4.342,0,7.873,3.531,7.873,7.869        C28,16.195,24.469,19.727,20.127,19.727z"/></g></svg>',
      :mail => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M0,0v24h32V0H0z M24.859,4l-7.445,7.445c-0.781,0.781-2.047,0.781-2.828,0L7.141,4H24.859z M4,20    V6.516l7.758,7.758c1.172,1.172,2.703,1.758,4.242,1.758s3.07-0.586,4.242-1.758L28,6.516V20H4z"/></svg>',
      :mail_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g>    <polygon fill="{fill}" points="16.078,11.457 32,3.918 32,0 0,0 0,3.903     "/>    <polygon fill="{fill}" points="16.087,15.879 0,8.322 0,24 32,24 32,8.344     "/></g></svg>',
      :map_pin_fill => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 20 32" enable-background="new 0 0 20 32" xml:space="preserve"><g id="{id}"></g><g id="map_x5F_pin_x5F_fill_x5F_32x32">    <g>        <g>            <path fill="{fill}" d="M17.07,2.93c-3.906-3.906-10.234-3.906-14.141,0c-3.906,3.904-3.906,10.237,0,14.141                C2.93,17.07,10,24,10,32c0-8,7.07-14.93,7.07-14.93C20.977,13.167,20.977,6.833,17.07,2.93z M10,14.005c-2.211,0-4-1.789-4-4                s1.789-4,4-4s4,1.789,4,4S12.211,14.005,10,14.005z"/>        </g>    </g></g></svg>',
      :map_pin_stroke => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 20 32" enable-background="new 0 0 20 32" xml:space="preserve"><g id="{id}"></g><g id="map_x5F_pin_x5F_stroke_x5F_32x32">    <g>        <path fill="{fill}" d="M10,4c1.602,0,3.109,0.625,4.242,1.76C15.375,6.891,16,8.398,16,10s-0.625,3.109-1.734,4.213            c-0.164,0.166-2.234,2.224-4.266,5.441c-2.023-3.211-4.086-5.261-4.242-5.415C4.625,13.109,4,11.602,4,10s0.625-3.109,1.758-4.242            S8.398,4,10,4 M10,0C7.438,0,4.883,0.977,2.93,2.93c-3.906,3.904-3.906,10.237,0,14.141C2.93,17.07,10,24,10,32            c0-8,7.07-14.93,7.07-14.93c3.906-3.904,3.906-10.237,0-14.141C15.117,0.977,12.558,0,10,0L10,0z"/>        <path fill="{fill}" d="M12,10c0,1.105-0.896,2-2,2c-1.109,0-2-0.895-2-2s0.891-2,2-2C11.104,8,12,8.895,12,10z"/>    </g></g></svg>',
      :minus => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 8" style="enable-background:new 0 0 32 8;" xml:space="preserve"><rect style="{style}" width="32" height="8"/></svg>',
      :minus_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M16,0C7.165,0,0,7.164,0,16s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0z M24,18H8v-4h16V18z"/></svg>',
      :moon_fill => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="moon_x5F_fill_x5F_32x32">    <g>        <path fill="{fill}" d="M24.633,22.184c-8.188,0-14.82-6.637-14.82-14.82c0-2.695,0.773-5.188,2.031-7.363            C5.016,1.969,0,8.188,0,15.645C0,24.676,7.32,32,16.352,32c7.456,0,13.68-5.023,15.648-11.844            C29.82,21.41,27.328,22.184,24.633,22.184z"/>    </g></g></svg>',
      :moon_stroke => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="moon_x5F_stroke_x5F_32x32">    <path fill="{fill}" d="M5.891,9.148c0.852,8.959,8,16.109,16.961,16.953C20.938,27.311,18.698,28,16.352,28        C9.539,28,4,22.459,4,15.646C4,13.3,4.688,11.059,5.891,9.148 M11.844,0C5.016,1.969,0,8.19,0,15.646C0,24.678,7.32,32,16.352,32        c7.456,0,13.68-5.021,15.648-11.844c-2.18,1.256-4.672,2.029-7.367,2.029c-8.188,0-14.82-6.636-14.82-14.82        C9.812,4.67,10.586,2.178,11.844,0L11.844,0z"/></g></svg>',
      :move => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_32x32">    <g>        <polygon fill="{fill}" points="18,20 18,26 22,26 16,32 10,26 14,26 14,20         "/>        <polygon fill="{fill}" points="14,12 14,6 10,6 16,0 22,6 18,6 18,12         "/>        <polygon fill="{fill}" points="12,18 6,18 6,22 0,16 6,10 6,14 12,14         "/>        <polygon fill="{fill}" points="20,14 26,14 26,10 32,16 26,22 26,18 20,18         "/>    </g></g></svg>',
      :move_alt1 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_alt1_x5F_32x32">    <g>        <polygon fill="{fill}" points="16,22 18,20 18,26 22,26 16,32 10,26 14,26 14,20         "/>        <polygon fill="{fill}" points="16,10.062 14,12 14,6 10,6 16,0 22,6 18,6 18,12         "/>        <polygon fill="{fill}" points="10,16 12,18 6,18 6,22 0,16 6,10 6,14 12,14         "/>        <polygon fill="{fill}" points="21.938,16 20,14 26,14 26,10 32,16 26,22 26,18 20,18         "/>    </g></g></svg>',
      :move_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_alt2_x5F_32x32">    <path fill="{fill}"fill="5E6469" d="M16,0C7.165,0,0,7.164,0,16s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0z M22,20v-2h-4v4h2l-4,4l-4-4h2v-4h-4v2        l-4-4l4-4v2h4v-4h-2l4-4l4,4h-2v4h4v-2l4,4L22,20z"/></g></svg>',
      :move_horizontal => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 12" enable-background="new 0 0 32 12" xml:space="preserve"><g id="Layer_1_1_"></g><g id="move_x5F_horizontal_x5F_12x32">    <g>        <polygon fill="{fill}" points="12,8 6,8 6,12 0,6 6,0 6,4 12,4         "/>        <polygon fill="{fill}" points="20,4 26,4 26,0 32,6 26,12 26,8 20,8         "/>    </g></g></svg>',
      :move_horizontal_alt1 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 12" enable-background="new 0 0 32 12" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_horizontal_x5F_alt1_x5F_12x32">    <g>        <polygon fill="{fill}" points="10,6 12,8 6,8 6,12 0,6 6,0 6,4 12,4         "/>        <polygon fill="{fill}" points="21.938,6 20,4 26,4 26,0 32,6 26,12 26,8 20,8         "/>    </g></g></svg>',
      :move_horizontal_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_horizontal_x5F_alt2_x5F_32x32">    <path fill="{fill}" d="M32,16c0-8.836-7.163-16-16-16C7.165,0,0,7.164,0,16s7.165,16,16,16C24.837,32,32,24.836,32,16z M10,18v2        l-4-4l4-4v2h12v-2l4,4l-4,4v-2H10z"/></g></svg>',
      :move_vertical => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 12 32" enable-background="new 0 0 12 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_vertical_x5F_12x32">    <g>        <polygon fill="{fill}" points="8,20 8,26 12,26 6,32 0,26 4,26 4,20         "/>        <polygon fill="{fill}" points="4,12 4,6 0,6 6,0 12,6 8,6 8,12         "/>    </g></g></svg>',
      :move_vertical_alt1 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 12 32" enable-background="new 0 0 12 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_vertical_x5F_alt1_x5F_12x32">    <g>        <polygon fill="{fill}" points="6,22 8,20 8,26 12,26 6,32 0,26 4,26 4,20         "/>        <polygon fill="{fill}" points="6,10.062 4,12 4,6 0,6 6,0 12,6 8,6 8,12         "/>    </g></g></svg>',
      :move_vertical_alt2 => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="move_x5F_vertical_x5F_alt2_x5F_32x32">    <path fill="{fill}" d="M16,0C7.165,0,0,7.164,0,16s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0z M18,22h2l-4,4l-4-4h2V10        h-2l4-4l4,4h-2V22z"/></g></svg>',
      :movie => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}"d="M27.977,8h-3.95L28,4.016L24.073,0h-5.565l3.987,3.984L18.409,8h-4.722l4.058-3.984L13.734,0H8.078l3.984,3.984L7.977,8    H3.969l4.062-3.984L4.016,0H0v32h32V0h-3.922L32,4L27.977,8z M28,27.958H4v-4h24V27.958z M28,20H4v-4h24V20z"/></svg>',
      :new_window => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M32,0H8v7.998c-2.906,0-8,0-8,0.002v24h24v-8h8V0z M20,28H4V16h4v8h12C20,25.791,20,27.998,20,28z     M28,20H12V8h16V20z"/></svg>',
      :pause => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 32" style="enable-background:new 0 0 24 32;" xml:space="preserve"><g>    <rect style="{style}" width="8" height="32"/>    <rect x="16" style="{style}" width="8" height="32"/></g></svg>',
      :pen => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32.004" style="enable-background:new 0 0 32 32.004;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M29.656,2.344C28.1,0.781,26.053,0,24,0c-2.047,0-4.094,0.781-5.656,2.344L0.031,20.657L0,32.004    h11.312l18.344-18.347C32.781,10.535,32.781,5.468,29.656,2.344z M9.656,28.001H8v-4H4.021l0.006-1.681L21.172,5.172l0,0    l5.656,5.656v0L9.656,28.001z"/></svg>',
      :pen_alt_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32.002" style="enable-background:new 0 0 32 32.002;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M29.656,2.344c-3.119-3.125-8.191-3.125-11.312,0L0.031,20.656L0,32.002h11.312l18.344-18.346            C32.781,10.534,32.781,5.467,29.656,2.344z M9.609,28.002H3.953v-5.689c1.562-1.562,4.094-1.562,5.656,0            C11.172,23.877,11.172,26.439,9.609,28.002z M26.756,10.828L21.1,5.172c1.562-1.562,4.094-1.562,5.656,0            S28.318,9.266,26.756,10.828z"/>    </g></g></svg>',
      :pen_alt_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32.002" style="enable-background:new 0 0 32 32.002;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M29.656,2.344C28.094,0.781,26.047,0,24,0s-4.094,0.781-5.656,2.344L0.031,20.656L0,32.002h11.312    l18.344-18.346C32.781,10.534,32.781,5.466,29.656,2.344z M9.656,28H9.609c1.562-1.562,1.562-4.125,0-5.688    c-1.494-1.496-3.859-1.517-5.426-0.149L21.137,5.211l5.656,5.655L9.656,28z"/></svg>',
      :pin => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="pin_x5F_32x32">    <path fill="{fill}" d="M32,8c0-4.417-3.585-8-8-8c-2.984,0-5.562,1.659-6.938,4.086c0-0.002,0.004-0.004,0.004-0.005        c-0.363-0.036-0.723-0.112-1.098-0.112c-6.625,0-12,5.371-12,12c0,2.527,0.79,4.865,2.125,6.799L0,32l9.29-6.064        c1.913,1.283,4.21,2.033,6.679,2.033c6.629,0,12-5.371,12-12c0-0.346-0.069-0.669-0.101-1.008C30.321,13.594,32,11.005,32,8z         M15.969,23.969c-4.413,0-8-3.588-8-8c0-4.412,3.587-8,8-8c0.016,0,0.024,0.004,0.031,0.004c0-0.008,0.004-0.014,0.004-0.02        C16.004,7.969,16,7.984,16,8c0,0.695,0.118,1.355,0.281,1.998l-3.172,3.174c-1.562,1.562-1.562,4.094,0,5.656s4.094,1.562,5.656,0        l3.141-3.141c0.66,0.18,1.344,0.305,2.062,0.309C23.953,20.396,20.375,23.969,15.969,23.969z M24,12c-2.203,0-4-1.794-4-4        s1.797-4,4-4s4,1.794,4,4S26.203,12,24,12z"/></g></svg>',
      :play => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 32" style="enable-background:new 0 0 24 32;" xml:space="preserve"><polygon style="{style}" points="0,0 24,16 0,32 "/></svg>',
      :play_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0z M10,24V8l16.008,8L10,24z"    /></svg>',
      :plus => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><polygon style="{style}" points="32,12 20,12 20,0 12,0 12,12 0,12 0,20 12,20 12,32 20,32 20,20 32,20 "/></svg>',
      :plus_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><path fill="{fill}" d="M16,0C7.165,0,0,7.164,0,16s7.165,16,16,16c8.837,0,16-7.164,16-16S24.837,0,16,0z M24,18h-6v6h-4v-6H8v-4h6    V8h4v6h6V18z"/></svg>',
      :read_more => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <polygon style="{style}" points="32,4 0,4 0,0 32,0 32,4     "/>    <polygon style="{style}" points="20,12 0,12 0,8 20,8 20,12     "/>    <polygon style="{style}" points="32,20.086 0,20.086 0,16.086 32,16.086 32,20.086     "/>    <circle style="{style}" cx="2" cy="30" r="2"/>    <path fill="{fill}"style="{style}" d="M12,30c0,1.104-0.898,2-2,2c-1.109,0-2.004-0.896-2.004-2S8.891,28,10,28C11.102,28,12,28.896,12,30        z"/>    <circle style="{style}" cx="18" cy="30" r="2"/></g></svg>',
      :reload => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 28" style="enable-background:new 0 0 24 28;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M20,16c0,4.41-3.586,8-8,8s-8-3.59-8-8s3.586-8,8-8l2.359,0.027l-1.164,1.164l2.828,2.828L22.035,6        l-6.012-6l-2.828,2.828L14.375,4H12C5.375,4,0,9.371,0,16s5.375,12,12,12s12-5.371,12-12H20z"/></g></svg>',
      :reload_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 28" style="enable-background:new 0 0 24 28;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M20,16c0,4.414-3.586,8-8,8s-8-3.586-8-8s3.586-8,8-8l4.023,0.043v3.977L22.035,6l-6.012-6v4H12        C5.375,4,0,9.375,0,16s5.375,12,12,12s12-5.375,12-12H20z"/></g></svg>',
      :right_quote => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g id="{id}"></g><g id="right_x5F_quote_x5F_32x32">    <g>        <path fill="{fill}" d="M0,0v12h8c0,4.411-3.585,8-8,8v4c6.618,0,12-5.383,12-12V0H0z"/>        <path fill="{fill}" d="M20,0v12h8c0,4.411-3.585,8-8,8v4c6.618,0,12-5.383,12-12V0H20z"/>    </g></g></svg>',
      :right_quote_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 24" enable-background="new 0 0 32 24" xml:space="preserve"><g id="{id}"></g><g id="right_x5F_quote_x5F_alt_x5F_32x32">    <g>        <polygon fill="{fill}" points="0,0 0,24 12,12 12,0         "/>        <polygon fill="{fill}" points="20,0 20,24 32,12 32,0         "/>    </g></g></svg>',
      :rss => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <circle style="{style}" cx="4.001" cy="28" r="4.001"/>    <g>        <path fill="{fill}"style="{style}" d="M6.023,20.004c3.309,0,6,2.691,6,6.004h4.001C16.025,20.492,11.538,16,6.023,16V20.004z"/>    </g>    <g>        <path fill="{fill}"style="{style}" d="M5.996,12c7.719,0,14.002,6.285,14.002,14.007h4C23.998,16.078,15.923,8,5.996,8V12z"/>    </g>    <g>        <path fill="{fill}"style="{style}" d="M5.996,4C18.129,4,28,13.871,28,26.008h4C32,11.665,20.334,0,5.996,0V4z"/>    </g></g></svg>',
      :rss_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g>    <path fill="{fill}"d="M32,32h-4.569C27.431,16.875,15.125,4.573,0,4.573V0C17.641,0,32,14.355,32,32L32,32z"/>    <path fill="{fill}"d="M22.859,32h-4.574c0-10.082-8.207-18.285-18.285-18.285V9.143C12.603,9.143,22.859,19.398,22.859,32L22.859,32z"/>    <path fill="{fill}"d="M13.719,32H9.141c0-5.043-4.094-9.143-9.141-9.143v-4.572C7.562,18.285,13.719,24.438,13.719,32L13.719,32z"/>    <path fill="{fill}"d="M4.571,32c0-2.523-2.04-4.57-4.571-4.57V32H4.571z"/></g></svg>',
      :spin => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 28 32" enable-background="new 0 0 28 32" xml:space="preserve"><g id="{id}"></g><g id="reload_x5F_alt2_x5F_28x32">    <g>        <path fill="{fill}"d="M23.883,6.086l-2.82,2.831C22.953,10.808,24,13.323,24,16c0,5.516-4.484,10-10,10v-2l-4,4l4,4v-2c7.719,0,14-6.281,14-14            C28,12.255,26.539,8.734,23.883,6.086z"/>        <path fill="{fill}"d="M18,4l-4-4v2C6.281,2,0,8.281,0,16c0,3.745,1.461,7.266,4.117,9.914l2.82-2.831C5.047,21.192,4,18.677,4,16            C4,10.484,8.484,6,14,6v2L18,4z"/>    </g></g></svg>',
      :spin_alt => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="reload_x5F_alt3_x5F_32x32">    <g>        <path fill="{fill}"d="M4.688,27.32C1.664,24.297,0,20.281,0,16C0,7.18,7.172,0,16,0l2,2l-2,2C9.383,4,4,9.383,4,16            c0,3.211,1.25,6.227,3.516,8.492l-2.453,0.32L4.688,27.32L4.688,27.32z"/>        <path fill="{fill}"d="M16,32l-2-1.992L16,28c6.617,0,12-5.383,12-12c0-3.203-1.25-6.219-3.523-8.489l2.461-0.323l0.367-2.505            C30.328,7.708,32,11.727,32,16C32,24.82,24.82,32,16,32L16,32z"/>    </g></g></svg>',
      :star => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="star_x5F_32x32">    <g>        <polygon fill="{fill}" points="22.136,19.625 32,12 20,12 16,0 12,12 0,12 9.875,19.594 6,32 16.016,24.32 26.008,32         "/>    </g></g></svg>',
      :stop => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><rect style="{style}" width="32" height="32"/></svg>',
      :sun => '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="{width}"     height="{height}" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve"><g id="{id}"></g><g id="sun_x5F_32x32">    <g>        <path fill="{fill}" d="M24,16c0,4.417-3.585,8-8,8c-4.422,0-8-3.583-8-8s3.578-8,8-8C20.415,8,24,11.583,24,16z"/>        <path fill="{fill}" d="M16,3.312c1.384,0,2.691,0.276,3.938,0.688H20l-4-4l-4,4h0.056C13.306,3.589,14.613,3.312,16,3.312z"/>        <path fill="{fill}" d="M16,28.688c-1.387,0-2.694-0.276-3.944-0.688H12l4,4l4-4h-0.062C18.691,28.411,17.384,28.688,16,28.688z"            />        <path fill="{fill}" d="M28.688,16c0,1.383-0.281,2.695-0.688,3.942V20l4-4l-4-4v0.058C28.406,13.305,28.688,14.617,28.688,16z"/>        <path fill="{fill}" d="M3.312,16c0-1.383,0.274-2.695,0.688-3.942V12l-4,4l4,4v-0.058C3.587,18.695,3.312,17.383,3.312,16z"/>        <path fill="{fill}" d="M24.969,24.969c-0.976,0.984-2.101,1.711-3.272,2.305l-0.04,0.039h5.656v-5.656l-0.043,0.042            C26.681,22.87,25.953,23.992,24.969,24.969z"/>        <path fill="{fill}" d="M7.031,7.031c0.978-0.984,2.094-1.711,3.266-2.305l0.047-0.039H4.688v5.656l0.04-0.042            C5.321,9.13,6.047,8.008,7.031,7.031z"/>        <path fill="{fill}" d="M7.031,24.969c-0.984-0.977-1.71-2.099-2.304-3.271l-0.04-0.042v5.656h5.656l-0.047-0.039            C9.125,26.68,8.009,25.953,7.031,24.969z"/>        <path fill="{fill}" d="M24.969,7.031c0.984,0.977,1.712,2.099,2.301,3.271l0.043,0.042V4.688h-5.656l0.04,0.039            C22.868,5.32,23.993,6.047,24.969,7.031z"/>    </g></g></svg>',
      :tag_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M13.277,0H0v13.277L18.719,32V18.723H32L13.277,0z M7.312,11.121c-2.102,0-3.805-1.703-3.805-3.805    s1.703-3.805,3.805-3.805s3.805,1.703,3.805,3.805S9.414,11.121,7.312,11.121z"/></svg>',
      :tag_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M11.699,8.613c0,1.703-1.383,3.086-3.082,3.086c-1.703,0-3.086-1.383-3.086-3.086        c0-1.699,1.383-3.078,3.086-3.078C10.316,5.535,11.699,6.914,11.699,8.613z"/>    <g>        <path fill="{fill}"style="{style}" d="M0,0v13.273L18.727,32c0,0,0-10.793,0-13.27c2.477,0,13.273,0,13.273,0L13.273,0H0z M11.797,3.562            c0.773,0.77,7.879,7.883,11.602,11.605c-3.102,0-8.234,0-8.234,0s0,5.133,0,8.227C11.441,19.676,4.336,12.566,3.562,11.801            c0-1.055,0-5.961,0-8.238C5.84,3.562,10.742,3.562,11.797,3.562z"/>    </g></g></svg>',
      :trash_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M28,4h-4c0-2.211-1.789-4-4-4h-8C9.789,0,8,1.789,8,4H4H0v4h4v18c0,3.312,2.688,6,6,6h12    c3.312,0,6-2.688,6-6V8h4V4H28z M12,24c-1.105,0-2-0.896-2-2s0.895-2,2-2s2,0.896,2,2S13.105,24,12,24z M12,16c-1.105,0-2-0.896-2-2    s0.895-2,2-2s2,0.896,2,2S13.105,16,12,16z M20,24c-1.105,0-2-0.896-2-2s0.895-2,2-2s2,0.896,2,2S21.105,24,20,24z M20,16    c-1.105,0-2-0.896-2-2s0.895-2,2-2s2,0.896,2,2S21.105,16,20,16z"/></svg>',
      :trash_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M32,4h-4h-4c0-2.211-1.789-4-4-4h-8C9.789,0,8,1.789,8,4H4H0v4h4v18c0,3.312,2.688,6,6,6h12        c3.312,0,6-2.688,6-6V8h4V4z M24,26c0,1.102-0.898,2-2,2H10c-1.102,0-2-0.898-2-2V8h16V26z"/>    <circle style="{style}" cx="12" cy="22" r="2"/>    <circle style="{style}" cx="12" cy="14" r="2"/>    <circle style="{style}" cx="20" cy="22" r="2"/>    <circle style="{style}" cx="20" cy="14" r="2"/></g></svg>',
      :undo => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 31.985" style="enable-background:new 0 0 32 31.985;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M28.156,3.72c-4.957-4.958-13.604-4.961-18.557,0L4,9.32V4.001H0v12h12v-4H6.975l5.453-5.453        c3.447-3.445,9.453-3.445,12.9,0.007C27.053,8.274,28,10.563,28,13.001s-0.947,4.727-2.672,6.453l-3.016,3.008l2.828,2.828        l3.016-3.008C30.631,19.805,32,16.508,32,13.001C32,9.493,30.631,6.196,28.156,3.72z"/>            <rect x="16.449" y="27.157" transform="matrix(0.7071 0.7071 -0.7071 0.7071 26.0209 -4.5056)" style="{style}" width="4" height="4"/></g></svg>',
      :unlock_fill => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24.008 32" style="enable-background:new 0 0 24.008 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M14.008,0c-5.516,0-10,4.487-10,10h4c0-3.309,2.688-6,6-6c3.305,0,6,2.691,6,6v2H0v14    c0,3.308,2.695,6,6,6h12.008c3.305,0,6-2.692,6-6V10C24.008,4.487,19.518,0,14.008,0z M12,24c-1.102,0-2-0.896-2-2    c0-1.105,0.898-2,2-2c1.109,0,2,0.895,2,2C14,23.104,13.109,24,12,24z"/></svg>',
      :unlock_stroke => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24.008 32" style="enable-background:new 0 0 24.008 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M14.008,0c-5.516,0-10,4.489-10,10h4c0-3.305,2.691-6,6-6s6,2.695,6,6v2H0v14c0,3.312,2.691,6,6,6        h12.008c3.309,0,6-2.688,6-6V10C24.008,4.489,19.523,0,14.008,0z M18.008,28H6c-1.102,0-2-0.896-2-2V16h16.008v10        C20.008,27.104,19.109,28,18.008,28z"/>    <path fill="{fill}"style="{style}" d="M14.004,22c0,1.109-0.895,2-2,2s-2-0.891-2-2c0-1.102,0.895-2,2-2S14.004,20.898,14.004,22z"/></g></svg>',
      :user => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 24 32" style="enable-background:new 0 0 24 32;" xml:space="preserve"><g>    <path fill="{fill}"style="{style}" d="M12,16C5.375,16,0,21.372,0,28c0,2.208,1.789,4,4,4h16c2.211,0,4-1.792,4-4        C24,21.372,18.625,16,12,16z"/>    <circle style="{style}" cx="12" cy="6" r="6"/></g></svg>',
      :volume => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M8,20c-4.416,0-8-3.579-8-8s3.584-8,8-8V20z"/>    </g>    <g>        <polygon style="{style}" points="12,4 20,0 20,24 12,20         "/>    </g>    <path fill="{fill}"style="{style}" d="M24.006,19.999v-4c0.328,0,0.666-0.046,1-0.125C26.762,15.423,28,13.829,28,12        s-1.238-3.422-3.01-3.874c-0.318-0.078-0.656-0.118-0.984-0.118v-4c0.656,0,1.312,0.085,1.953,0.241C29.521,5.155,32,8.336,32,12        c0,3.671-2.479,6.858-6.025,7.751C25.309,19.914,24.652,19.999,24.006,19.999L24.006,19.999z"/></g></svg>',
      :volume_mute => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" xml:space="preserve"><g>    <g>        <path fill="{fill}"style="{style}" d="M8,20c-4.418,0-8-3.583-8-8s3.582-8,8-8V20z"/>    </g>    <g>        <polygon style="{style}" points="12,4 20,0 20,24 12,20         "/>    </g>    <polygon style="{style}" points="32,14 24,14 24,10 32,10 32,14     "/></g></svg>',
      :x => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 28 28" style="enable-background:new 0 0 28 28;" xml:space="preserve"><g>    <polygon style="{style}" points="28,22.398 19.594,14 28,5.602 22.398,0 14,8.402 5.598,0 0,5.602 8.398,14 0,22.398         5.598,28 14,19.598 22.398,28     "/></g></svg>',
      :x_alt => '<svg version="1.1" id="{id}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"     width="{width}" height="{height}" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><path fill="{fill}"style="{style}" d="M16,0C7.164,0,0,7.164,0,16s7.164,16,16,16s16-7.164,16-16S24.836,0,16,0z M23.914,21.086    l-2.828,2.828L16,18.828l-5.086,5.086l-2.828-2.828L13.172,16l-5.086-5.086l2.828-2.828L16,13.172l5.086-5.086l2.828,2.828    L18.828,16L23.914,21.086z"/></svg>',
    }
  end
end
require 'active_admin/iconic/icons'

module ActiveAdmin
  module Iconic

    # Default color to use for icons
    @@default_color = "#5E6469"
    mattr_accessor :default_color

    # Default width to use for icons
    @@default_width = 15
    mattr_accessor :default_width

    # Default height to use for icons
    @@default_height = 15
    mattr_accessor :default_height

    # Render an icon:
    #   Iconic.icon :loop
    def self.icon(name, options = {})
      options = {
        :color => default_color,
        :width => default_width,
        :height => default_height,
        :id => ""
      }.merge(options)


      options[:style] = "fill:#{options[:color]};"
      options[:fill] = options.delete(:color)

      # Convert to strings representations of pixels
      [:width, :height].each do |key|
        options[key] = "#{options[key]}px" unless options[key].is_a?(String)
      end

      template = ICONS[name.to_sym]

      if template
        svg = template.dup
        options.each do |key, value|
          svg.gsub!("{#{key}}", value)
        end
        "<span class=\"icon icon_#{name}\">#{svg}</span>".html_safe
      else
        raise "Could not find the icon named #{name}"
      end
    end

  end
end
module ActiveAdmin
  module Inputs
    class DatepickerInput < ::Formtastic::Inputs::StringInput
      def input_html_options
        options = super
        options[:class] = [options[:class], "datepicker"].compact.join(' ')
        options
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    module FilterBase
      include ::Formtastic::Inputs::Base

      def input_wrapping(&block)
        template.content_tag(:div,
          template.capture(&block),
          wrapper_html_options
        )
      end

      def required?
        false
      end

      def wrapper_html_options
        { :class => "filter_form_field #{as}" }
      end

      # Override the standard finder to accept a proc
      def collection_from_options
        if options[:collection].is_a?(Proc)
          template.instance_eval(&options[:collection])
        else
          super
        end
      end

      # Returns the default label for a given attribute
      # Will use ActiveModel I18n if possible
      def humanized_method_name
        if object.base.respond_to?(:human_attribute_name)
          object.base.human_attribute_name(method)
        else
          method.to_s.send(builder.label_str_method)
        end
      end

      # Returns the association reflection for the method if it exists
      def reflection_for(method)
        @object.base.reflect_on_association(method) if @object.base.respond_to?(:reflect_on_association)
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterBooleanInput < ::Formtastic::Inputs::BooleanInput
      include FilterBase

      def to_html
        input_wrapping do 
          [ label_html,
            check_box_html
          ].join("\n").html_safe
        end
      end

      def check_box_html
        template.check_box_tag("#{object_name}[#{method}]", checked_value, checked?, input_html_options)
      end

      def search_method
        method.to_s.match(metasearch_conditions) ? method : "#{method}_eq"
      end

      def checked?
        if defined? ActionView::Helpers::InstanceTag
          object && ActionView::Helpers::InstanceTag.check_box_checked?(object.send(search_method), checked_value)
        else
          object && boolean_checked?(object.send(search_method), checked_value)
        end
      end

      def input_html_options
        { :name => "q[#{search_method}]" }
      end

      def metasearch_conditions
        /(is_true|is_false|is_present|is_blank|is_null|is_not_null)$/
      end

    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterCheckBoxesInput < ::Formtastic::Inputs::CheckBoxesInput
      include FilterBase

      def input_name
        "#{object_name}[#{association_primary_key || method}_in][]"
      end

      def selected_values
        @object.send("#{association_primary_key || method}_in") || []
      end

      # Add whitespace before label
      def choice_label(choice)
        " #{super(choice)}"
      end

      # Don't wrap in UL tag
      def choices_group_wrapping(&block)
        template.capture(&block)
      end

      # Don't wrap in LI tag
      def choice_wrapping(html_options, &block)
        template.capture(&block)
      end

      # Don't render hidden fields
      def hidden_field_for_all
        ""
      end

      # Don't render hidden fields
      def hidden_fields?
        false
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterDateRangeInput < ::Formtastic::Inputs::StringInput
      include FilterBase

      def to_html
        input_wrapping do
          [ label_html,
            builder.text_field(gt_input_name, input_html_options(gt_input_name)),
            template.content_tag(:span, "-", :class => "seperator"),
            builder.text_field(lt_input_name, input_html_options(lt_input_name)),
          ].join("\n").html_safe
        end
      end

      def gt_input_name
        "#{method}_gte"
      end
      alias :input_name :gt_input_name

      def lt_input_name
        "#{method}_lte"
      end

      def input_html_options(input_name = gt_input_name)
        current_value = @object.send(input_name)
        { :size => 12,
          :class => "datepicker",
          :max => 10,
          :value => current_value.respond_to?(:strftime) ? current_value.strftime("%Y-%m-%d") : "" }
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterNumericInput < ::Formtastic::Inputs::NumberInput
      include FilterBase

      def to_html
        input_wrapping do
          [ label_html,
            select_html,
            " ",
            input_html
          ].join("\n").html_safe
        end
      end

      def input_html
        builder.text_field current_filter, input_html_options
      end

      def input_html_options
        { :size => 10, :id => "#{method}_numeric" }
      end

      def select_html
        template.select_tag '', select_options, select_html_options
      end

      def select_options
        template.options_for_select(filters, current_filter)
      end

      def select_html_options
        { :onchange => "document.getElementById('#{method}_numeric').name = 'q[' + this.value + ']';" }
      end

      # Returns the scope for which we are currently searching. If no search is available
      # it returns the first scope
      def current_filter
        filters[1..-1].inject(filters.first){|a,b| @object.send(b[1].to_sym) ? b : a }[1]
      end

      def filters
        (options[:filters] || default_filters).collect do |scope|
          [scope[0], [method, scope[1]].join("_")]
        end
      end

      def default_filters
        [ [I18n.t('active_admin.equal_to'), 'eq'],
          [I18n.t('active_admin.greater_than'), 'gt'],
          [I18n.t('active_admin.less_than'), 'lt'] ]
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterSelectInput < ::Formtastic::Inputs::SelectInput
      include FilterBase

      def input_name
        "#{super}_eq"
      end

      def input_options
        super.merge(:include_blank => I18n.t('active_admin.any'))
      end

      def method
        if super.to_s.scan(/_id/).count('_id') == 1
          super.to_s.sub(/_id$/, '').to_sym
        else
          super.to_s.to_sym
        end
      end

      def extra_input_html_options
        {}
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    class FilterStringInput < ::Formtastic::Inputs::StringInput
      include FilterBase

      def to_html
        input_wrapping do
          label_html <<
          builder.text_field(input_name, input_html_options)
        end
      end

      def label_text
        I18n.t('active_admin.search_field', :field => super)
      end

      def input_name
        method.to_s.match(metasearch_conditions) ? method : "#{method}_contains"
      end

      def metasearch_conditions
        /starts_with|ends_with/
      end
    end
  end
end
module ActiveAdmin
  module Inputs
    extend ActiveSupport::Autoload

    autoload :DatepickerInput

    autoload :FilterBase
    autoload :FilterStringInput
    autoload :FilterDateRangeInput
    autoload :FilterNumericInput
    autoload :FilterSelectInput
    autoload :FilterCheckBoxesInput
    autoload :FilterBooleanInput
  end
end
module ActiveAdmin

  # Each Namespace builds up it's own menu as the global navigation
  #
  # To build a new menu:
  #
  #   menu = Menu.new do |m|
  #     m.add label: 'Dashboard', url: '/'
  #     m.add label: 'Users',     url: '/users'
  #   end
  #
  # If you're interested in configuring a menu item, take a look at the
  # options available in `ActiveAdmin::MenuItem`
  #
  class Menu

    def initialize
      super # MenuNode
      yield(self) if block_given?
    end

    module MenuNode
      def initialize
        @children = {}
      end

      def [](id)
        @children[normalize_id(id)]
      end
      def []=(id, child)
        @children[normalize_id(id)] = child
      end

      # Recursively builds any given menu items. There are two syntaxes supported,
      # as shown in the below examples. Both create an identical menu structure.
      #
      # Example 1:
      #   menu = Menu.new
      #   menu.add label: 'Dashboard' do |dash|
      #     dash.add label: 'My Child Dashboard'
      #   end
      #
      # Example 2:
      #   menu = Menu.new
      #   menu.add label:  'Dashboard'
      #   menu.add parent: 'Dashboard', label: 'My Child Dashboard'
      #
      def add(options)
        item = if parent = options.delete(:parent)
          (self[parent] || add(:label => parent)).add options
        else
          _add options.merge :parent => self
        end

        yield(item) if block_given?

        item
      end

      # Whether any children match the given item.
      def include?(item)
        @children.values.include? item
      end

      # Used in the UI to visually distinguish which menu item is selected.
      def current?(item)
        self == item || include?(item)
      end

      # Returns sorted array of menu items that should be displayed in this context.
      # Sorts by priority first, then alphabetically by label if needed.
      def items(context = nil)
        @children.values.select{ |i| i.display?(context) }.sort do |a,b|
          result = a.priority       <=> b.priority
          result = a.label(context) <=> b.label(context) if result == 0
          result
        end
      end

      attr_reader :children
      private
      attr_writer :children

      # The method that actually adds new menu items. Called by the public method.
      # If this ID is already taken, transfer the children of the existing item to the new item.
      def _add(options)
        item = ActiveAdmin::MenuItem.new(options)
        item.send :children=, self[item.id].children if self[item.id]
        self[item.id] = item
      end

      def normalize_id(id)
        case id
        when String, Symbol
          id.to_s.downcase.gsub ' ', '_'
        else
          raise TypeError, "#{id.class} isn't supported as a Menu ID"
        end
      end
    end

    include MenuNode

  end
end
module ActiveAdmin

  DEFAULT_MENU = :default

  # A MenuCollection stores multiple menus for any given namespace. Namespaces delegate
  # the addition of menu items to this class.
  class MenuCollection

    NoMenuError = Class.new(KeyError)

    def initialize
      @menus = {}
      @build_callbacks = []
      @built = false
    end

    # Add a new menu item to a menu in the collection
    def add(menu_name, menu_item_options = {})
      menu = find_or_create(menu_name)

      menu.add menu_item_options
    end

    def clear!
      @menus = {}
      @built = false
    end

    def exists?(menu_name)
      @menus.keys.include? menu_name
    end

    def fetch(menu_name)
      build_menus!

      @menus[menu_name] or
        raise NoMenuError, "No menu by the name of #{menu_name.inspect} in availble menus: #{@menus.keys.join(", ")}"
    end

    # Add callbacks that will be run when the menu is going to be built. This
    # helps use with reloading and allows configurations to add items to menus.
    #
    # @param [Proc] block A block which will be ran when the menu is built. The
    #                   will have the menu collection yielded.
    def on_build(&block)
      @build_callbacks << block
    end

    # Add callbacks that will be run before the menu is built
    def before_build(&block)
      @build_callbacks.unshift(block)
    end

    def menu(menu_name)
      menu = find_or_create(menu_name)

      yield(menu) if block_given?

      menu
    end

    private

    def built?
      @built
    end

    def build_menus!
      return if built?

      build_default_menu
      run_on_build_callbacks

      @built = true
    end

    def run_on_build_callbacks
      @build_callbacks.each do |callback|
        callback.call(self)
      end
    end

    def build_default_menu
      find_or_create DEFAULT_MENU
    end

    def find_or_create(menu_name)
      menu_name ||= DEFAULT_MENU
      @menus[menu_name] ||= ActiveAdmin::Menu.new
    end



  end

end
require 'active_admin/view_helpers/method_or_proc_helper'

module ActiveAdmin
  class MenuItem
    include Menu::MenuNode
    include MethodOrProcHelper

    attr_reader :html_options, :parent, :priority

    # Builds a new menu item
    #
    # @param [Hash] options The options for the menu
    #
    # @option options [String, Symbol, Proc] :label
    #         The label to display for this menu item.
    #         Default: Titleized Resource Name
    #
    # @option options [String] :id
    #         A custom id to reference this menu item with.
    #         Default: underscored_resource_name
    #
    # @option options [String, Symbol, Proc] :url
    #         The URL this item will link to.
    #
    # @option options [Integer] :priority
    #         The lower the priority, the earlier in the menu the item will be displayed.
    #         Default: 10
    #
    # @option options [Symbol, Proc] :if
    #         This decides whether the menu item will be displayed. Evaluated on each request.
    #
    # @option options [Hash] :html_options
    #         A hash of options to pass to `link_to` when rendering the item
    #
    # @option [ActiveAdmin::MenuItem] :parent
    #         This menu item's parent. It will be displayed nested below its parent.
    #
    # NOTE: for :label, :url, and :if
    # These options are evaluated in the view context at render time. Symbols are called
    # as methods on `self`, and Procs are exec'd within `self`.
    # Here are some examples of what you can do:
    #
    #   menu if:  :admin?
    #   menu url: :new_book_path
    #   menu url: :awesome_helper_you_defined
    #   menu label: ->{ User.some_method }
    #   menu label: ->{ I18n.t 'menus.user' }
    #
    def initialize(options = {})
      super() # MenuNode
      @label          = options[:label]
      @dirty_id       = options[:id]           || options[:label]
      @url            = options[:url]          || '#'
      @priority       = options[:priority]     || 10
      @html_options   = options[:html_options] || {}
      @should_display = options[:if]           || proc{true}
      @parent         = options[:parent]

      yield(self) if block_given? # Builder style syntax
    end

    def id
      @id ||= normalize_id @dirty_id
    end

    def label(context = nil)
      render_in_context context, @label
    end

    def url(context = nil)
      render_in_context context, @url
    end

    # Don't display if the :if option passed says so
    # Don't display if the link isn't real, we have children, and none of the children are being displayed.
    def display?(context = nil)
      return false unless render_in_context(context, @should_display)
      return false if     !real_url?(context) && @children.any? && !items(context).any?
      true
    end

    # Returns an array of the ancestory of this menu item.
    # The first item is the immediate parent of the item.
    def ancestors
      parent ? [parent, parent.ancestors].flatten : []
    end

    private

    # URL is not nil, empty, or '#'
    def real_url?(context = nil)
      url = url context
      url.present? && url != '#'
    end

  end
end
require 'active_admin/helpers/settings'
require 'active_admin/resource_collection'

module ActiveAdmin

  class ResourceMismatchError < StandardError; end

  # Namespaces are the basic organizing principle for resources within Active Admin
  #
  # Each resource is registered into a namespace which defines:
  #   * the namespaceing for routing
  #   * the module to namespace controllers
  #   * the menu which gets displayed (other resources in the same namespace)
  #
  # For example:
  #   
  #   ActiveAdmin.register Post, :namespace => :admin
  #
  # Will register the Post model into the "admin" namespace. This will namespace the
  # urls for the resource to "/admin/posts" and will set the controller to
  # Admin::PostsController
  #
  # You can also register to the "root" namespace, which is to say no namespace at all.
  #
  #   ActiveAdmin.register Post, :namespace => false
  #
  # This will register the resource to an instantiated namespace called :root. The 
  # resource will be accessible from "/posts" and the controller will be PostsController.
  #
  class Namespace
    include Settings

    RegisterEvent = 'active_admin.namespace.register'.freeze

    attr_reader :application, :resources, :name, :menus

    def initialize(application, name)
      @application = application
      @name = name.to_s.underscore.to_sym
      @resources = ResourceCollection.new
      register_module unless root?
      generate_dashboard_controller
      build_menu_collection
    end

    # Register a resource into this namespace. The preffered method to access this is to 
    # use the global registration ActiveAdmin.register which delegates to the proper 
    # namespace instance.
    def register(resource_class, options = {}, &block)
      config = find_or_build_resource(resource_class, options)

      # Register the resource
      register_resource_controller(config)
      parse_registration_block(config, &block) if block_given?
      reset_menu!

      # Ensure that the dashboard is generated
      generate_dashboard_controller

      # Dispatch a registration event
      ActiveAdmin::Event.dispatch ActiveAdmin::Resource::RegisterEvent, config

      # Return the config
      config
    end

    def register_page(name, options = {}, &block)
      config = build_page(name, options)

      # Register the resource
      register_page_controller(config)
      parse_page_registration_block(config, &block) if block_given?
      reset_menu!

      config
    end

    def root?
      name == :root
    end

    # Returns the name of the module if required. Will be nil if none
    # is required.
    #
    # eg: 
    #   Namespace.new(:admin).module_name # => 'Admin'
    #   Namespace.new(:root).module_name # => nil
    #
    def module_name
      return nil if root?
      @module_name ||= name.to_s.camelize
    end

    # Returns the name of the dashboard controller for this namespace
    def dashboard_controller_name
      [module_name, "DashboardController"].compact.join("::")
    end

    # Unload all the registered resources for this namespace
    def unload!
      unload_resources!
      unload_dashboard!
      reset_menu!
    end

    # Returns the first registered ActiveAdmin::Resource instance for a given class
    def resource_for(klass)
      resources.find_by_resource_class(klass)
    end

    # Override from ActiveAdmin::Settings to inherit default attributes
    # from the application
    def read_default_setting(name)
      application.send(name)
    end

    def fetch_menu(name)
      @menus.fetch(name)
    end

    def reset_menu!
      @menus.clear!
    end

    # Add a callback to be ran when we build the menu
    #
    # @param [Symbol] name The name of the menu. Default: :default
    # @param [Proc] block The block to be ran when the menu is built
    #
    # @returns [void]
    def build_menu(name = DEFAULT_MENU, &block)
      @menus.before_build do |menus|
        menus.menu name do |menu|
          block.call(menu)
        end
      end
    end

    # Add the default logout button to the menu, using the ActiveAdmin configuration settings
    #
    # @param [ActiveAdmin::MenuItem] menu The menu to add the logout link to
    # @param [Fixnum] priority Override the default priority of 100 to position the logout button where you want
    # @param [Hash] html_options An options hash to pass along to link_to
    #
    # @returns [void]
    def add_logout_button_to_menu(menu, priority=100, html_options={})
      if logout_link_path
        logout_method = logout_link_method || :get
        menu.add :id           => 'logout',
                 :priority     => priority,
                 :label        => proc{ I18n.t('active_admin.logout') },
                 :html_options => html_options.reverse_merge(:method => logout_method),
                 :url          => proc{ render_or_call_method_or_proc_on self, active_admin_namespace.logout_link_path },
                 :if           => proc{ current_active_admin_user? }
      end
    end

    protected

    def build_menu_collection
      @menus = MenuCollection.new

      @menus.on_build do |menus|
        # Support for deprecated dashboards...
        Dashboards.add_to_menu(self, menus.menu(DEFAULT_MENU))

        # Build the default utility navigation
        build_default_utility_nav

        resources.each do |resource|
          resource.add_to_menu(@menus)
        end
      end
    end

    # Builds the default utility navigation in top right header with current user & logout button
    def build_default_utility_nav
      return if @menus.exists? :utility_navigation
      @menus.menu :utility_navigation do |menu|
        menu.add  :label  => proc{ display_name current_active_admin_user },
                  :url    => '#',
                  :id     => 'current_user',
                  :if     => proc{ current_active_admin_user? }
                  
        add_logout_button_to_menu menu
      end
    end

    # Either returns an existing Resource instance or builds a new
    # one for the resource and options
    def find_or_build_resource(resource_class, options)
      resources.add Resource.new(self, resource_class, options)
    end

    def build_page(name, options)
      resources.add Page.new(self, name, options)
    end

    def register_page_controller(config)
      eval "class ::#{config.controller_name} < ActiveAdmin::PageController; end"
      config.controller.active_admin_config = config
    end

    def unload_resources!
      resources.each do |resource|
        parent = (module_name || 'Object').constantize
        const_name = resource.controller_name.split('::').last
        # Remove the const if its been defined
        parent.send(:remove_const, const_name) if parent.const_defined?(const_name)

        # Remove circular references
        resource.controller.active_admin_config = nil
        if resource.is_a?(Resource) && resource.dsl
          resource.dsl.run_registration_block { @config = nil }
        end
      end
      @resources = ResourceCollection.new
    end

    def unload_dashboard!
      # TODO: Only clear out my sections
      Dashboards.clear_all_sections!
    end

    # Creates a ruby module to namespace all the classes in if required
    def register_module
      eval "module ::#{module_name}; end"
    end

    def register_resource_controller(config)
      eval "class ::#{config.controller_name} < ActiveAdmin::ResourceController; end"
      config.controller.active_admin_config = config
    end

    def parse_registration_block(config, &block)
      config.dsl = ResourceDSL.new(config)
      config.dsl.run_registration_block(&block)
    end

    def parse_page_registration_block(config, &block)
      PageDSL.new(config).run_registration_block(&block)
    end

    # Creates a dashboard controller for this config
    def generate_dashboard_controller
      return unless ActiveAdmin::Dashboards.built?

      eval "class ::#{dashboard_controller_name} < ActiveAdmin::PageController
              include ActiveAdmin::Dashboards::DashboardController
            end"
    end
  end
end
module ActiveAdmin
  # Page is the primary data storage for page configuration in Active Admin
  #
  # When you register a page (ActiveAdmin.page "Status") you are actually creating
  # a new Page instance within the given Namespace.
  #
  # The instance of the current page is available in PageController and views
  # by calling the #active_admin_config method.
  #
  class Page

    # The namespace this config belongs to
    attr_reader :namespace

    # The name of the page
    attr_reader :name

    # An array of custom actions defined for this page
    attr_reader :page_actions
    
    # Set breadcrumb builder
    attr_accessor :breadcrumb

    module Base
      def initialize(namespace, name, options)
        @namespace = namespace
        @name = name
        @options = options
        @page_actions = []
      end
    end

    include Base
    include Resource::Controllers
    include Resource::PagePresenters
    include Resource::Sidebars
    include Resource::ActionItems
    include Resource::Menu
    include Resource::Naming
    include Resource::Routes

    # label is singular
    def plural_resource_label
      name
    end

    def resource_name
      @resource_name ||= Resource::Name.new(nil, name)
    end

    def underscored_resource_name
      resource_name.parameterize.underscore
    end

    def camelized_resource_name
      underscored_resource_name.camelize
    end

    def default_menu_options
      super.merge(:id => resource_name)
    end

    def controller_name
      [namespace.module_name, camelized_resource_name + "Controller"].compact.join('::')
    end

    # Override from `ActiveAdmin::Resource::Controllers`
    def route_uncountable?
      false
    end

    def belongs_to?
      false
    end

    def add_default_action_items
    end

    def add_default_sidebar_sections
    end
    
    # Clears all the custom actions this page knows about
    def clear_page_actions!
      @page_actions = []
    end

  end
end
module ActiveAdmin

  # All Pages controllers inherit from this controller.
  class PageController < BaseController

    # Active admin actions don't require layout.  All custom actions do.
    ACTIVE_ADMIN_ACTIONS = [:index]

    actions :index

    before_filter :authorize_access!

    def index(options={}, &block)
      render "active_admin/page/index"
    end

    def clear_page_actions!
      active_admin_config.clear_page_actions!
    end

    private

    def authorize_access!
      permission = action_to_permission(params[:action])
      authorize! permission, active_admin_config
    end

  end
end
module ActiveAdmin
  # This is the class where all the register_page blocks are instance eval'd
  class PageDSL < DSL

    # Page content.
    #
    # The block should define the view using Arbre.
    #
    # Example:
    #
    #   ActiveAdmin.register "My Page" do
    #     content do
    #       para "Sweet!"
    #     end
    #   end
    #
    def content(options = {}, &block)
      config.set_page_presenter :index, ActiveAdmin::PagePresenter.new(options, &block)
    end
    
    def page_action(name, options = {}, &block)
      config.page_actions << ControllerAction.new(name, options)
      controller do
        define_method(name, &block || Proc.new{})
      end
    end
  end
end
module ActiveAdmin

  # A simple object that gets used to present different aspects of views
  #
  # Initialize with a set of options and a block. The options become
  # available using hash style syntax.
  #
  # Usage:
  #
  #     presenter = PagePresenter.new :as => :table do
  #       # some awesome stuff
  #     end
  #
  #     presenter[:as]    #=> :table
  #     presenter.block   #=> The block passed in to new
  #
  class PagePresenter

    attr_reader :block, :options

    delegate :has_key?, :to => :options

    def initialize(options = {}, &block)
      @options, @block = options, block
    end

    def [](key)
      @options[key]
    end

  end
end
module ActiveAdmin

  module Reloader

    # Builds the proper Reloader implementation class given the
    # current version of Rails.
    #
    # @param [Rails::Application] rails_app The current rails application
    # @param [ActiveAdmin::Application] active_admin_app The current Active Admin app
    # @param [String] rails_version The version of Rails we're using. 
    #
    # @returns A concrete subclass of AbstractReloader
    def self.build(rails_app, active_admin_app, rails_version)
      reloader_class = rails_version[0..2] == "3.2" ? Rails32Reloader : RailsLessThan31Reloader
      reloader_class.new(rails_app, active_admin_app, rails_version)
    end

    class AbstractReloader

      attr_reader :active_admin_app, :rails_app, :rails_version

      def initialize(rails_app, active_admin_app, rails_version)
        @rails_app = rails_app
        @active_admin_app = active_admin_app
        @rails_version = rails_version.to_s
      end

      def attach!
        raise "Please implement #{self.class}#attach!"
      end

      def reload!
        active_admin_app.unload!
        rails_app.reload_routes!
      end

      def major_rails_version
        @rails_version[0..2]
      end

    end

    # Reloads the application when using Rails 3.2
    #
    # 3.2 introduced a to_prepare block that only gets called when
    # files have actually changed. ActiveAdmin had built this functionality
    # in to speed up applications. So in Rails >= 3.2, we can now piggy
    # back off the existing reloader. This simplifies our duties... which is
    # nice.
    class Rails32Reloader < AbstractReloader

      # Attach to Rails and perform the reload on each request.
      def attach!
        active_admin_app.load_paths.each do |path|
          rails_app.config.watchable_dirs[path] = [:rb]
        end

        reloader = self

        ActionDispatch::Reloader.to_prepare do
          reloader.reload!
        end
      end

    end

    # Deals with reloading Active Admin on each request in 
    # development and once in production in Rails < 3.2.
    class RailsLessThan31Reloader < AbstractReloader

      class FileUpdateChecker < ::ActiveSupport::FileUpdateChecker
        def paths
          # hack to support both Rails 3.1 and 3.2
          @files || @paths
        end

        # Over-ride the default #updated_at to support the deletion of files
        def updated_at
          paths.map { |path| File.mtime(path) rescue Time.now }.max
        end

        def execute_if_updated
          super
        end
      end

      attr_reader :file_update_checker

      def initialize(rails_app, active_admin_app, rails_version)
        super
        @file_update_checker = FileUpdateChecker.new(watched_paths) do
          reload!
        end
      end

      def reload!
        super
        file_update_checker.paths.clear
        watched_paths.each{|path| file_update_checker.paths << path }
      end


      # Attach to Rails and perform the reload on each request.
      def attach!
        # Bring the checker into local scope for the ruby block
        checker = file_update_checker

        reloader_class.to_prepare do
          checker.execute_if_updated
        end
      end

      def watched_paths
        paths = active_admin_app.load_paths
        active_admin_app.load_paths.each{|path| paths += Dir[File.join(path, "**", "*.rb")]}
        paths
      end

      def reloader_class
        if major_rails_version == "3.1"
          ActionDispatch::Reloader
        else
          ActionDispatch::Callbacks
        end
      end

    end

  end
end
require 'active_admin/helpers/optional_display'

module ActiveAdmin

  class Resource
    module ActionItems

      # Add the default action items to a resource when it's
      # initialized
      def initialize(*args)
        super
        add_default_action_items
      end

      # @return [Array] The set of action items for this resource
      def action_items
        @action_items ||= []
      end

      # Add a new action item to a resource
      #
      # @param [Hash] options valid keys include:
      #                 :only:  A single or array of controller actions to display
      #                         this action item on.
      #                 :except: A single or array of controller actions not to
      #                          display this action item on.
      def add_action_item(options = {}, &block)
        self.action_items << ActiveAdmin::ActionItem.new(options, &block)
      end

      # Returns a set of action items to display for a specific controller action
      #
      # @param [String, Symbol] action the action to retrieve action items for
      #
      # @return [Array] Array of ActionItems for the controller actions
      def action_items_for(action, render_context = nil)
        action_items.select{|item| item.display_on?(action, render_context) }
      end

      # Clears all the existing action items for this resource
      def clear_action_items!
        @action_items = []
      end

      # Used by active_admin Base view
      def action_items?
        !!@action_items && @action_items.any?
      end

      private

      # Adds the default action items to each resource
      def add_default_action_items
        # New Link on all actions except :new and :show
        add_action_item :except => [:new, :show] do
          if controller.action_methods.include?('new') && authorized?(ActiveAdmin::Auth::CREATE, active_admin_config.resource_class)
            link_to(I18n.t('active_admin.new_model', :model => active_admin_config.resource_label), new_resource_path)
          end
        end

        # Edit link on show
        add_action_item :only => :show do
          if controller.action_methods.include?('edit') && authorized?(ActiveAdmin::Auth::UPDATE, resource)
            link_to(I18n.t('active_admin.edit_model', :model => active_admin_config.resource_label), edit_resource_path(resource))
          end
        end

        # Destroy link on show
        add_action_item :only => :show do
          if controller.action_methods.include?("destroy") && authorized?(ActiveAdmin::Auth::DESTROY, resource)
            link_to(I18n.t('active_admin.delete_model', :model => active_admin_config.resource_label),
              resource_path(resource),
              :method => :delete, :data => {:confirm => I18n.t('active_admin.delete_confirmation')})
          end
        end
      end

    end
  end

  # Model class to store the data for ActionItems
  class ActionItem
    include ActiveAdmin::OptionalDisplay

    attr_accessor :block

    def initialize(options = {}, &block)
      @options, @block = options, block
      normalize_display_options!
    end
  end

end
require 'active_admin/resource'

module ActiveAdmin
  class Resource
    class BelongsTo

      class TargetNotFound < StandardError; end

      # The resource which initiated this relationship
      attr_reader :owner

      def initialize(owner_resource, target_name, options = {})
        @owner, @target_name = owner_resource, target_name
        @options = options
      end

      # Returns the target resource class or raises an exception if it doesn't exist
      def target
        namespace.resources.find_by_key(@target_name.to_s.camelize) or 
          raise TargetNotFound, "Could not find registered resource #{@target_name} in #{namespace.name} with #{namespace.resources.inspect}"
      end

      def namespace
        @owner.namespace
      end

      def optional?
        @options[:optional]
      end

    end
  end
end
module ActiveAdmin
  class Resource
    module Controllers

      # Returns a properly formatted controller name for this
      # config within its namespace
      def controller_name
        [namespace.module_name, resource_name.plural.camelize + "Controller"].compact.join('::')
      end

      # Returns the controller for this config
      def controller
        @controller ||= controller_name.constantize
      end

    end
  end
end
module ActiveAdmin
  class Resource

    module Menu

      # Set the menu options. To not add this resource to the menu, just
      # call #menu(false)
      def menu_item_options=(options)
        if options == false
          @navigation_menu = false
          @menu_item_options = {}
        else
          self.menu_item_menu_name = options[:menu_name]
          @menu_item_options = default_menu_options.merge(options)
        end
      end

      def menu_item_options
        @menu_item_options ||= default_menu_options
      end

      def default_menu_options
        # These local variables are accessible to the procs.
        menu_resource_class = respond_to?(:resource_class) ? resource_class : self
        resource = self
        {
          :id    => resource_name.plural,
          :label => proc{ resource.plural_resource_label },
          :url   => proc{ resource.route_collection_path(params) },
          :if    => proc{ authorized?(:read, menu_resource_class) }
        }
      end

      def navigation_menu_name=(menu_name)
        @navigation_menu_name = menu_name
      end

      def navigation_menu_name
        @navigation_menu_name ||= DEFAULT_MENU
        case @navigation_menu_name
        when Proc
          controller.instance_eval(&@navigation_menu_name).to_sym
        else
          @navigation_menu_name
        end
      end

      def navigation_menu
        namespace.fetch_menu(navigation_menu_name)
      end

      def menu_item_menu_name=(menu_name)
        @menu_item_menu_name = menu_name
      end

      def menu_item_menu_name
        @menu_item_menu_name ||= DEFAULT_MENU
      end

      def add_to_menu(menu_collection)
        if include_in_menu?
          @menu_item = menu_collection.add(menu_item_menu_name, menu_item_options)
        end
      end

      def menu_item
        @menu_item
      end

      # Should this resource be added to the menu system?
      def include_in_menu?
        @navigation_menu != false
      end

    end
  end
end
module ActiveAdmin
  class Resource

    module Naming

      # Returns a name used to uniquely identify this resource
      # this should be an instance of ActiveAdmin:Resource::Name, which responds to
      # #singular, #plural, #route_key, #human etc.
      def resource_name
        custom_name = @options[:as] && @options[:as].gsub(/\s/,'')
        @resource_name ||= if custom_name || !resource_class.respond_to?(:model_name)
            Resource::Name.new(resource_class, custom_name)
          else
            Resource::Name.new(resource_class)
          end
      end

      # Returns the name to call this resource such as "Bank Account"
      def resource_label
        resource_name.translate :count => 1,  :default => resource_name.gsub('::', ' ').titleize
      end

      # Returns the plural version of this resource such as "Bank Accounts"
      def plural_resource_label
        resource_name.translate :count => 1.1, :default => resource_label.pluralize.titleize
      end
    end

    # A subclass of ActiveModel::Name which supports the different APIs presented
    # in Rails < 3.1 and > 3.1.
    class Name < ActiveModel::Name

      def initialize(klass, name = nil)
        if ActiveModel::Name.instance_method(:initialize).arity == 1
          super(proxy_for_initializer(klass, name))
        else
          super(klass, nil, name)
        end
      end

      def translate(options = {})
        I18n.t i18n_key, {:scope => [:activerecord, :models]}.merge(options)
      end

      def proxy_for_initializer(klass, name)
        return klass unless name
        return StringClassProxy.new(klass, name) if klass

        StringProxy.new(name)
      end

      def route_key
        plural
      end

      class StringProxy
        def initialize(name)
          @name = name
        end

        def name
          @name
        end
      end

      class StringClassProxy < StringProxy
        delegate :lookup_ancestors, :i18n_scope, :to => :"@klass"

        def initialize(klass, name)
          @klass = klass || name
          super(name)
        end
      end

    end

  end
end
module ActiveAdmin
  class Resource
    module PagePresenters

      # for setting default css class in admin ui
      def default_index_class
        @default_index
      end

      # A hash of page configurations for the controller indexed by action name
      def page_presenters
        @page_presenters ||= {}
      end

      # Sets a page config for a given action
      #
      # @param [String, Symbol] action The action to store this configuration for
      # @param [PagePresenter] page_presenter The instance of PagePresenter to store
      def set_page_presenter(action, page_presenter)

        if action.to_s == "index" && page_presenter[:as]
          index_class = find_index_class(page_presenter[:as])
          page_presenter_key = index_class.index_name.to_sym
          set_index_presenter page_presenter_key, page_presenter
        else
          page_presenters[action.to_sym] = page_presenter
        end

      end

      # Returns a stored page config
      #
      # @param [Symbol, String] action The action to get the config for
      # @param [String] type The string specified in the presenters index_name method
      # @returns [PagePresenter, nil]
      def get_page_presenter(action, type=nil)
        
        if action.to_s == "index" && type && page_presenters[:index].kind_of?(Hash)
          page_presenters[:index][type.to_sym] 
        elsif action.to_s == "index" && page_presenters[:index].kind_of?(Hash)
          page_presenters[:index].default
        else
          page_presenters[action.to_sym]
        end

      end

      protected

      # Stores a config for all index actions supplied
      #
      # @param [Symbol] index_as The index type to store in the configuration
      # @param [PagePresenter] page_presenter The intance of PagePresenter to store
      def set_index_presenter(index_as, page_presenter)
        page_presenters[:index] ||= {}

        #set first index as default value or the index with default param set to to true
        if page_presenters[:index].empty? || page_presenter[:default] == true
          page_presenters[:index].default = page_presenter
          @default_index = find_index_class(page_presenter[:as])
        end

        page_presenters[:index][index_as] = page_presenter
      end

      # Returns the actual class for renderering the main content on the index
      # page. To set this, use the :as option in the page_presenter block.
      #
      # @param [Symbol, Class] symbol_or_class The component symbol or class
      # @return [Class]
      def find_index_class(symbol_or_class)
        case symbol_or_class
        when Symbol
          ::ActiveAdmin::Views.const_get("IndexAs" + symbol_or_class.to_s.camelcase)
        when Class
          symbol_or_class
        end
      end

    end
  end
end
module ActiveAdmin

  class Resource
    module Pagination

      # The default number of records to display per page
      attr_accessor :per_page

      # Enable / disable pagination (defaults to true)
      attr_accessor :paginate

      def initialize(*args)
        super
        @paginate = true
        @per_page = namespace.default_per_page
      end
    end
  end
end
module ActiveAdmin
  class Resource
    module Routes

      # Returns the routes prefix for this config
      def route_prefix
        namespace.module_name.try(:underscore)
      end

      def route_uncountable?
        controller.resources_configuration[:self][:route_collection_name] ==
              controller.resources_configuration[:self][:route_instance_name]
      end

      # Returns a symbol for the route to use to get to the
      # collection of this resource
      def route_collection_path(params = {})
        route, required_params = [], []

        route << route_prefix

        if belongs_to? && !belongs_to_config.optional?
          name = belongs_to_config.target.resource_name.singular
          route << name
          required_params << :"#{name}_id"
        end

        route << controller.resources_configuration[:self][:route_collection_name]

        route << (route_uncountable? ? 'index_path' : 'path')

        route_name = route.compact.join("_").to_sym

        route_params = params.values_at(*required_params)
        routes.send(route_name, *route_params)
      end

      private

      def routes
        Rails.application.routes.url_helpers
      end

    end
  end
end
module ActiveAdmin
  class Resource
    module Scopes

      # Return an array of scopes for this resource
      def scopes
        @scopes ||= []
      end

      # Returns a scope for this object by its identifier
      def get_scope_by_id(id)
        id = id.to_s
        scopes.find{|s| s.id == id }
      end

      def default_scope
        @default_scope
      end

      # Create a new scope object for this resource.
      # If you want to internationalize the scope name, you can add
      # to your i18n files a key like "active_admin.scopes.scope_method".
      def scope(*args, &block)
        options = args.extract_options!
        title = args[0] rescue nil
        method = args[1] rescue nil

        scope = ActiveAdmin::Scope.new(title, method, options, &block)

        # Finds and replaces a scope by the same name if it already exists
        existing_scope_index = scopes.index{|existing_scope| existing_scope.id == scope.id }
        if existing_scope_index
          scopes.delete_at(existing_scope_index)
          scopes.insert(existing_scope_index, scope)
        else
          self.scopes << scope
        end

        @default_scope = scope if options[:default]

        scope
      end

    end
  end
end
require 'active_admin/helpers/optional_display'

module ActiveAdmin

  class Resource
    module Sidebars

      def sidebar_sections
        @sidebar_sections ||= []
      end

      def clear_sidebar_sections!
        @sidebar_sections = []
      end

      def sidebar_sections_for(action, render_context = nil)
        sidebar_sections.select{|section| section.display_on?(action, render_context) }
      end

      def sidebar_sections?
        !!@sidebar_sections && @sidebar_sections.any?
      end

    end
  end

end
require 'active_admin/resource/action_items'
require 'active_admin/resource/controllers'
require 'active_admin/resource/menu'
require 'active_admin/resource/page_presenters'
require 'active_admin/resource/pagination'
require 'active_admin/resource/routes'
require 'active_admin/resource/naming'
require 'active_admin/resource/scopes'
require 'active_admin/resource/sidebars'
require 'active_admin/resource/belongs_to'

module ActiveAdmin

  # Resource is the primary data storage for resource configuration in Active Admin
  #
  # When you register a resource (ActiveAdmin.register Post) you are actually creating
  # a new Resource instance within the given Namespace.
  #
  # The instance of the current resource is available in ResourceController and views
  # by calling the #active_admin_config method.
  #
  class Resource

    # Event dispatched when a new resource is registered
    RegisterEvent = 'active_admin.resource.register'.freeze

    # The namespace this config belongs to
    attr_reader :namespace

    # The name of the resource class
    attr_reader :resource_class_name

    # An array of member actions defined for this resource
    attr_reader :member_actions

    # An array of collection actions defined for this resource
    attr_reader :collection_actions

    # The default sort order to use in the controller
    attr_accessor :sort_order

    # Scope this resource to an association in the controller
    attr_accessor :scope_to

    # If we're scoping resources, use this method on the parent to return the collection
    attr_accessor :scope_to_association_method

    # Set the configuration for the CSV
    attr_writer :csv_builder
    
    # Set breadcrumb builder
    attr_accessor :breadcrumb

    # Store a reference to the DSL so that we can dereference it during garbage collection.
    attr_accessor :dsl

    # The string identifying a class to decorate our resource with for the view.
    # nil to not decorate.
    attr_accessor :decorator_class_name

    module Base
      def initialize(namespace, resource_class, options = {})
        @namespace = namespace
        @resource_class_name = "::#{resource_class.name}"
        @options = default_options.merge(options)
        @sort_order = @options[:sort_order]
        @member_actions, @collection_actions = [], []
      end
    end

    include Base
    include ActionItems
    include Authorization
    include Controllers
    include Menu
    include Naming
    include PagePresenters
    include Pagination
    include Scopes
    include Sidebars
    include Menu
    include Routes

    # The class this resource wraps. If you register the Post model, Resource#resource_class
    # will point to the Post class
    def resource_class
      ActiveSupport::Dependencies.constantize(resource_class_name)
    end

    def decorator_class
      ActiveSupport::Dependencies.constantize(decorator_class_name) if decorator_class_name
    end

    def resource_table_name
      resource_class.quoted_table_name
    end

    def resource_column_names
      resource_class.column_names
    end

    def resource_quoted_column_name(column)
      resource_class.connection.quote_column_name(column)
    end

    # Returns the named route for an instance of this resource
    def route_instance_path
      [route_prefix, controller.resources_configuration[:self][:route_instance_name], 'path'].compact.join('_').to_sym
    end

    # Clears all the member actions this resource knows about
    def clear_member_actions!
      @member_actions = []
    end

    def clear_collection_actions!
      @collection_actions = []
    end

    # Return only defined resource actions
    def defined_actions
      controller.instance_methods.map { |m| m.to_sym } & ResourceController::ACTIVE_ADMIN_ACTIONS
    end

    # Are admin notes turned on for this resource
    def admin_notes?
      admin_notes.nil? ? ActiveAdmin.admin_notes : admin_notes
    end

    def belongs_to(target, options = {})
      @belongs_to = Resource::BelongsTo.new(self, target, options)
      self.menu_item_menu_name = target unless @belongs_to.optional?
      controller.belongs_to(target, options.dup)
    end

    def belongs_to_config
      @belongs_to
    end

    # Do we belong to another resource
    def belongs_to?
      !belongs_to_config.nil?
    end

    # The csv builder for this resource
    def csv_builder
      @csv_builder || default_csv_builder
    end

    # @deprecated
    def resource
      resource_class
    end
    ActiveAdmin::Deprecation.deprecate self, :resource,
      "ActiveAdmin::Resource#resource is deprecated. Please use #resource_class instead."

    private

    def default_options
      {
        :sort_order => "#{resource_class.respond_to?(:primary_key) ? resource_class.primary_key : 'id'}_desc"
      }
    end

    def default_csv_builder
      @default_csv_builder ||= CSVBuilder.default_for_resource(resource_class)
    end

  end # class Resource
end # module ActiveAdmin
module ActiveAdmin

  class ResourceMismatchError < StandardError; end

  # Holds on to a collection of Resources. Is an Enumerable object
  # so it has some Array like qualities.
  #
  # Adding a resource assumes that the object responds to #resource_name
  class ResourceCollection
    include Enumerable

    def initialize
      @resource_hash = {}
    end

    # Add a new resource to the collection. If the resource_name already
    # exists, the exiting resource is returned.
    #
    # @param [Resource, Page] resource The resource to add to the collection
    #
    # @returns [Resource, Page] Either the existing resource or the new one
    def add(resource)
      if has_key?(resource.resource_name)
        existing_resource = find_by_key(resource.resource_name)
        ensure_resource_classes_match!(existing_resource, resource)
        existing_resource
      else
        @resource_hash[resource.resource_name] = resource
      end
    end

    # @returns [Array] An array of all the resources
    def resources
      @resource_hash.values
    end

    # For enumerable
    def each(&block)
      @resource_hash.values.each(&block)
    end

    # @returns [Array] An array of all the keys registered in the collection
    def keys
      @resource_hash.keys
    end

    # @returns [Boolean] If the key has been registered in the collection
    def has_key?(resource_name)
      @resource_hash.has_key?(resource_name)
    end

    # Finds a resource by a given key
    def find_by_key(resource_name)
      @resource_hash[resource_name]
    end

    # Finds a resource based on it's class. Looks up the class Heirarchy if its
    # a subclass of an Active Record class (ie: implementes base_class)
    def find_by_resource_class(resource_class)
      resource_class_name = resource_class.to_s
      match = resources_with_a_resource_class.find{|r| r.resource_class.to_s == resource_class_name }
      return match if match

      if resource_class.respond_to?(:base_class)
        base_class_name = resource_class.base_class.to_s
        resources_with_a_resource_class.find{|r| r.resource_class.to_s == base_class_name }
      else
        nil
      end
    end

    private

    def resources_with_a_resource_class
      select{|resource| resource.respond_to?(:resource_class) }
    end

    def ensure_resource_classes_match!(existing_resource, resource)
      return unless existing_resource.respond_to?(:resource_class) && resource.respond_to?(:resource_class)

      if existing_resource.resource_class != resource.resource_class
        raise ActiveAdmin::ResourceMismatchError, 
          "Tried to register #{resource.resource_class} as #{resource.resource_name} but already registered to #{existing_resource.resource_class}"
      end
    end

  end
end
module ActiveAdmin
  class ResourceController < BaseController

    module ActionBuilder
      extend ActiveSupport::Concern

      module ClassMethods

        def clear_member_actions!
          active_admin_config.clear_member_actions!
        end

        def clear_collection_actions!
          active_admin_config.clear_collection_actions!
        end
      end

    end

  end
end
module ActiveAdmin
  class ResourceController < BaseController

    # Override the InheritedResources actions to use the
    # Active Admin templates.
    #
    # We ensure that the functionality provided by Inherited
    # Resources is still available within any ResourceController

    def index(options={}, &block)
      super(options) do |format|
        block.call(format) if block
        format.html { render active_admin_template('index') }
        format.csv do
          headers['Content-Type'] = 'text/csv; charset=utf-8'
          headers['Content-Disposition'] = %{attachment; filename="#{csv_filename}"}
          render active_admin_template('index')
        end
      end
    end
    alias :index! :index

    def show(options={}, &block)
      super do |format|
        block.call(format) if block
        format.html { render active_admin_template('show') }
      end
    end
    alias :show! :show

    def new(options={}, &block)
      super do |format|
        block.call(format) if block
        format.html { render active_admin_template('new') }
      end
    end
    alias :new! :new

    def edit(options={}, &block)
      super do |format|
        block.call(format) if block
        format.html { render active_admin_template('edit') }
      end
    end
    alias :edit! :edit

    def create(options={}, &block)
      super(options) do |success, failure|
        block.call(success, failure) if block
        failure.html { render active_admin_template('new') }
      end
    end
    alias :create! :create

    def update(options={}, &block)
      super do |success, failure|
        block.call(success, failure) if block
        failure.html { render active_admin_template('edit') }
      end
    end
    alias :update! :update


    # Make aliases protected
    protected :index!, :show!, :new!, :create!, :edit!, :update!

    protected

    # Returns the full location to the Active Admin template path
    def active_admin_template(template)
      "active_admin/resource/#{template}"
    end

    # Returns a filename for the csv file using the collection_name
    # and current date such as 'my-articles-2011-06-24.csv'.
    def csv_filename
      "#{resource_collection_name.to_s.gsub('_', '-')}-#{Time.now.strftime("%Y-%m-%d")}.csv"
    end

  end
end
module ActiveAdmin
  class ResourceController < BaseController

    # This module overrides most of the data access methods in Inherited
    # Resources to provide Active Admin with it's data.
    #
    # The module also deals with authorization and resource callbacks.
    #
    module DataAccess
      extend ActiveSupport::Concern

      include ActiveAdmin::Callbacks
      include ActiveAdmin::ScopeChain

      included do
        define_active_admin_callbacks :build, :create, :update, :save, :destroy
      end

      protected

      # Retrieve, memoize and authorize the current collection from the db. This
      # method delegates the finding of the collection to #find_collection.
      #
      # Once #collection has been called, the collection is available using 
      # either the @collection instance variable or an instance variable named 
      # after the resource that the collection is for. eg: Post => @post.
      #
      # @returns [ActiveRecord::Relation] The collection for the index
      def collection
        _collection = get_collection_ivar

        return _collection if _collection

        _collection = find_collection
        authorize! ActiveAdmin::Authorization::READ, active_admin_config.resource_class

        set_collection_ivar _collection
      end


      # Does the actual work of retrieving the current collection from the db. 
      # This is a great method to override if you would like to perform 
      # some additional db # work before your controller returns and 
      # authorizes the collection.
      #
      # @returns [ActiveRecord::Relation] The collectin for the index
      def find_collection
        collection = scoped_collection

        collection = apply_sorting(collection)
        collection = apply_filtering(collection)
        collection = apply_scoping(collection)
        collection = apply_pagination(collection)
        collection = apply_decorator(collection)

        collection
      end


      # Override this method in your controllers to modify the start point
      # of our searches and index.
      #
      # This method should return an ActiveRecord::Relation object so that
      # the searching and filtering can be applied on top
      #
      # Note, unless you are doing something special, you should use the
      # scope_to method from the Scoping module instead of overriding this
      # method.
      def scoped_collection
        scope_for_authorization end_of_association_chain
      end

      # Retrieve, memoize and authorize a resource based on params[:id]. The 
      # actual work of finding the resource is done in #find_resource.
      #
      # This method is used on all the member actions:
      #
      #   * show
      #   * edit
      #   * update
      #   * destroy
      #
      # @returns [ActiveRecord::Base] An active record object
      def resource
        _resource = get_resource_ivar

        return _resource if _resource

        _resource = find_resource
        authorize_resource! _resource

        if decorator?
          _resource = decorator_class.new(_resource)
        end

        set_resource_ivar(_resource)
      end

      def decorator?
        !!active_admin_config.decorator_class
      end

      def decorator_class
        active_admin_config.decorator_class
      end


      # Does the actual work of finding a resource in the database. This 
      # method uses the finder method as defined in InheritedResources.
      #
      # @returns [ActiveRecord::Base] An active record object.
      def find_resource
        scoped_collection.send(method_for_find, params[:id])
      end


      # Builds, memoize and authorize a new instance of the resource. The 
      # actual work of building the new instance is delegated to the 
      # #build_new_resource method.
      #
      # This method is used to instantiate and authorize new resources in the
      # new and create controller actions.
      #
      # @returns [ActiveRecord::Base] An un-saved active record base object
      def build_resource
        return resource if resource = get_resource_ivar

        resource = build_new_resource

        run_build_callbacks resource
        authorize_resource! resource

        set_resource_ivar(resource)
      end

      # Builds a new resource. This method uses the method_for_build provided
      # by Inherited Resources.
      #
      # @returns [ActiveRecord::Base] An un-saved active record base object
      def build_new_resource
        scoped_collection.send(method_for_build, *resource_params)
      end

      # Calls all the appropriate callbacks and then creates the new resource.
      #
      # @param [ActiveRecord::Base] object The new resource to create
      #
      # @returns [void]
      def create_resource(object)
        run_create_callbacks object do
          save_resource(object)
        end
      end

      # Calls all the appropriate callbacks and then saves the new resource.
      #
      # @param [ActiveRecord::Base] object The new resource to save
      #
      # @returns [void]
      def save_resource(object)
        run_save_callbacks object do
          object.save
        end
      end

      # Update an object with the given attributes. Also calls the appropriate
      # callbacks for update action.
      #
      # @param [ActiveRecord::Base] object The instance to update
      #
      # @param [Array] attributes An array with the attributes in the first position
      #                           and the Active Record "role" in the second. The role
      #                           may be set to nil.
      #
      # @returns [void]
      def update_resource(object, attributes)
        if object.respond_to?(:assign_attributes)
          object.assign_attributes(*attributes)
        else
          object.attributes = attributes[0]
        end

        run_update_callbacks object do
          save_resource(object)
        end
      end

      # Destroys an object from the database and calls appropriate callbacks.
      #
      # @returns [void]
      def destroy_resource(object)
        run_destroy_callbacks object do
          object.destroy
        end
      end


      #
      # Collection Helper Methods
      #


      # Gives the authorization library a change to pre-scope the collection.
      #
      # In the case of the CanCan adapter, it calls `#accessible_by` on 
      # the collection.
      #
      # @param [ActiveRecord::Relation] collection The collection to scope
      #
      # @retruns [ActiveRecord::Relation] a scoped collection of query
      def scope_for_authorization(collection)
        active_admin_authorization.scope_collection(collection)
      end


      def apply_sorting(chain)
        params[:order] ||= active_admin_config.sort_order
        if params[:order] && params[:order] =~ /^([\w\_\.]+)_(desc|asc)$/
          column = $1
          order  = $2
          table  = active_admin_config.resource_column_names.include?(column) ? active_admin_config.resource_table_name : nil
          table_column = (column =~ /\./) ? column :
            [table, active_admin_config.resource_quoted_column_name(column)].compact.join(".")

          chain.reorder("#{table_column} #{order}")
        else
          chain # just return the chain
        end
      end

      def apply_filtering(chain)
        @search = chain.metasearch(clean_search_params(params[:q]))
        @search.relation
      end

      def clean_search_params(search_params)
        return {} unless search_params.is_a?(Hash)
        search_params = search_params.dup
        search_params.delete_if do |key, value|
          value == ""
        end
        search_params
      end

      def apply_scoping(chain)
        @collection_before_scope = chain

        if current_scope
          scope_chain(current_scope, chain)
        else
          chain
        end
      end

      def collection_before_scope
        @collection_before_scope
      end

      def current_scope
        @current_scope ||= if params[:scope]
          active_admin_config.get_scope_by_id(params[:scope]) if params[:scope]
        else
          active_admin_config.default_scope
        end
      end

      def apply_pagination(chain)
        page_method_name = Kaminari.config.page_method_name
        page = params[Kaminari.config.param_name]

        chain.send(page_method_name, page).per(per_page)
      end

      def per_page
        return max_csv_records if request.format == 'text/csv'
        return max_per_page if active_admin_config.paginate == false

        @per_page || active_admin_config.per_page
      end

      def max_csv_records
        10_000
      end

      def max_per_page
        10_000
      end

      def apply_decorator(chain)
        if decorator?
          decorator_class.decorate_collection(chain)
        else
          chain
        end
      end

    end
  end
end
module ActiveAdmin
  class ResourceController < BaseController
    module Decorators
      protected

      def resource
        decorator = active_admin_config.decorator_class
        resource = super
        decorator ? decorator.new(resource) : resource
      end

      def active_admin_collection
        decorator = active_admin_config.decorator_class
        collection = super
        decorator ? decorator.decorate_collection(collection) : collection
      end

    end
  end
end
module ActiveAdmin
  class ResourceController < BaseController
    module ResourceClassMethods

      # Override the default resource_class class and instance
      # methods to only return the class defined in the instance
      # of ActiveAdmin::Resource
      def override_resource_class_methods!
        self.class_eval do
          def self.resource_class=(klass); end

          def self.resource_class
            @active_admin_config ? @active_admin_config.resource_class : nil
          end

          def resource_class
            self.class.resource_class
          end
        end
      end

    end
  end
end
module ActiveAdmin
  class ResourceController < BaseController

    # This module deals with scoping entire controllers to a relation
    module Scoping
      extend ActiveSupport::Concern

      protected

      # Override the default InheritedResource #begin_of_association_chain to allow
      # the scope to be defined in the active admin configuration.
      #
      # If scope_to is a proc, we eval it, otherwise we call the method on the controller.
      def begin_of_association_chain
        return nil unless active_admin_config.scope_to
        case active_admin_config.scope_to
        when Proc
          instance_eval &active_admin_config.scope_to
        when Symbol
          send active_admin_config.scope_to
        else
          raise ArgumentError, "#scope_to accepts a symbol or a block"
        end
      end

      # Overriding from InheritedResources::BaseHelpers
      #
      # Returns the method for the association chain when using
      # the scope_to option
      def method_for_association_chain
        active_admin_config.scope_to_association_method || super
      end

    end
  end
end
module ActiveAdmin
  class ResourceController < BaseController

    module Sidebars

      protected

      def skip_sidebar!
        @skip_sidebar = true
      end

      def skip_sidebar?
        @skip_sidebar == true
      end
    end

  end
end
require 'inherited_resources'
require 'active_admin/resource_controller/actions'
require 'active_admin/resource_controller/action_builder'
require 'active_admin/resource_controller/data_access'
require 'active_admin/resource_controller/decorators'
require 'active_admin/resource_controller/scoping'
require 'active_admin/resource_controller/sidebars'
require 'active_admin/resource_controller/resource_class_methods'

module ActiveAdmin
  # All Resources Controller inherits from this controller.
  # It implements actions and helpers for resources.
  class ResourceController < BaseController
    layout :determine_active_admin_layout

    respond_to :html, :xml, :json
    respond_to :csv, :only => :index

    include Actions
    include ActionBuilder
    include Decorators
    include DataAccess
    include Scoping
    include Sidebars
    extend  ResourceClassMethods

    class << self
      def active_admin_config=(config)
        @active_admin_config = config

        unless config.nil?
          defaults :resource_class => config.resource_class, :route_prefix => config.route_prefix, :instance_name => config.resource_name.singular
        end
      end

      # Inherited Resources uses the inherited(base) hook method to
      # add in the Base.resource_class class method. To override it, we
      # need to install our resource_class method each time we're inherited from.
      def inherited(base)
        super(base)
        base.override_resource_class_methods!
      end

      public :belongs_to
    end

    private

    # Returns the renderer class to use for the given action.
    def renderer_for(action)
      active_admin_namespace.view_factory["#{action}_page"]
    end
    helper_method :renderer_for

  end
end
module ActiveAdmin
  # This is the class where all the register blocks are instance eval'd
  class ResourceDSL < DSL
    private

    def belongs_to(target, options = {})
      config.belongs_to(target, options)
    end

    # Scope this controller to some object which has a relation
    # to the resource. Can either accept a block or a symbol 
    # of a method to call.
    #
    # Eg:
    #
    #   ActiveAdmin.register Post do
    #     scope_to :current_user
    #   end
    #
    # Then every time we instantiate and object, it would call
    #
    #   current_user.posts.build
    #
    # By default Active Admin will use the resource name to build a
    # method to call as the association. If its different, you can 
    # pass in the association_method as an option.
    #
    #   scope_to :current_user, :association_method => :blog_posts
    #
    # will result in the following
    #
    #   current_user.blog_posts.build
    #
    def scope_to(*args, &block)
      options = args.extract_options!
      method = args.first

      config.scope_to = block_given? ? block : method
      config.scope_to_association_method = options[:association_method]
    end

    # Create a scope
    def scope(*args, &block)
      config.scope(*args, &block)
    end

    # Configure the index page for the resource
    def index(options = {}, &block)
      options[:as] ||= :table
      config.set_page_presenter :index, ActiveAdmin::PagePresenter.new(options, &block)
    end
    
    # Configure the show page for the resource
    def show(options = {}, &block)
      config.set_page_presenter :show, ActiveAdmin::PagePresenter.new(options, &block)
    end

    def form(options = {}, &block)
      config.set_page_presenter :form, ActiveAdmin::PagePresenter.new(options, &block)
    end

    # Configure the CSV format
    #
    # For example:
    #
    #   csv do
    #     column :name
    #     column("Author") { |post| post.author.full_name }
    #   end
    #
    #   csv :separator => ";", :options => { :force_quotes => true } do
    #     column :name
    #   end
    #
    def csv(options={}, &block)
      config.csv_builder = CSVBuilder.new(options, &block)
    end

    # Member Actions give you the functionality of defining both the
    # action and the route directly from your ActiveAdmin registration
    # block.
    #
    # For example:
    #
    #   ActiveAdmin.register Post do
    #     member_action :comments do
    #       @post = Post.find(params[:id]
    #       @comments = @post.comments
    #     end
    #   end
    #
    # Will create a new controller action comments and will hook it up to
    # the named route (comments_admin_post_path) /admin/posts/:id/comments
    #
    # You can treat everything within the block as a standard Rails controller
    # action.
    #
    def action(set, name, options = {}, &block)
      set << ControllerAction.new(name, options)
      title = options.delete(:title)

      controller do
        before_filter(:only => [name]) { @page_title = title } if title
        define_method(name, &block || Proc.new{})
      end
    end

    def member_action(name, options = {}, &block)
      action config.member_actions, name, options, &block
    end

    def collection_action(name, options = {}, &block)
      action config.collection_actions, name, options, &block
    end

    # Defined Callbacks
    #
    # == After Build
    # Called after the resource is built in the new and create actions.
    #
    # ActiveAdmin.register Post do
    #   after_build do |post|
    #     post.author = current_user
    #   end
    # end
    #
    # == Before / After Create
    # Called before and after a resource is saved to the db on the create action.
    #
    # == Before / After Update
    # Called before and after a resource is saved to the db on the update action.
    #
    # == Before / After Save
    # Called before and after the object is saved in the create and update action.
    # Note: Gets called after the create and update callbacks
    #
    # == Before / After Destroy
    # Called before and after the object is destroyed from the database.
    #
    delegate :before_build,   :after_build,   :to => :controller
    delegate :before_create,  :after_create,  :to => :controller
    delegate :before_update,  :after_update,  :to => :controller
    delegate :before_save,    :after_save,    :to => :controller
    delegate :before_destroy, :after_destroy, :to => :controller

    # Standard rails filters
    delegate :before_filter, :skip_before_filter, :after_filter, :around_filter, :to => :controller

    # Specify which actions to create in the controller
    #
    # Eg:
    #
    #   ActiveAdmin.register Post do
    #     actions :index, :show
    #   end
    #
    # Will only create the index and show actions (no create, update or delete)
    delegate :actions, :to => :controller

  end
end
module ActiveAdmin
  class Router
    def initialize(application)
      @application = application
    end

    # Creates all the necessary routes for the ActiveAdmin configurations
    #
    # Use this within the routes.rb file:
    #
    #   Application.routes.draw do |map|
    #     ActiveAdmin.routes(self)
    #   end
    #
    def apply(router)
      define_basic_routes router
      define_resource_routes router
    end

    # Define any necessary dashboard routes and root
    def define_basic_routes(router)
      router.instance_exec(@application.namespaces.values, self) do |namespaces, aa_router|
        namespaces.each do |namespace|
          if namespace.root?
            instance_eval &aa_router.root_and_dashboard_routes(namespace)
          else
            namespace(namespace.name) do
              instance_eval &aa_router.root_and_dashboard_routes(namespace)
            end
          end
        end
      end
    end

    def root_and_dashboard_routes(namespace)
      Proc.new do
        root :to => (namespace.root_to || "dashboard#index")
        if ActiveAdmin::Dashboards.built?
          match '/dashboard' => 'dashboard#index', :as => 'dashboard'
        end
      end
    end

    # Define the routes for each resource
    def define_resource_routes(router)
      resource_routes = method(:resource_routes)

      router.instance_exec(@application.namespaces, self) do |namespaces, aa_router|
        resources = namespaces.values.collect{|n| n.resources.resources }.flatten
        resources.each do |config|
          route_definition_block = aa_router.resource_routes(config)

          # Add in the parent if it exists
          if config.belongs_to?
            routes_for_belongs_to = route_definition_block.dup
            route_definition_block = Proc.new do
              # If its optional, make the normal resource routes
              instance_eval &routes_for_belongs_to if config.belongs_to_config.optional?

              # Make the nested belongs_to routes
              # :only is set to nothing so that we don't clobber any existing routes on the resource
              resources config.belongs_to_config.target.resource_name.plural, :only => [] do
                instance_eval &routes_for_belongs_to
              end
            end
          end

          # Add on the namespace if required
          unless config.namespace.root?
            routes_in_namespace = route_definition_block.dup
            route_definition_block = Proc.new do
              namespace config.namespace.name do
                instance_eval(&routes_in_namespace)
              end
            end
          end

          instance_eval &route_definition_block
        end
      end
    end

    def resource_routes(config)
      Proc.new do
        case config
        when Resource
          resources config.resource_name.route_key, :only => config.defined_actions do
            # Define any member actions
            member do
              config.member_actions.each do |action|
                [*action.http_verb].each do |http_verb|
                  # eg: get :comment
                  send(http_verb, action.name)
                end
              end
            end

            # Define any collection actions
            collection do
              config.collection_actions.each do |action|
                send(action.http_verb, action.name)
              end

              post :batch_action
            end
          end
        when Page
          match "/#{config.underscored_resource_name}" => "#{config.underscored_resource_name}#index"
          config.page_actions.each do |action|
            match "/#{config.underscored_resource_name}/#{action.name}" => "#{config.underscored_resource_name}##{action.name}", :via => action.http_verb
          end
        else
          raise "Unsupported config class: #{config.class}"
        end
      end

    end
  end
end
require 'sass/importers'

# This monkey patches the SASS filesystem importer to work with files
# that are named *.css.scss. This allows us to be compatible with both
# Rails 3.0.* and Rails 3.1
#
# This should only be loaded in Rails 3.0 apps.
class Sass::Importers::Filesystem

  # We want to ensure that all *.css.scss files are loaded as scss files
  def extensions_with_css
    extensions_without_css.merge('{css.,}scss' => :scss)
  end
  alias_method_chain :extensions, :css

end
require 'sass'
require 'sass/script/functions'
require 'sass-rails' if ActiveAdmin::DependencyChecker.rails_3_1?

module ActiveAdmin
  module Sass
    module Helpers

      if ActiveAdmin::DependencyChecker.rails_3_1?
        include ::Sass::Rails::Helpers
      end

      # Provides a helper in SASS to ensure that the paths to image
      # assets are always correct across Rails versions.
      #
      # Example:
      #
      #   background: url(active_admin_image_path('some_image.png')) 0 0 repeat-x;
      #
      # Will result in:
      #
      #   background: url("/images/active_admin/some_image.png") 0 0 repeat-x;
      #
      # Or in Rails 3.1 with asset pipeline enebaled:
      #
      #   background: url("/assets/active_admin/some_image.png") 0 0 repeat-x;
      #
      # @param [Sass::Script::String] asset the path to the image after */active_admin/
      #
      # @return [Sass::Script::String] path to the image
      #
      def active_admin_image_path(asset)
        if ActiveAdmin.use_asset_pipeline?
          asset_path(::Sass::Script::String.new("active_admin/#{asset.value}"), ::Sass::Script::String.new('image'))
        else
          ::Sass::Script::String.new("/images/active_admin/#{asset.value}", true)
        end
      end

    end
  end
end

# Install for use in Sass
Sass::Script::Functions.send :include, ActiveAdmin::Sass::Helpers
module ActiveAdmin
  class Scope

    attr_reader :scope_method, :id, :scope_block, :display_if_block, :show_count

    # Create a Scope
    #
    # Examples:
    #
    #   Scope.new(:published)
    #   # => Scope with name 'Published' and scope method :published
    #
    #   Scope.new('Published', :public)
    #   # => Scope with name 'Published' and scope method :public
    #
    #   Scope.new 'Published', :public, :if => proc { current_admin_user.can? :manage, resource_class } do |articles| 
    #     articles.where :published => true
    #   end
    #   # => Scope with name 'Published' and scope method :public, optionally displaying the scope per the :if block
    #
    #   Scope.new('Published') { |articles| articles.where(:published => true) }
    #   # => Scope with name 'Published' using a block to scope
    #
    #   Scope.new ->{Date.today.strftime '%A'}, :published_today
    #   # => Scope with dynamic title using the :published_today scope method
    #
    def initialize(name, method = nil, options = {}, &block)
      @name, @scope_method = name, method.try(:to_sym)

      if name.is_a? Proc
        raise "A string/symbol is required as the second argument if your label is a proc." unless method
        @id = method.to_s.gsub(' ', '').underscore
      else
        @scope_method ||= name.to_sym
        @id = name.to_s.gsub(' ', '').underscore
      end

      @scope_method               = nil        if @scope_method == :all
      @scope_method, @scope_block = nil, block if block_given?

      @show_count       = options[:show_count].nil? ? true : options[:show_count]
      @display_if_block = options[:if] || proc{ true }
    end

    def name
      case @name
        when Proc   then @name.call.to_s
        when String then @name
        when Symbol then @name.to_s.titleize
        else             @name.to_s
      end
    end

  end
end
module ActiveAdmin

  class SidebarSection
    include ActiveAdmin::OptionalDisplay

    attr_accessor :name, :options, :block

    def initialize(name, options = {}, &block)
      @name, @options, @block = name, options, block
      normalize_display_options!
    end

    # The id gets used for the div in the view
    def id
      "#{name.to_s.downcase.underscore}_sidebar_section".parameterize
    end

    def icon?
      options[:icon]
    end

    def icon
      options[:icon] if icon?
    end

    # The title gets displayed within the section in the view
    def title
      I18n.t("active_admin.sidebars.#{name.to_s}", :default => name.to_s.titlecase)
    end

    # If a block is not passed in, the name of the partial to render
    def partial_name
      options[:partial] || "#{name.to_s.downcase.gsub(' ', '_')}_sidebar"
    end
  end

end
module ActiveAdmin
  VERSION = '0.6.0'
end
require 'active_admin/abstract_view_factory'

module ActiveAdmin
  class ViewFactory < AbstractViewFactory

    # Register Helper Renderers
    register  :global_navigation    => ActiveAdmin::Views::TabbedNavigation,
              :site_title           => ActiveAdmin::Views::SiteTitle,
              :action_items         => ActiveAdmin::Views::ActionItems,
              :title_bar            => ActiveAdmin::Views::TitleBar,
              :header               => ActiveAdmin::Views::Header,
              :footer               => ActiveAdmin::Views::Footer,
              :dashboard_section    => ActiveAdmin::Views::DashboardSection,
              :index_scopes         => ActiveAdmin::Views::Scopes,
              :blank_slate          => ActiveAdmin::Views::BlankSlate,
              :action_list_popover  => ActiveAdmin::Views::ActionListPopover

    # Register All The Pages
    register  :dashboard_page     	=> ActiveAdmin::Views::Pages::Dashboard,
              :index_page         	=> ActiveAdmin::Views::Pages::Index,
              :show_page          	=> ActiveAdmin::Views::Pages::Show,
              :new_page           	=> ActiveAdmin::Views::Pages::Form,
              :edit_page          	=> ActiveAdmin::Views::Pages::Form,
              :layout             	=> ActiveAdmin::Views::Pages::Layout,
              :page               	=> ActiveAdmin::Views::Pages::Page

  end
end
module ActiveAdmin
  module ViewHelpers
    module ActiveAdminApplicationHelper

      # Returns the current Active Admin application instance
      def active_admin_application
        ActiveAdmin.application
      end

    end
  end
end
module AssignsWithIndifferentAccessHelper

  def assigns
    @assigns_with_indifferent_access_helper ||= HashWithIndifferentAccess.new(super)
  end

end
module ActiveAdmin
  module ViewHelpers
    module AutoLinkHelper

      # Automatically links objects to their resource controllers. If
      # the resource has not been registered, a string representation of
      # the object is returned.
      #
      # The default content in the link is returned from ActiveAdmin::ViewHelpers::DisplayHelper#display_name
      #
      # You can pass in the content to display
      #   eg: auto_link(@post, "My Link Content")
      #
      def auto_link(resource, link_content = nil)
        content = link_content || display_name(resource)
        if (registration = active_admin_resource_for(resource.class))
          begin
            content = link_to(content, send(registration.route_instance_path, resource))
          rescue
            # ignored
          end
        end
        content
      end

      # Returns the ActiveAdmin::Resource instance for a class
      def active_admin_resource_for(klass)
        return nil unless respond_to?(:active_admin_namespace)
        active_admin_namespace.resource_for(klass)
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module BreadcrumbHelper

      # Returns an array of links to use in a breadcrumb
      def breadcrumb_links(path = request.path)
        parts = path[1..-1].split('/')                        # remove leading "/" and split up URL path
        parts.pop unless params[:action] =~ /^create|update$/ # remove last if not create/update

        parts.each_with_index.map do |part, index|
          # If an object (users/23), look it up via ActiveRecord and capture its name.
          # If name is nil, look up the model translation, using `titlecase` as the backup.
          if part =~ /^\d|^[a-f0-9]{24}$/ && parent = parts[index-1]
            klass = parent.singularize.camelcase.constantize rescue nil
            obj   = klass.find_by_id(part) if klass
            name  = display_name(obj)      if obj
          end
          name ||= I18n.t "activerecord.models.#{part.singularize}", :count => 1.1, :default => part.titlecase

          link_to name, '/' + parts[0..index].join('/')
        end
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module DisplayHelper

      def display_name_method_for(resource)
        @@display_name_methods_cache ||= {}
        @@display_name_methods_cache[resource.class] ||= 
          active_admin_application.display_name_methods.find{|method| resource.respond_to? method }
      end

      # Tries to display an object with as friendly of output
      # as possible.
      def display_name(resource)
        resource.send(display_name_method_for(resource))
      end

      # Return a pretty string for any object
      # Date Time are formatted via #localize with :format => :long
      # ActiveRecord objects are formatted via #auto_link
      # We attempt to #display_name of any other objects
      def pretty_format(object)
        case object
        when String
          object
        when Arbre::Element
          object
        when Date, Time
          localize(object, :format => :long)
        when ActiveRecord::Base
          auto_link(object)
        else
          display_name(object)
        end
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module DownloadFormatLinksHelper

      module ClassMethods

        # A ready only of formats to make available in index/paginated
        # collection view.
        # @return [Array]
        # @see add_format for information on adding custom download link
        # formats
        def formats
          @formats ||= [:csv, :xml, :json]
          @formats.clone
        end
        
        # Adds a mime type extension to the list of available formats.
        # You must register the extension prior to adding it to the list
        # of avilable formats. This should be used by plugins that want 
        # to add additional formats to the download format links.
        # @param [Symbol] extension the mime extension to add
        # @return [Array] A copy of the updated formats array.
        def add_format extension
          unless formats.include?(extension)
            if Mime::Type.lookup_by_extension(extension).nil?
              raise ArgumentError, "The mime extension you defined: #{extension} is not registered. Please register it via Mime::Type.register before adding it to the available formats."
            end
          @formats << extension
          end
          formats
        end
      end

      # TODO: Refactor to new HTML DSL
      def build_download_format_links(formats = self.class.formats)
        links = formats.collect do |format|
          link_to format.to_s.upcase, { :format => format}.merge(request.query_parameters.except(:commit, :format))
        end
        div :class => "download_links" do
          text_node [I18n.t('active_admin.download'), links].flatten.join("&nbsp;").html_safe
        end
      end

      def self.included base
        base.extend ClassMethods
      end
    end
  end
end

module ActiveAdmin
  module ViewHelpers
    module FormHelper

      # Flatten a params Hash to an array of fields.
      #
      # @param params [Hash]
      # @param options [Hash] :namespace and :except
      #
      # @return [Array] of [Hash] with one element.
      #
      # @example
      #   fields_for_params(scope: "all", users: ["greg"])
      #     => [ {"scope" => "all"} , {"users[]" => "greg"} ]
      #
      def fields_for_params(params, options = {})
        namespace = options[:namespace]
        except = options[:except].is_a?(Array) ? options[:except] : [options[:except]]

        params.map do |k, v|
          next if namespace.nil? && %w(controller action commit utf8).include?(k.to_s)
          next if except.map(&:to_s).include?(k.to_s)

          if namespace
            k = "#{namespace}[#{k}]"
          end

          case v
          when String
            { k => v }
          when Symbol
            { k => v.to_s }
          when Hash
            fields_for_params(v, :namespace => k)
          when Array
            v.map do |v|
              { "#{k}[]" => v }
            end
          when nil
          	{ k => '' }
          when TrueClass,FalseClass
            { k => v }
          else
            raise "I don't know what to do with #{v.class} params: #{v.inspect}"
          end
        end.flatten.compact
      end
    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module FlashHelper

      # Returns all the flash keys to display in any Active Admin view.
      # This method removes the :timedout key that Devise uses by default
      def active_admin_flash_messages
        @active_admin_flash_messages ||= flash.to_hash.except(:timedout)
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module FormHelper
      
      def active_admin_form_for(resource, options = {}, &block)
        options = Marshal.load( Marshal.dump(options) )
        options[:builder] ||= ActiveAdmin::FormBuilder
        semantic_form_for resource, options, &block
      end

      def hidden_field_tags_for(params, options={})
        fields_for_params(params, options).map do |kv|
          k, v = kv.first
          hidden_field_tag k, v, :id => sanitize_to_id("hidden_active_admin_#{k}")
        end.join("\n").html_safe
      end
    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module IconHelper
      
      # Render an icon from the Iconic icon set
      def icon(*args)
        ActiveAdmin::Iconic.icon(*args)
      end

    end
  end
end
module MethodOrProcHelper

  # This method will either call the symbol on self or instance_exec the Proc
  # within self. Any args will be passed along to the method dispatch.
  #
  # Calling with a Symbol:
  #
  #     call_method_or_exec_proc(:to_s) #=> will call #to_s
  #
  # Calling with a Proc
  #
  #     my_proc = Proc.new{ to_s }
  #     call_method_or_exec_proc(my_proc) #=> will instance_exec in self
  #
  def call_method_or_exec_proc(symbol_or_proc, *args)
    case symbol_or_proc
    when Symbol, String
      send(symbol_or_proc, *args)
    when Proc
      instance_exec(*args, &symbol_or_proc)
    end
  end

  # Many times throughout the views we want to either call a method on an object
  # or instance_exec a proc passing in the object as the first parameter. This
  # method wraps that pattern.
  #
  # Calling with a Symbol:
  #
  #     call_method_or_proc_on(@my_obj, :size) same as @my_obj.size
  #
  # Calling with a Proc:
  #
  #     proc = Proc.new{|s| s.size }
  #     call_method_or_proc_on(@my_obj, proc)
  #
  # By default, the Proc will be instance_exec'd within self. If you would rather
  # not instance exec, but just call the Proc, then pass along `:exec => false` in
  # the options hash.
  #
  #     proc = Proc.new{|s| s.size }
  #     call_method_or_proc_on(@my_obj, proc, :exec => false)
  #
  # You can pass along any necessary arguments to the method / Proc as arguments. For 
  # example:
  #
  #     call_method_or_proc_on(@my_obj, :find, 1) #=> @my_obj.find(1)
  #
  def call_method_or_proc_on(receiver, *args)
    options = { :exec => true }.merge(args.extract_options!)

    symbol_or_proc = args.shift

    case symbol_or_proc
    when Symbol, String
      receiver.send(symbol_or_proc.to_sym, *args)
    when Proc
      if options[:exec]
        instance_exec(receiver, *args, &symbol_or_proc)
      else
        symbol_or_proc.call(receiver, *args)
      end
    end
  end

  # Many configuration options (Ex: site_title, title_image) could either be
  # static (String), methods (Symbol) or procs (Proc). This helper takes care of
  # returning the content when String or call call_method_or_proc_on when Symbol or Proc.
  #
  def render_or_call_method_or_proc_on(obj, string_symbol_or_proc, options = {})
    case string_symbol_or_proc
    when Symbol, Proc
      call_method_or_proc_on(obj, string_symbol_or_proc, options)
    when String
      string_symbol_or_proc
    end
  end

  # This method is different from the others in that it calls `instance_eval` on the reciever,
  # passing it the proc. This evaluates the proc in the context of the reciever, thus changing
  # what `self` means inside the proc.
  def render_in_context(context, obj)
    context ||= self # default to `self`
    case obj
    when Proc
      context.instance_exec &obj
    when Symbol
      context.send obj
    else
      obj
    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module SidebarHelper

      def skip_sidebar!
        @skip_sidebar = true
      end

      def skip_sidebar?
        @skip_sidebar == true
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module TitleHelper

      def title(_title)
        @page_title = _title 
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers
    module ViewFactoryHelper

      def view_factory
        active_admin_namespace.view_factory
      end

    end
  end
end
module ActiveAdmin
  module ViewHelpers

    # Require all ruby files in the view helpers dir
    Dir[File.expand_path('../view_helpers', __FILE__) + "/*.rb"].each{|f| require f }

    include AssignsWithIndifferentAccessHelper
    include ActiveAdminApplicationHelper
    include AutoLinkHelper
    include BreadcrumbHelper
    include DisplayHelper
    include IconHelper
    include MethodOrProcHelper
    include SidebarHelper
    include FormHelper
    include TitleHelper
    include ViewFactoryHelper
    include FlashHelper

  end
end
module ActiveAdmin
  module Views

    class ActionItems < ActiveAdmin::Component

      def build(action_items)
        action_items.each do |action_item|
          span :class => "action_item" do
            instance_eval(&action_item.block)
          end
        end
      end

    end

  end
end
require 'active_admin/views/components/popover'

module ActiveAdmin
  module Views
    # Build an ActionListPopover
    class ActionListPopover < ActiveAdmin::Views::Popover
      builder_method :action_list_popover
      
      
      def build(*args, &block)
        @contents = ul :class => "popover_contents"
        
        options = args.extract_options!
        
        super(options)
      end
      
      def action(title, url, *args)
        options = args.extract_options!
        within @contents do
          li do
            text_node link_to( title, url, options )
          end
        end
      end

    end
  end
endmodule ActiveAdmin
  module Views

    class AttributesTable < ActiveAdmin::Component
      builder_method :attributes_table_for

      attr_reader :resource

      def build(record, *attrs)
        @record = record
        super(:for => @record)
        @table = table
        rows(*attrs)
      end

      def rows(*attrs)
        attrs.each {|attr| row(attr) }
      end

      def row(*args, &block)
        title   = args[0]
        options = args.extract_options!
        options[:class] ||= :row
        @table << tr(options) do
          th do
            header_content_for(title)
          end
          td do
            content_for(block || title)
          end
        end
      end

      protected

      def default_id_for_prefix
        'attributes_table'
      end

      def header_content_for(attr)
        if @record.class.respond_to?(:human_attribute_name)
          @record.class.human_attribute_name(attr, :default => attr.to_s.titleize)
        else
          attr.to_s.titleize
        end
      end

      def empty_value
        span I18n.t('active_admin.empty'), :class => "empty"
      end

      def content_for(attr_or_proc)
        value = case attr_or_proc
                when Proc
                  attr_or_proc.call(@record)
                else
                  content_for_attribute(attr_or_proc)
                end
        value = pretty_format(value)
        value == "" || value.nil? ? empty_value : value
      end

      def content_for_attribute(attr)
        if attr.to_s =~ /^([\w]+)_id$/ && @record.respond_to?($1.to_sym)
          content_for_attribute($1)
        else
          @record.send(attr.to_sym)
        end
      end
    end

  end
end
module ActiveAdmin
  module Views
    # Build a Blank Slate
    class BlankSlate < ActiveAdmin::Component
      builder_method :blank_slate
      
      def default_class_name
        'blank_slate_container'
      end
      
      def build(content)
        super(span(content.html_safe, :class => "blank_slate"))
      end
      
    end
  end
endmodule ActiveAdmin
  module Views

    # = Columns Component
    #
    # The Columns component allows you draw content into scalable columns. All
    # you need to do is define the number of columns and the component will
    # take care of the rest.
    #
    # == Simple Columns
    #
    # To display columns, use the #columns method. Within the block, call the 
    # #column method to create a new column.
    #
    # To createa a two column layout:
    #
    #     colums do
    #       column do
    #         span "Column # 1
    #       end
    #       column do
    #         span "Column # 2
    #       end
    #     end
    #
    #
    # == Multiple Span Columns
    #
    # To make a column span multiple, pass the :span option to the column method:
    #
    #     colums do
    #       column :span => 2 do
    #         span "Column # 1
    #       end
    #       column do
    #         span "Column # 2
    #       end
    #     end
    #
    # By default, each column spans 1 column. So the above layout would have 2 columns,
    # the first being 2 time bigger than the second.
    #
    #
    # == Max and Mix Column Sizes
    #
    # Active Admin is a fluid width layout, which means that columns are all defined
    # using percentages. Sometimes this can cause issues if you don't want a column
    # to shrink or expand past a certain point.
    #
    # To overcome this, columns include a :max_width and :min_width option.
    #
    #     colums do
    #       column :max_width => "200px", :min_width => "100px" do
    #         span "Column # 1
    #       end
    #       column do
    #         span "Column # 2
    #       end
    #     end
    #
    # Now the first column will not grow bigger than 200px and will not shrink smaller
    # than 100px.
    class Columns < ActiveAdmin::Component
      builder_method :columns


      # For documentation, please take a look at Column#build
      def column(*args, &block)
        insert_tag Column, *args, &block
      end

      # Override add child to set widths
      def add_child(*)
        super
        calculate_columns!
      end

      protected

      # Override the closing tag to include a clear
      def closing_tag
        "<div style=\"clear:both;\"></div>" + super
      end

      def margin_size
        2
      end

      # Calculate our columns sizes and margins
      def calculate_columns!
        span_count = columns_span_count
        columns_count = children.size

        all_margins_width = margin_size * (span_count - 1)
        column_width = (100.00 - all_margins_width) / span_count

        children.each_with_index do |col, i|
          is_last_column = i == (columns_count - 1)
          col.set_column_styles(column_width, margin_size, is_last_column)
        end
      end

      def columns_span_count
        count = 0
        children.each {|column| count += column.span_size }

        count
      end

    end

    class Column < ActiveAdmin::Component

      attr_accessor :span_size, :max_width, :min_width

      # @param [Hash] options An options hash for the column
      #
      # @options options [Integer] :span The columns this column should span
      def build(options = {})
        options = options.dup
        @span_size = options.delete(:span) || 1
        @max_width = options.delete(:max_width)
        @min_width = options.delete(:min_width)

        super(options)
      end

      def set_column_styles(column_width, margin_width, is_last_column = false)
        column_with_span_width = (span_size * column_width) + ((span_size - 1) * margin_width)

        styles = []

        styles << "width: #{column_with_span_width}%;"

        if max_width
          styles << "max-width: #{max_width};"
        end

        if min_width
          styles << "min-width: #{min_width};"
        end

        styles << "margin-right: #{margin_width}%;" unless is_last_column

        set_attribute :style, styles.join(" ")
      end

    end
  end
end
require 'active_admin/views/components/popover'

module ActiveAdmin
  module Views

    # Action List - A button with a drop down menu of links
    #
    # Creating a new action list:
    #
    #     dropdown_menu "Administration" do
    #       item "Edit Details", edit_details_path
    #       item "Edit My Account", edit_my_acccount_path
    #     end
    #
    # This will create a button with the label "Administration" and
    # a drop down once clicked with 2 options.
    #
    class DropdownMenu < ActiveAdmin::Component
      builder_method :dropdown_menu

      # Build a new action list
      #
      # @param [String] name  The name to display in the button
      #
      # @param [Hash] options A set of options that get passed along to
      #                       to the parent dom element.
      def build(name, options = {})
        options = options.dup

        # Easily set options for the button or menu
        button_options  = options.delete(:button) || {}
        menu_options = options.delete(:menu) || {}

        @button  = build_button(name, button_options)
        @menu = build_menu(menu_options)

        super(options)
      end

      def item(*args)
        within @menu do
          li link_to(*args)
        end
      end

      private

      def build_button(name, button_options)
        button_options[:class] ||= ""
        button_options[:class] << " dropdown_menu_button"

        button_options[:href] = "#"

        a name, button_options
      end

      def build_menu(options)
        options[:class] ||= ""
        options[:class] << " dropdown_menu_list"

        menu_list = nil

        div :class => "dropdown_menu_list_wrapper", :style => "display:none;" do
          menu_list = ul(options)
        end

        menu_list
      end

    end

  end
end
require 'active_admin/helpers/collection'

module ActiveAdmin
	module Views

    # Renders a collection of index views available to the resource
    # as a list with a separator
		class IndexList < ActiveAdmin::Component
      builder_method :index_list_renderer

      include ::ActiveAdmin::Helpers::Collection

      def default_class_name
        "indexes table_tools_segmented_control"
      end

      def tag_name
        'ul'
      end

      # Builds the links for presenting different index views to the user
      #
      # @param [Array] index_classes The class constants that represent index page presenters 
      def build(index_classes)
        unless current_filter_search_empty?
          index_classes.each do |index_class|
            build_index_list(index_class)
          end
        end
      end

      protected

      # Builds the individual link and HTML classes for each index page presenter
      #
      # @param [Class] index_class The class on which to build the link and html classes
      def build_index_list(index_class)
        li :class => classes_for_index(index_class) do
          a :href => url_for(params.merge(:as => index_class.index_name.to_sym)), :class => "table_tools_button" do
            name = index_class.index_name
            I18n.t("active_admin.index_list.#{name}", :default => name.to_s.titleize)
          end
        end
      end

      def classes_for_index(index_class)
        classes = ["index"]
        classes << "selected" if current_index?(index_class)
        classes.join(" ")
      end

      def current_index?(index_class)
        if params[:as]
          params[:as] == index_class.index_name
        else
          active_admin_config.default_index_class == index_class
        end
      end

      def current_filter_search_empty?
        params.include?(:q) && collection_is_empty?
      end

		end
	end
end


require 'active_admin/helpers/collection'

module ActiveAdmin
  module Views

    # Wraps the content with pagination and available formats.
    #
    # *Example:*
    #
    #   paginated_collection collection, :entry_name => "Post" do
    #     div do
    #       h2 "Inside the
    #     end
    #   end
    #
    # This will create a div with a sentence describing the number of
    # posts in one of the following formats:
    #
    # * "No Posts found"
    # * "Displaying all 10 Posts"
    # * "Displaying Posts 1 - 30 of 31 in total"
    #
    # It will also generate pagination links.
    #
    class PaginatedCollection < ActiveAdmin::Component
      builder_method :paginated_collection

      attr_reader :collection

      # Builds a new paginated collection component
      #
      # collection => A paginated collection from kaminari
      # options    => These options will be passed to `page_entries_info`
      #   entry_name     => The name to display for this resource collection
      #   param_name     => Parameter name for page number in the links (:page by default)
      #   download_links => Download links override (false or [:csv, :pdf])
      #
      def build(collection, options = {})
        @collection = collection
        @param_name     = options.delete(:param_name)
        @download_links = options.delete(:download_links)

        unless collection.respond_to?(:num_pages)
          raise(StandardError, "Collection is not a paginated scope. Set collection.page(params[:page]).per(10) before calling :paginated_collection.")
        end
        
        @contents = div(:class => "paginated_collection_contents")
        build_pagination_with_formats(options)
        @built = true
      end

      # Override add_child to insert all children into the @contents div
      def add_child(*args, &block)
        if @built
          @contents.add_child(*args, &block)
        else
          super
        end
      end

      protected

      def build_pagination_with_formats(options)
        div :id => "index_footer" do
          build_pagination
          div(page_entries_info(options).html_safe, :class => "pagination_information")

          if @download_links.is_a?(Array) && !@download_links.empty?
            build_download_format_links @download_links
          else
            build_download_format_links unless @download_links == false
          end

        end
      end

      def build_pagination
        options =  request.query_parameters.except(:commit, :format)
        options[:param_name] = @param_name if @param_name

        text_node paginate(collection, options.symbolize_keys)
      end

      include ::ActiveAdmin::Helpers::Collection
      include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
        
      # modified from will_paginate
      def page_entries_info(options = {})
        if options[:entry_name]
          entry_name = options[:entry_name]
          entries_name = options[:entries_name] || entry_name.pluralize
        elsif collection_is_empty?
          entry_name = I18n.translate("active_admin.pagination.entry", :count => 1, :default => 'entry')
          entries_name = I18n.translate("active_admin.pagination.entry", :count => 2, :default => 'entries')
        else
          entry_name = I18n.translate("activerecord.models.#{collection.first.class.model_name.i18n_key}", :count => 1, :default => collection.first.class.name.underscore.sub('_', ' '))
          entries_name = I18n.translate("activerecord.models.#{collection.first.class.model_name.i18n_key}", :count => collection.size, :default => entry_name.pluralize)
        end

        if collection.num_pages < 2
          case collection_size
          when 0; I18n.t('active_admin.pagination.empty', :model => entries_name)
          when 1; I18n.t('active_admin.pagination.one', :model => entry_name)
          else;   I18n.t('active_admin.pagination.one_page', :model => entries_name, :n => collection.total_count)
          end
        else
          offset = (collection.current_page - 1) * collection.limit_value
          total = collection.total_count
          I18n.t('active_admin.pagination.multiple', :model => entries_name, :from => offset + 1, :to => offset + collection_size, :total => total)
        end
      end

    end
  end
end
module ActiveAdmin
  module Views

    class Panel < ActiveAdmin::Component
      builder_method :panel

      def build(title, attributes = {})
        icon_name = attributes.delete(:icon)
        icn = icon_name ? icon(icon_name) : ""
        super(attributes)
        add_class "panel"
        @title = h3(icn + title.to_s)
        @contents = div(:class => "panel_contents")
      end

      def add_child(child)
        if @contents
          @contents << child
        else
          super
        end
      end

      # Override children? to only report children when the panel's
      # contents have been added to. This ensures that the panel
      # correcly appends string values, etc.
      def children?
        @contents.children?
      end

    end

  end
end
module ActiveAdmin
  module Views

    class Popover < ActiveAdmin::Component
      builder_method :popover

      def build(options = {}, &block)
        options           = options.dup
        contents_root_tag = options.delete(:contents_root_tag) || :div
        options[:style]   = "display: none"

        super(options)

        @contents_root = send(contents_root_tag, :class => "popover_contents")
      end

      def add_child(child)
        if @contents_root
          @contents_root << child
        else
          super
        end
      end

    end
  end
end
require 'active_admin/helpers/collection'

module ActiveAdmin
  module Views

    # Renders a collection of ActiveAdmin::Scope objects as a
    # simple list with a seperator
    class Scopes < ActiveAdmin::Component
      builder_method :scopes_renderer

      include ActiveAdmin::ScopeChain
      include ::ActiveAdmin::Helpers::Collection


      def default_class_name
        "scopes table_tools_segmented_control"
      end

      def tag_name
        'ul'
      end

      def build(scopes, options = {})
        scopes.each do |scope|
          build_scope(scope, options) if call_method_or_proc_on(self, scope.display_if_block)
        end
      end

      protected

      def build_scope(scope, options)
        li :class => classes_for_scope(scope) do
          scope_name = I18n.t("active_admin.scopes.#{scope.id}", :default => scope.name)

          a :href => url_for(params.merge(:scope => scope.id, :page => 1)), :class => "table_tools_button" do
            text_node scope_name
            span :class => 'count' do
              "(#{get_scope_count(scope)})"
            end if options[:scope_count] && scope.show_count
          end
        end
      end

      def classes_for_scope(scope)
        classes = ["scope", scope.id]
        classes << "selected" if current_scope?(scope)
        classes.join(" ")
      end

      def current_scope?(scope)
        if params[:scope]
          params[:scope] == scope.id
        else
          active_admin_config.default_scope == scope
        end
      end

      # Return the count for the scope passed in.
      def get_scope_count(scope)
        collection_size(scope_chain(scope, collection_before_scope))
      end
    end
  end
end
module ActiveAdmin
  module Views

    class SidebarSection < Panel
      builder_method :sidebar_section

      # Takes a ActiveAdmin::Sidebar::Section instance
      def build(section)
        @section = section
        super(@section.title, :icon => @section.icon)
        self.id = @section.id
        build_sidebar_content
      end

      protected

      def build_sidebar_content
        if @section.block
          rvalue = instance_eval(&@section.block)
          self << rvalue if rvalue.is_a?(String)
        else
          render(@section.partial_name)
        end
      end
    end

  end
end
module ActiveAdmin
  module Views

    class SiteTitle < Component

      def tag_name
        'h1'
      end

      def build(namespace)
        super(:id => "site_title")
        @namespace = namespace

        if site_title_link?
          text_node site_title_with_link
        else
          text_node site_title_content
        end
      end

      def site_title_link?
        @namespace.site_title_link.present?
      end

      def site_title_image?
        @namespace.site_title_image.present?
      end

      private

      def site_title_with_link
        helpers.link_to(site_title_content, @namespace.site_title_link)
      end

      def site_title_content
        if site_title_image?
          title_image
        else
          title_text
        end
      end

      def title_text
        helpers.render_or_call_method_or_proc_on(self, @namespace.site_title)
      end

      def title_image
        path = helpers.render_or_call_method_or_proc_on(self, @namespace.site_title_image)
        helpers.image_tag(path, :id => "site_title_image", :alt => @namespace.site_title)
      end

    end

  end
end
module ActiveAdmin
  module Views
    # Build a StatusTag
    class StatusTag < ActiveAdmin::Component
      builder_method :status_tag

      def tag_name
        'span'
      end

      def default_class_name
        'status_tag'
      end

      # @method status_tag(status, type = nil, options = {})
      #
      # @param [String] status the status to display. One of the span classes will be an underscored version of the status.
      # @param [Symbol] type type of status. Will become a class of the span. ActiveAdmin provide style for :ok, :warning and :error.
      # @param [Hash] options such as :class, :id and :label to override the default label
      #
      # @return [ActiveAdmin::Views::StatusTag]
      #
      # Examples:
      #   status_tag('In Progress')
      #   # => <span class='status_tag in_progress'>In Progress</span>
      #
      #   status_tag('active', :ok)
      #   # => <span class='status_tag active ok'>Active</span>
      #
      #   status_tag('active', :ok, :class => 'important', :id => 'status_123', :label => 'on')
      #   # => <span class='status_tag active ok important' id='status_123'>on</span>
      # 
      def build(*args)
        options = args.extract_options!
        status = args[0]
        type = args[1]
        label = options.delete(:label)
        classes = options.delete(:class)

        content = label || status.titleize if status

        super(content, options)

        add_class(status_to_class(status)) if status
        add_class(type.to_s) if type
        add_class(classes) if classes
      end

      protected

      def status_to_class(status)
        status.titleize.gsub(/\s/, '').underscore
      end
    end
  end
end
module ActiveAdmin
  module Views
    class TableFor < Arbre::HTML::Table
      builder_method :table_for

      def tag_name
        'table'
      end

      def build(collection, options = {})
        @sortable = options.delete(:sortable)
        @resource_class = options.delete(:i18n)
        @collection = collection
        @columns = []
        build_table
        super(options)
      end

      def column(*args, &block)
        options = default_options.merge(args.extract_options!)
        title = args[0]
        data  = args[1] || args[0]

        col = Column.new(title, data, @resource_class, options, &block)
        @columns << col

        # Build our header item
        within @header_row do
          build_table_header(col)
        end

        # Add a table cell for each item
        @collection.each_with_index do |item, i|
          within @tbody.children[i] do
            build_table_cell(col, item)
          end
        end
      end

      def sortable?
        @sortable
      end

      # Returns the columns to display based on the conditional block
      def visible_columns
        @visible_columns ||= @columns.select{|col| col.display_column? }
      end

      protected

      def build_table
        build_table_head
        build_table_body
      end

      def build_table_head
        @thead = thead do
          @header_row = tr
        end
      end

      def build_table_header(col)
        classes = Arbre::HTML::ClassList.new
        sort_key = sortable? && col.sortable? && col.sort_key

        classes << 'sortable'                         if sort_key
        classes << "sorted-#{current_sort[1]}"        if sort_key && current_sort[0] == sort_key
        classes << col.html_class

        if sort_key
          th :class => classes do
            link_to(col.pretty_title, params.merge(:order => "#{sort_key}_#{order_for_sort_key(sort_key)}").except(:page))
          end
        else
          th(col.pretty_title, :class => classes)
        end
      end

      def build_table_body
        @tbody = tbody do
          # Build enough rows for our collection
          @collection.each{|elem| tr(:class => cycle('odd', 'even'), :id => dom_id(elem)) }
        end
      end

      def build_table_cell(col, item)
        td(:class =>  col.html_class) do
          rvalue = call_method_or_proc_on(item, col.data, :exec => false)
          if col.data.is_a?(Symbol)
            rvalue = pretty_format(rvalue)
          end
          rvalue
        end
      end

      # Returns an array for the current sort order
      #   current_sort[0] #=> sort_key
      #   current_sort[1] #=> asc | desc
      def current_sort
        @current_sort ||= if params[:order] && params[:order] =~ /^([\w\_\.]+)_(desc|asc)$/
          [$1,$2]
        else
          []
        end
      end

      # Returns the order to use for a given sort key
      #
      # Default is to use 'desc'. If the current sort key is
      # 'desc' it will return 'asc'
      def order_for_sort_key(sort_key)
        current_key, current_order = current_sort
        return 'desc' unless current_key == sort_key
        current_order == 'desc' ? 'asc' : 'desc'
      end

      def default_options
        {
          :i18n => @resource_class
        }
      end

      class Column

        attr_accessor :title, :data , :html_class

        def initialize(*args, &block)
          @options = args.extract_options!

          @title = args[0]
          @html_class = @options.delete(:class) || @title.to_s.downcase.underscore.gsub(/ +/,'_')
          @data  = args[1] || args[0]
          @data = block if block
          @resource_class = args[2]
        end

        def sortable?
          if @data.is_a?(Proc)
            [String, Symbol].include?(@options[:sortable].class)
          elsif @options.has_key?(:sortable)
            @options[:sortable]
          elsif @data.respond_to?(:to_sym) && @resource_class
            !@resource_class.reflect_on_association(@data.to_sym)
          else
            true
          end
        end

        #
        # Returns the key to be used for sorting this column
        #
        # Defaults to the column's method if its a symbol
        #   column :username
        #   # => Sort key will be set to 'username'
        #
        # You can set the sort key by passing a string or symbol
        # to the sortable option:
        #   column :username, :sortable => 'other_column_to_sort_on'
        #
        # If you pass a block to be rendered for this column, the column
        # will not be sortable unless you pass a string to sortable to
        # sort the column on:
        #
        #   column('Username', :sortable => 'login'){ @user.pretty_name }
        #   # => Sort key will be 'login'
        #
        def sort_key
          # If boolean or nil, use the default sort key.
          if @options[:sortable] == true || @options[:sortable] == false || @options[:sortable].nil?
            @data.to_s
          else
            @options[:sortable].to_s
          end
        end

        def pretty_title
          if @title.is_a?(Symbol)
            default_title =  @title.to_s.titleize
            if @options[:i18n] && @options[:i18n].respond_to?(:human_attribute_name)
              @title = @options[:i18n].human_attribute_name(@title, :default => default_title)
            else
              default_title
            end
          else
            @title
          end
        end
      end
    end
  end
end
module ActiveAdmin
  module Views
    class DashboardSection < ActiveAdmin::Views::Panel

      def build(section)
        @section = section
        super(title, :icon => @section.icon)
        instance_eval &@section.block
      end

      protected

      def title
        I18n.t("active_admin.sections.#{@section.name.to_s}", :default => @section.name.to_s.titleize)
      end

    end
  end
end
module ActiveAdmin
  module Views
    class Footer < Component

      def build
        super :id => "footer"
        powered_by_message
      end

      private

      def powered_by_message
        para I18n.t('active_admin.powered_by',
          :active_admin => link_to("Active Admin", "http://www.activeadmin.info"),
          :version => ActiveAdmin::VERSION).html_safe
      end

    end
  end
end
module ActiveAdmin
  module Views
    class Header < Component

      def build(namespace, menu)
        super(:id => "header")

        @namespace = namespace
        @menu = menu
        @utility_menu = @namespace.fetch_menu(:utility_navigation)

        build_site_title
        build_global_navigation
        build_utility_navigation
      end


      def build_site_title
        insert_tag view_factory.site_title, @namespace
      end

      def build_global_navigation
        insert_tag view_factory.global_navigation, @menu, :class => 'header-item tabs' 
      end

      def build_utility_navigation
        insert_tag view_factory.global_navigation, @utility_menu, :id => "utility_nav", :class => 'header-item tabs' 
      end

    end
  end
end
module ActiveAdmin
  module Views

    # = Index as a Block
    #
    # If you want to fully customize the display of your resources on the index
    # screen, Index as a Block allows you to render a block of content for each
    # resource.
    #
    #     index :as => :block do |product|
    #       div :for => product do
    #         resource_selection_cell product
    #         h2 auto_link(product.title)
    #         div do
    #           simple_format product.description
    #         end
    #       end
    #     end
    #
    class IndexAsBlock < ActiveAdmin::Component

      def build(page_presenter, collection)
        add_class "index"
        resource_selection_toggle_panel if active_admin_config.batch_actions.any?
        collection.each do |obj|
          instance_exec(obj, &page_presenter.block)
        end
      end

      def self.index_name
        "block"
      end

    end
  end
end
module ActiveAdmin
  module Views

    # = Index as Blog
    #
    # Render your index page as a set of posts. The post has two main options:
    # title and body.
    #
    #     index :as => :blog do
    #       title :my_title # Calls #my_title on each resource
    #       body  :my_body  # Calls #my_body on each resource
    #     end
    #
    # == Post Title
    #
    # The title is the content that will be rendered within a link to the
    # resource. There are two main ways to set the content for the title
    #
    # First, you can pass in a method to be called on your
    # resource. For example:
    #
    #     index :as => :blog do
    #       title :a_method_to_call
    #     end
    #
    # This will result in the title of the post being the return value of
    # Resource#a_method_to_call
    #
    # Second, you can pass a block to the tile option which will then be
    # used as the contents fo the title. The resource being rendered
    # is passed in to the block. For Example:
    #
    #     index :as => :blog do
    #       title do |post|
    #         span post.title, :class => 'title'
    #         span post.created_at, :class => 'created_at'
    #       end
    #     end
    #
    # == Post Body
    #
    # The body is rendered underneath the title of each post. The same two
    # style of options work as the Post Title above.
    #
    # Call a method on the resource as the body:
    #
    #     index :as => :blog do
    #       title :my_title
    #       body :my_body # Return value of #my_body will be the body
    #     end
    #
    # Or, render a block as the body:
    #
    #     index :as => :blog do
    #       title :my_title
    #       body do |post|
    #         div truncate(post.title)
    #         div :class => 'meta' do
    #           span "Post in #{post.categories.join(', ')}"
    #         end
    #       end
    #     end
    #
    class IndexAsBlog < ActiveAdmin::Component

      def build(page_presenter, collection)
        @page_presenter = page_presenter
        @collection = collection

        # Call the block passed in. This will set the 
        # title and body methods
        instance_eval &page_presenter.block if page_presenter.block

        add_class "index"
        build_posts
      end

      # Setter method for the configuration of the title
      def title(method = nil, &block)
        if block_given? || method
          @title = block_given? ? block : method
        end
        @title
      end


      # Setter method for the configuration of the body
      #
      def body(method = nil, &block)
        if block_given? || method
          @body = block_given? ? block : method
        end
        @body
      end

      def self.index_name
        "blog"
      end

      private

      def build_posts
        resource_selection_toggle_panel if active_admin_config.batch_actions.any?
        @collection.each do |post|
          build_post(post)
        end
      end

      def build_post(post)
        div :for => post do
          resource_selection_cell(post) if active_admin_config.batch_actions.any?
          build_title(post)
          build_body(post)
        end
      end

      def build_title(post)
        if @title
          h3 do
            link_to(call_method_or_proc_on(post, @title), resource_path(post))
          end
        else
          h3 do
            auto_link(post)
          end
        end
      end

      def build_body(post)
        if @body
          div(call_method_or_proc_on(post, @body), :class => 'content')
        end
      end

    end # Posts
  end
end
module ActiveAdmin
  module Views

     # = Index as a Grid
     #
     # Sometimes you want to display the index screen for a set of resources as a grid
     # (possibly a grid of thumbnail images). To do so, use the :grid option for the
     # index block.
     #
     #     index :as => :grid do |product|
     #       link_to(image_tag(product.image_path), admin_products_path(product))
     #     end
     #
     # The block is rendered within a cell in the grid once for each resource in the
     # collection. The resource is passed into the block for you to use in the view.
     #
     # You can customize the number of colums that are rendered using the columns
     # option:
     #
     #     index :as => :grid, :columns => 5 do |product|
     #       link_to(image_tag(product.image_path), admin_products_path(product))
     #     end
     #
     class IndexAsGrid < ActiveAdmin::Component

      def build(page_presenter, collection)
        @page_presenter = page_presenter
        @collection = collection
        add_class "index"
        build_table
      end

      def number_of_columns
        @page_presenter[:columns] || default_number_of_columns
      end

      def self.index_name
        "grid"
      end

      protected

      def build_table
        resource_selection_toggle_panel if active_admin_config.batch_actions.any?
        table :class => "index_grid" do
          collection.in_groups_of(number_of_columns).each do |group|
            build_row(group)
          end
        end
      end

      def build_row(group)
        tr do
          group.each do |item|
            item ? build_item(item) : build_empty_cell
          end
        end
      end

      def build_item(item)
        td :for => item do
          instance_exec(item, &@page_presenter.block)
        end
      end

      def build_empty_cell
        td '&nbsp;'.html_safe
      end

      def default_number_of_columns
        3
      end

    end
  end
end
module ActiveAdmin
  module Views

    # = Index as a Table
    #
    # By default, the index page is a table with each of the models content columns and links to
    # show, edit and delete the object. There are many ways to customize what gets
    # displayed.
    #
    # == Defining Columns
    #
    # To display an attribute or a method on a resource, simply pass a symbol into the
    # column method:
    #
    #     index do
    #       selectable_column
    #       column :title
    #     end
    #
    # If the default title does not work for you, pass it as the first argument:
    #
    #     index do
    #       selectable_column
    #       column "My Custom Title", :title
    #     end
    #
    # Sometimes calling methods just isn't enough and you need to write some view
    # specific code. For example, say we wanted a colum called Title which holds a
    # link to the posts admin screen.
    #
    # The column method accepts a block as an argument which will then be rendered
    # within the context of the view for each of the objects in the collection.
    #
    #     index do
    #       selectable_column
    #       column "Title" do |post|
    #         link_to post.title, admin_post_path(post)
    #       end
    #     end
    #
    # The block gets called once for each resource in the collection. The resource gets passed into
    # the block as an argument.
    #
    # To setup links to View, Edit and Delete a resource, use the default_actions method:
    #
    #     index do
    #       selectable_column
    #       column :title
    #       default_actions
    #     end
    #
    # Alternatively, you can create a column with custom links:
    #
    #     index do
    #       selectable_column
    #       column :title
    #       column "Actions" do |post|
    #         link_to "View", admin_post_path(post)
    #       end
    #     end
    #
    #
    # == Sorting
    #
    # When a column is generated from an Active Record attribute, the table is
    # sortable by default. If you are creating a custom column, you may need to give
    # Active Admin a hint for how to sort the table.
    #
    # If a column is defined using a block, you must pass the key to turn on sorting. The key
    # is the attribute which gets used to sort objects using Active Record.
    #
    # By default, this is the column on the resource's table that the attribute corresponds to. 
    # Otherwise, any attribute that the resource collection responds to can be used.
    #
    #     index do
    #       column "Title", :sortable => :title do |post|
    #         link_to post.title, admin_post_path(post)
    #       end
    #     end
    #
    # You can also sort using an attribute on another table by passing the table name
    # and the attribute separated by a dot:
    #
    #     index do
    #       column :title, :sortable => 'categories.name'
    #     end
    #
    # You can turn off sorting on any column by passing false:
    #
    #     index do
    #       column :title, :sortable => false
    #     end
    #
    # == Showing and Hiding Columns
    #
    # The entire index block is rendered within the context of the view, so you can
    # easily do things that show or hide columns based on the current context.
    #
    # For example, if you were using CanCan:
    #
    #     index do
    #       column :title, :sortable => false
    #       if can? :manage, Post
    #         column :some_secret_data
    #       end
    #     end
    #
    class IndexAsTable < ActiveAdmin::Component

      def build(page_presenter, collection)
        table_options = {
          :id => "index_table_#{active_admin_config.resource_name.plural}",
          :sortable => true,
          :class => "index_table index",
          :i18n => active_admin_config.resource_class,
          :paginator => page_presenter[:paginator] != false
        }

        table_for collection, table_options do |t|
          table_config_block = page_presenter.block || default_table
          instance_exec(t, &table_config_block)
        end
      end

      def table_for(*args, &block)
        insert_tag IndexTableFor, *args, &block
      end

      def default_table
        proc do
          id_column
          resource_class.content_columns.each do |col|
            column col.name.to_sym
          end
          default_actions
        end
      end

      def self.index_name
        "table"
      end

      #
      # Extend the default ActiveAdmin::Views::TableFor with some
      # methods for quickly displaying items on the index page
      #
      class IndexTableFor < ::ActiveAdmin::Views::TableFor

        # Display a column for checkbox
        def selectable_column
          return unless active_admin_config.batch_actions.any?
          column( resource_selection_toggle_cell, { :class => "selectable" } ) { |resource| resource_selection_cell( resource ) }
        end

        # Display a column for the id
        def id_column
          column(resource_class.human_attribute_name(resource_class.primary_key), :sortable => resource_class.primary_key) do |resource| 
            link_to resource.id, resource_path(resource), :class => "resource_id_link"
          end
        end

        # Add links to perform actions.
        #
        #   # Add default links.
        #   actions
        #
        #   # Append some actions onto the end of the default actions.
        #   actions do |admin_user|
        #     link_to 'Grant Admin', grant_admin_admin_user_path(admin_user)
        #   end
        #
        #   # Custom actions without the defaults.
        #   actions :defaults => false do |admin_user|
        #     link_to 'Grant Admin', grant_admin_admin_user_path(admin_user)
        #   end
        def actions(options = {}, &block)
          options = {
            :name => "",
            :defaults => true
          }.merge(options)
          column options[:name] do |resource|
            text_node default_actions(resource) if options[:defaults]
            text_node instance_exec(resource, &block) if block_given?
          end
        end

        def default_actions(*args)
          links = proc do |resource|
            links = ''.html_safe
            if controller.action_methods.include?('show') && authorized?(ActiveAdmin::Auth::READ, resource)
              links << link_to(I18n.t('active_admin.view'), resource_path(resource), :class => "member_link view_link")
            end
            if controller.action_methods.include?('edit') && authorized?(ActiveAdmin::Auth::UPDATE, resource)
              links << link_to(I18n.t('active_admin.edit'), edit_resource_path(resource), :class => "member_link edit_link")
            end
            if controller.action_methods.include?('destroy') && authorized?(ActiveAdmin::Auth::DESTROY, resource)
              links << link_to(I18n.t('active_admin.delete'), resource_path(resource), :method => :delete, :data => {:confirm => I18n.t('active_admin.delete_confirmation')}, :class => "member_link delete_link")
            end
            links
          end

          options = args.extract_options!
          if options.present? || args.empty?
            actions options
          else
            links.call(args.first)
          end
        end

        # Display A Status Tag Column
        #
        #   index do |i|
        #     i.status_tag :state
        #   end
        #
        #   index do |i|
        #     i.status_tag "State", :status_name
        #   end
        #
        #   index do |i|
        #     i.status_tag do |post|
        #       post.published? ? 'published' : 'draft'
        #     end
        #   end
        #
        def status_tag(*args, &block)
          col = Column.new(*args, &block)
          data = col.data
          col.data = proc do |resource|
            status_tag call_method_or_proc_on(resource, data)
          end
          add_column col
        end
      end # TableBuilder

    end # Table
  end
end
module ActiveAdmin
  module Views
    module Pages
      class Base < Arbre::HTML::Document

        def build(*args)
          super
          add_classes_to_body
          build_active_admin_head
          build_page
        end

        private

        def add_classes_to_body
          @body.add_class(params[:action])
          @body.add_class(params[:controller].gsub('/', '_'))
          @body.add_class("active_admin")
          @body.add_class("logged_in")
          @body.add_class(active_admin_namespace.name.to_s + "_namespace")
        end

        def build_active_admin_head
          within @head do
            insert_tag Arbre::HTML::Title, [title, render_or_call_method_or_proc_on(self, active_admin_application.site_title)].join(" | ")
            active_admin_application.stylesheets.each do |style|
              text_node(stylesheet_link_tag(style.path, style.options.dup).html_safe)
            end

            active_admin_application.javascripts.each do |path|
              script :src => javascript_path(path), :type => "text/javascript"
            end
            text_node csrf_meta_tag
          end
        end

        def build_page
          within @body do
            div :id => "wrapper" do
              build_header
              build_title_bar
              build_page_content
              build_footer
            end
          end
        end

        def build_header
          insert_tag view_factory.header, active_admin_namespace, current_menu
        end

        def build_title_bar
          insert_tag view_factory.title_bar, title, action_items_for_action
        end


        def build_page_content
          build_flash_messages
          div :id => "active_admin_content", :class => (skip_sidebar? ? "without_sidebar" : "with_sidebar") do
            build_main_content_wrapper
            build_sidebar unless skip_sidebar?
          end
        end

        def build_flash_messages
          if active_admin_flash_messages.any?
            div :class => 'flashes' do
              active_admin_flash_messages.each do |type, message|
                div message, :class => "flash flash_#{type}"
              end
            end
          end
        end

        def build_main_content_wrapper
          div :id => "main_content_wrapper" do
            div :id => "main_content" do
              main_content
            end
          end
        end

        def main_content
          I18n.t('active_admin.main_content', :model => self.class.name).html_safe
        end

        def title
          self.class.name
        end

        # Set's the page title for the layout to render
        def set_page_title
          set_ivar_on_view "@page_title", title
        end

        # Returns the sidebar sections to render for the current action
        def sidebar_sections_for_action
          if active_admin_config && active_admin_config.sidebar_sections?
            active_admin_config.sidebar_sections_for(params[:action], self)
          else
            []
          end
        end

        def action_items_for_action
          if active_admin_config && active_admin_config.action_items?
            active_admin_config.action_items_for(params[:action], self)
          else
            []
          end
        end

        # Renders the sidebar
        def build_sidebar
          div :id => "sidebar" do
            sidebar_sections_for_action.collect do |section|
              sidebar_section(section)
            end
          end
        end

        def skip_sidebar?
          sidebar_sections_for_action.empty? || assigns[:skip_sidebar] == true
        end

        # Renders the content for the footer
        def build_footer
          insert_tag view_factory.footer
        end

      end
    end
  end
end
module ActiveAdmin
  module Views
    module Pages
      class Dashboard < Base

        def main_content
          if assigns[:dashboard_sections] && assigns[:dashboard_sections].any?
            render_sections(assigns[:dashboard_sections])
          else
            default_welcome_section
          end
        end

        protected

        # Dashboards don't have a sidebar
        def build_sidebar; end

        def title
          I18n.t("active_admin.dashboard")
        end

        def render_sections(sections)
          table :class => "dashboard" do
            sections.in_groups_of(3, false).each do |row|
              tr do
                row.each do |section|
                  td do
                    render_section(section)
                  end
                end
              end
            end
          end
        end

        # Renders each section using their renderer
        def render_section(section)
          insert_tag section_renderer(section), section
        end

        def section_renderer(section)
          if section.options[:as]
            view_factory["dashboard_section_as_#{section.options[:as]}"]
          else
            view_factory.dashboard_section
          end
        end

        def default_welcome_section
          div :class => "blank_slate_container", :id => "dashboard_default_message" do
            span :class => "blank_slate" do
              span I18n.t('active_admin.dashboard_welcome.welcome')
              small I18n.t('active_admin.dashboard_welcome.call_to_action')
            end
          end
        end

      end
    end
  end
end
module ActiveAdmin
  module Views
    module Pages

      class Form < Base

        def title
          I18n.t("active_admin.#{params[:action]}_model",
                 :model => active_admin_config.resource_label)
        end

        def form_presenter
            active_admin_config.get_page_presenter(:form) || default_form_config
        end

        def main_content
          form_options = default_form_options.merge(form_presenter.options)

          if form_options[:partial]
            render(form_options[:partial])
          else
            active_admin_form_for(resource, form_options) do |f|
              instance_exec f, &form_presenter.block
            end
          end
        end

        private

        def default_form_options
          {
            :url => default_form_path,
            :as => active_admin_config.resource_name.singular
          }
        end

        def default_form_path
          resource.persisted? ? resource_path(resource) : collection_path
        end

        def default_form_config
          ActiveAdmin::PagePresenter.new do |f|
            f.inputs
            f.actions
          end
        end
      end

    end
  end
end
require 'active_admin/helpers/collection'

module ActiveAdmin
  module Views
    module Pages

      class Index < Base

        def title
          case config[:title]
          when Proc then controller.instance_eval(&config[:title])
          when String then config[:title]
          else
            active_admin_config.plural_resource_label
          end
        end

        def config
          active_admin_config.get_page_presenter(:index, params[:as]) || default_index_config
        end

        # Render's the index configuration that was set in the
        # controller. Defaults to rendering the ActiveAdmin::Pages::Index::Table
        def main_content
          wrap_with_batch_action_form do
            build_table_tools
            build_collection
          end
        end

        protected

        def wrap_with_batch_action_form(&block)
          if active_admin_config.batch_actions.any?
            batch_action_form(&block)
          else
            block.call
          end
        end

        include ::ActiveAdmin::Helpers::Collection

        def items_in_collection?
          !collection_is_empty?
        end

        def build_collection
          if items_in_collection?
            render_index
          else
            if params[:q] || params[:scope]
              render_empty_results
            else
              render_blank_slate
            end
          end
        end

        include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper

        def build_table_tools
          div :class => "table_tools" do
            build_batch_actions_selector
            build_scopes
            build_index_list
          end
        end

        def build_batch_actions_selector
          if active_admin_config.batch_actions.any?
            insert_tag view_factory.batch_action_selector, active_admin_config.batch_actions
          end
        end

        def build_scopes
          if active_admin_config.scopes.any?
            scope_options = {
              :scope_count => config[:scope_count].nil? ? true : config[:scope_count]
            }

            scopes_renderer active_admin_config.scopes, scope_options
          end
        end

        def build_index_list
          indexes = active_admin_config.page_presenters[:index]

          if indexes.kind_of?(Hash) && indexes.length > 1
            index_classes = []
            active_admin_config.page_presenters[:index].each do |type, page_presenter|
              index_classes << find_index_renderer_class(page_presenter[:as])
            end
            
            index_list_renderer index_classes
          end
        end

        # Creates a default configuration for the resource class. This is a table
        # with each column displayed as well as all the default actions
        def default_index_config
          @default_index_config ||= ::ActiveAdmin::PagePresenter.new(:as => :table) do |display|
            selectable_column
            id_column
            resource_class.content_columns.each do |col|
              column col.name.to_sym
            end
            default_actions
          end
        end

        # Returns the actual class for renderering the main content on the index
        # page. To set this, use the :as option in the page_presenter block.
        def find_index_renderer_class(symbol_or_class)
          case symbol_or_class
          when Symbol
            ::ActiveAdmin::Views.const_get("IndexAs" + symbol_or_class.to_s.camelcase)
          when Class
            symbol_or_class
          else
            raise ArgumentError, "'as' requires a class or a symbol"
          end
        end
        
        def render_blank_slate
          blank_slate_content = I18n.t("active_admin.blank_slate.content", :resource_name => active_admin_config.plural_resource_label)
          if controller.action_methods.include?('new')
            blank_slate_content += " " + link_to(I18n.t("active_admin.blank_slate.link"), new_resource_path)
          end
          insert_tag(view_factory.blank_slate, blank_slate_content)
        end
        
        def render_empty_results
          empty_results_content = I18n.t("active_admin.pagination.empty", :model => active_admin_config.plural_resource_label)
          insert_tag(view_factory.blank_slate, empty_results_content)
        end
        
        def render_index
          renderer_class = find_index_renderer_class(config[:as])
          paginator      = config[:paginator].nil?      ? true : config[:paginator]
          download_links = config[:download_links].nil? ? active_admin_config.namespace.download_links : config[:download_links]
          
          paginated_collection(collection, :entry_name     => active_admin_config.resource_label,
                                           :entries_name   => active_admin_config.plural_resource_label,
                                           :download_links => download_links,
                                           :paginator      => paginator) do
            div :class => 'index_content' do
              insert_tag(renderer_class, config, collection)
            end
          end
        end

      end
    end
  end
end

module ActiveAdmin
  module Views
    module Pages

      # Acts as a standard rails Layout for use when logged
      # out or when rendering custom actions.
      class Layout < Base

        def title
          assigns[:page_title] || I18n.t("active_admin.#{params[:action]}", :default => params[:action].to_s.titleize)
        end

        # Render the content_for(:layout) into the main content area
        def main_content
          content_for_layout = content_for(:layout)
          if content_for_layout.is_a?(Arbre::Element)
            current_arbre_element.add_child content_for_layout.children
          else
            text_node content_for_layout
          end
        end
      end

    end
  end
end
module ActiveAdmin
  module Views
    module Pages
      class Page < Base

        def main_content
          if page_presenter.block
            instance_exec &page_presenter.block
          else
            nil
          end
        end

        protected

        def page_presenter
          active_admin_config.get_page_presenter(:index) || ActiveAdmin::PagePresenter.new
        end

        def title
          if page_presenter[:title]
            render_or_call_method_or_proc_on self, page_presenter[:title]
          else
            active_admin_config.name
          end
        end
      end
    end
  end
end
module ActiveAdmin
  module Views
    module Pages
      class Show < Base

        def config
          active_admin_config.get_page_presenter(:show) || super
        end

        def title
          if config[:title]
            render_or_call_method_or_proc_on(resource, config[:title])
          else
            default_title
          end
        end

        def main_content
          if config.block
            # Eval the show config from the controller
            instance_exec resource, &config.block
          else
            default_main_content
          end
        end

        def attributes_table(*args, &block)
          panel(I18n.t('active_admin.details', :model => active_admin_config.resource_label)) do
            attributes_table_for resource, *args, &block
          end
        end

        protected

        def default_title
          title = display_name(resource)

          if title.nil? || title.empty? || title == resource.to_s
            title = "#{active_admin_config.resource_label} ##{resource.id}"
          end

          title
        end

        module DefaultMainContent
          def default_main_content
            attributes_table *default_attribute_table_rows
          end

          def default_attribute_table_rows
            resource.class.columns.collect{|column| column.name.to_sym }
          end
        end

        include DefaultMainContent
      end
    end
  end
end
module ActiveAdmin
  module Views

    # Renders an ActiveAdmin::Menu as a set of unordered list items.
    #
    # This component takes cares of deciding which items should be
    # displayed given the current context and renders them appropriately.
    #
    # The entire component is rendered within one ul element.
    class TabbedNavigation < Component

      attr_reader :menu

      # Build a new tabbed navigation component.
      #
      # @param [ActiveAdmin::Menu] menu the Menu to render
      # @param [Hash] options the options as passed to the underlying ul element.
      #
      def build(menu, options = {})
        @menu = menu
        super(default_options.merge(options))
        build_menu
      end

      # The top-level menu items that should be displayed.
      def menu_items
        menu.items(self)
      end

      def tag_name
        'ul'
      end

      private

      def build_menu
        menu_items.each do |item|
          build_menu_item(item)
        end
      end

      def build_menu_item(item)
        li :id => item.id do |li|
          li.add_class "current" if item.current? assigns[:current_tab]

          text_node link_to item.label(self), item.url(self), item.html_options

          if children = item.items(self).presence
            li.add_class "has_nested"
            ul do
              children.each{ |child| build_menu_item child }
            end
          end
        end
      end

      def default_options
        { :id => "tabs" }
      end
    end
  end
end
module ActiveAdmin
  module Views
    class TitleBar < Component

      def build(title, action_items)
        super(:id => "title_bar")
        @title = title
        @action_items = action_items
        build_titlebar_left
        build_titlebar_right
      end

      private

      def build_titlebar_left
        div :id => "titlebar_left" do
          build_breadcrumb
          build_title_tag
        end
      end

      def build_titlebar_right
        div :id => "titlebar_right" do
          build_action_items
        end
      end

      def build_breadcrumb(separator = "/")
        links = if active_admin_config && active_admin_config.breadcrumb.present?
          instance_exec(controller, &active_admin_config.breadcrumb)
        else
          breadcrumb_links
        end
        return unless links.present? && links.is_a?(::Array)
        span :class => "breadcrumb" do
          links.each do |link|
            text_node link
            span(separator, :class => "breadcrumb_sep")
          end
        end
      end

      def build_title_tag
        h2(@title, :id => 'page_title')
      end

      def build_action_items
        insert_tag(view_factory.action_items, @action_items) if @action_items.any?
      end

    end
  end
end
module ActiveAdmin
  module Views

    # Loads all the classes in views/*.rb
    Dir[File.expand_path('../views', __FILE__) + "/**/*.rb"].sort.each{ |f| require f }

  end
end
require 'meta_search'
require 'bourbon'
require 'devise'
require 'kaminari'
require 'formtastic'
require 'sass'
require 'inherited_resources'
require 'jquery-rails'
require 'arbre'
require 'active_admin/dependency_checker' 
require 'active_admin/sass/helpers'
require 'active_admin/engine'

module ActiveAdmin

  autoload :VERSION,                  'active_admin/version'
  autoload :Application,              'active_admin/application'
  autoload :AssetRegistration,        'active_admin/asset_registration'
  autoload :Authorization,            'active_admin/authorization_adapter'
  autoload :AuthorizationAdapter,     'active_admin/authorization_adapter'
  autoload :Breadcrumbs,              'active_admin/breadcrumbs'
  autoload :CanCanAdapter,            'active_admin/cancan_adapter'
  autoload :Callbacks,                'active_admin/callbacks'
  autoload :Component,                'active_admin/component'
  autoload :BaseController,           'active_admin/base_controller'
  autoload :ControllerAction,         'active_admin/controller_action'
  autoload :CSVBuilder,               'active_admin/csv_builder'
  autoload :Dashboards,               'active_admin/dashboards'
  autoload :Deprecation,              'active_admin/deprecation'
  autoload :Devise,                   'active_admin/devise'
  autoload :DSL,                      'active_admin/dsl'
  autoload :Event,                    'active_admin/event'
  autoload :FormBuilder,              'active_admin/form_builder'
  autoload :Inputs,                   'active_admin/inputs'
  autoload :Iconic,                   'active_admin/iconic'
  autoload :Menu,                     'active_admin/menu'
  autoload :MenuCollection,           'active_admin/menu_collection'
  autoload :MenuItem,                 'active_admin/menu_item'
  autoload :Namespace,                'active_admin/namespace'
  autoload :Page,                     'active_admin/page'
  autoload :PagePresenter,            'active_admin/page_presenter'
  autoload :PageController,           'active_admin/page_controller'
  autoload :PageDSL,                  'active_admin/page_dsl'
  autoload :Reloader,                 'active_admin/reloader'
  autoload :Resource,                 'active_admin/resource'
  autoload :ResourceController,       'active_admin/resource_controller'
  autoload :ResourceDSL,              'active_admin/resource_dsl'
  autoload :Scope,                    'active_admin/scope'
  autoload :ScopeChain,               'active_admin/helpers/scope_chain'
  autoload :SidebarSection,           'active_admin/sidebar_section'
  autoload :TableBuilder,             'active_admin/table_builder'
  autoload :ViewFactory,              'active_admin/view_factory'
  autoload :ViewHelpers,              'active_admin/view_helpers'
  autoload :Views,                    'active_admin/views'

  class Railtie < ::Rails::Railtie
    config.after_initialize do
      # Add load paths straight to I18n, so engines and application can overwrite it.
      require 'active_support/i18n'
      I18n.load_path.unshift *Dir[File.expand_path('../active_admin/locales/*.yml', __FILE__)]
    end
  end

  class << self

    attr_accessor :application

    def application
      @application ||= ::ActiveAdmin::Application.new
    end

    # Gets called within the initializer
    def setup
      application.setup!
      yield(application)
      application.prepare!
    end

    delegate :register,      :to => :application
    delegate :register_page, :to => :application
    delegate :unload!,       :to => :application
    delegate :load!,         :to => :application
    delegate :routes,        :to => :application

    # Returns true if this rails application has the asset
    # pipeline enabled.
    def use_asset_pipeline?
      DependencyChecker.rails_3_1? && Rails.application.config.try(:assets).try(:enabled)
    end

    # Migration MoveAdminNotesToComments generated with version 0.2.2 might reference
    # to ActiveAdmin.default_namespace.
    delegate :default_namespace, :to => :application
    ActiveAdmin::Deprecation.deprecate self, :default_namespace, 
      "ActiveAdmin.default_namespace is deprecated. Please use ActiveAdmin.application.default_namespace"

    # A callback is triggered each time (before) Active Admin loads the configuration files.
    # In development mode, this will happen whenever the user changes files. In production
    # it only happens on boot.
    #
    # The block takes the current instance of [ActiveAdmin::Application]
    #
    # Example:
    #
    #     ActiveAdmin.before_load do |app|
    #       # Do some stuff before AA loads
    #     end
    #
    # @param [Block] block A block to call each time (before) AA loads resources
    def before_load(&block)
      ActiveAdmin::Event.subscribe ActiveAdmin::Application::BeforeLoadEvent, &block
    end

    # A callback is triggered each time (after) Active Admin loads the configuration files. This
    # is an opportunity to hook into Resources after they've been loaded.
    #
    # The block takes the current instance of [ActiveAdmin::Application]
    #
    # Example:
    #
    #     ActiveAdmin.after_load do |app|
    #       app.namespaces.each do |name, namespace|
    #         puts "Namespace: #{name} loaded!"
    #       end
    #     end
    #
    # @param [Block] block A block to call each time (after) AA loads resources
    def after_load(&block)
      ActiveAdmin::Event.subscribe ActiveAdmin::Application::AfterLoadEvent, &block
    end

  end

end

ActiveAdmin::DependencyChecker.check!

# Require internal Plugins
require 'active_admin/comments'
require 'active_admin/batch_actions'
require 'active_admin/filters'
require 'active_admin'
module ActiveAdmin
  module Generators
    class AssetsGenerator < Rails::Generators::Base

      class_option :bourbon, :type => :boolean, :default => true,
                   :desc => "Generate Bourbon scss files if using Rails 3.0.x"

      class_option :jquery, :type => :boolean, :default => true,
                   :desc => "Generate jQuery js files if using Rails 3.0.x"

      def self.source_root
        @_active_admin_source_root ||= File.expand_path("../templates", __FILE__)
      end

      def install_assets
        require 'rails'
        require 'active_admin'

        if ActiveAdmin.use_asset_pipeline?
          template '3.1/active_admin.js', 'app/assets/javascripts/active_admin.js'
          template '3.1/active_admin.css.scss', 'app/assets/stylesheets/active_admin.css.scss'
        else
          template '3.0/active_admin.js', 'public/javascripts/active_admin.js'
          directory '../../../../../app/assets/images/active_admin', 'public/images/active_admin'
          generate "jquery:install --ui" if options.jquery?
          install_bourbon if options.bourbon?
        end
      end

      private

      def install_bourbon
        rake "bourbon:install"
        create_file "public/stylesheets/sass/_bourbon.scss", '@import "bourbon/bourbon"'
      end

    end
  end
end
module ActiveAdmin
  module Generators
    class DeviseGenerator < Rails::Generators::NamedBase
      desc "Creates an admin user and uses Devise for authentication"
      argument :name, :type => :string, :default => "AdminUser"

      class_option  :registerable, :type => :boolean, :default => false,
                    :desc => "Should the generated resource be registerable?"

      def install_devise
        require 'devise'
        if File.exists?(File.join(destination_root, "config", "initializers", "devise.rb"))
          log :generate, "No need to install devise, already done."
        else
          log :generate, "devise:install"
          invoke "devise:install"
        end
      end

      def create_admin_user
        invoke "devise", [name]
      end

      def remove_registerable_from_model
        unless options[:registerable]
          model_file = File.join(destination_root, "app", "models", "#{file_path}.rb")
          gsub_file model_file, /\:registerable([.]*,)?/, ""
        end
      end

      def set_namespace_for_path
        routes_file = File.join(destination_root, "config", "routes.rb")
        gsub_file routes_file, /devise_for :#{plural_table_name}/, "devise_for :#{plural_table_name}, ActiveAdmin::Devise.config"
      end

      def add_default_user_to_migration
        # Don't assume that we have a migration!
        devise_migration_file = Dir["db/migrate/*_devise_create_#{table_name}.rb"].first
        return if devise_migration_file.nil?

        devise_migration_content = File.read(devise_migration_file)

        if devise_migration_content["def change"]
          inject_into_file  devise_migration_file,
                            "def migrate(direction)\n    super\n    # Create a default user\n    #{class_name}.create!(:email => 'admin@example.com', :password => 'password', :password_confirmation => 'password') if direction == :up\n  end\n\n  ", 
                            :before => "def change"
        elsif devise_migration_content[/def (self.)?up/]
          inject_into_file  devise_migration_file,
                            "# Create a default user\n    #{class_name}.create!(:email => 'admin@example.com', :password => 'password', :password_confirmation => 'password')\n\n    ",
                            :before => "add_index :#{table_name}, :email"
        else
          puts devise_migration_content
          raise "Failed to add default admin user to migration."
        end
      end
    end
  end
end
require 'rails/generators/active_record'

module ActiveAdmin
  module Generators
    class InstallGenerator < ActiveRecord::Generators::Base
      desc "Installs Active Admin and generates the necessary migrations"
      argument :name, :type => :string, :default => "AdminUser"

      hook_for :users, :default => "devise", :desc => "Admin user generator to run. Skip with --skip-users"

      def self.source_root
        @_active_admin_source_root ||= File.expand_path("../templates", __FILE__)
      end

			def copy_initializer
        @underscored_user_name = name.underscore
        template 'active_admin.rb.erb', 'config/initializers/active_admin.rb'
      end

      def setup_directory
        empty_directory "app/admin"
        template 'dashboard.rb', 'app/admin/dashboard.rb'
        if options[:users].present?
          @user_class = name
          template 'admin_user.rb.erb', "app/admin/#{name.underscore}.rb"
        end
      end

      def setup_routes
        if ARGV.include? "--skip-users"
          route "ActiveAdmin.routes(self)"
        else # Ensure Active Admin routes occur after Devise routes so that Devise has higher priority
          inject_into_file "config/routes.rb", "\n  ActiveAdmin.routes(self)", :after => /devise_for.*/
        end
      end

      def create_assets
        generate "active_admin:assets"
      end

      def create_migrations
        Dir["#{self.class.source_root}/migrations/*.rb"].sort.each do |filepath|
          name = File.basename(filepath)
          migration_template "migrations/#{name}", "db/migrate/#{name.gsub(/^\d+_/,'')}"
          sleep 1
        end
      end
    end
  end
end
ActiveAdmin.register_page "Dashboard" do

  menu :priority => 1, :label => proc{ I18n.t("active_admin.dashboard") }

  content :title => proc{ I18n.t("active_admin.dashboard") } do
    div :class => "blank_slate_container", :id => "dashboard_default_message" do
      span :class => "blank_slate" do
        span I18n.t("active_admin.dashboard_welcome.welcome")
        small I18n.t("active_admin.dashboard_welcome.call_to_action")
      end
    end

    # Here is an example of a simple dashboard with columns and panels.
    #
    # columns do
    #   column do
    #     panel "Recent Posts" do
    #       ul do
    #         Post.recent(5).map do |post|
    #           li link_to(post.title, admin_post_path(post))
    #         end
    #       end
    #     end
    #   end

    #   column do
    #     panel "Info" do
    #       para "Welcome to ActiveAdmin."
    #     end
    #   end
    # end
  end # content
end
class CreateAdminNotes < ActiveRecord::Migration
  def self.up
    create_table :admin_notes do |t|
      t.string :resource_id, :null => false
      t.string :resource_type, :null => false
      t.references :admin_user, :polymorphic => true
      t.text :body
      t.timestamps
    end
    add_index :admin_notes, [:resource_type, :resource_id]
    add_index :admin_notes, [:admin_user_type, :admin_user_id]
  end

  def self.down
    drop_table :admin_notes
  end
end
class MoveAdminNotesToComments < ActiveRecord::Migration
  def self.up
    remove_index  :admin_notes, [:admin_user_type, :admin_user_id]
    rename_table  :admin_notes, :active_admin_comments
    rename_column :active_admin_comments, :admin_user_type, :author_type
    rename_column :active_admin_comments, :admin_user_id, :author_id
    add_column    :active_admin_comments, :namespace, :string
    add_index     :active_admin_comments, [:namespace]
    add_index     :active_admin_comments, [:author_type, :author_id]

    # Update all the existing comments to the default namespace
    say "Updating any existing comments to the #{ActiveAdmin.application.default_namespace} namespace."
    comments_table_name = ActiveRecord::Migrator.proper_table_name("active_admin_comments")
    execute "UPDATE #{comments_table_name} SET namespace='#{ActiveAdmin.application.default_namespace}'"
  end

  def self.down
    remove_index  :active_admin_comments, :column => [:author_type, :author_id]
    remove_index  :active_admin_comments, :column => [:namespace]
    remove_column :active_admin_comments, :namespace
    rename_column :active_admin_comments, :author_id, :admin_user_id
    rename_column :active_admin_comments, :author_type, :admin_user_type
    rename_table  :active_admin_comments, :admin_notes
    add_index     :admin_notes, [:admin_user_type, :admin_user_id]
  end
end
module ActiveAdmin
  module Generators
    class ResourceGenerator < Rails::Generators::NamedBase
      desc "Installs ActiveAdmin in a rails 3 application"

      def self.source_root
        @_active_admin_source_root ||= File.expand_path("../templates", __FILE__)
      end

      def generate_config_file
        template "admin.rb", "app/admin/#{file_path.gsub('/', '_').pluralize}.rb"
      end

    end
  end
end
ActiveAdmin.register <%= class_name %> do
  
end
require 'spec_helper'

describe ActiveAdmin::Application do

  include Rails.application.routes.url_helpers

  [false, nil].each do |value|

    describe "with a #{value} default namespace" do

      before(:all) do
        @__original_application = ActiveAdmin.application
        application = ActiveAdmin::Application.new
        application.default_namespace = value
        ActiveAdmin.application = application
        load_defaults!
        reload_routes!
      end

      after(:all) do
        ActiveAdmin.application = @__original_application
      end

      it "should generate a log out path" do
        destroy_admin_user_session_path.should == "/admin_users/logout"
      end

      it "should generate a log in path" do
        new_admin_user_session_path.should == "/admin_users/login"
      end

    end

  end

    describe "with a test default namespace" do

      before(:all) do
        @__original_application = ActiveAdmin.application
        application = ActiveAdmin::Application.new
        application.default_namespace = :test
        ActiveAdmin.application = application
        load_defaults!
        reload_routes!
      end

      after(:all) do
        ActiveAdmin.application = @__original_application
      end

      it "should generate a log out path" do
        destroy_admin_user_session_path.should == "/test/logout"
      end

      it "should generate a log in path" do
        new_admin_user_session_path.should == "/test/login"
      end

    end

end
require 'spec_helper'
require 'jslint'

%x[which java]
if $? == 0 # Only run the JS Lint test if Java is installed
  describe "Javascript" do
    before do
      @lint = JSLint::Lint.new(
        :paths => ['public/javascripts/**/*.js'],
        :exclude_paths => ['public/javascripts/vendor/**/*.js'],
        :config_path => 'spec/support/jslint.yml'
      )
    end

    it "should not have any syntax errors" do
      @lint.run
    end
  end
end

require 'spec_helper'

# These tests show the memory leak that is currently in Active Admin. They
# are all marked as pending until they pass. To work on them, comment out the
# pending method call in #it_should_not_leak
describe "Memory Leak" do

  def count_instances_of(klass)
    ObjectSpace.each_object(klass) { }
  end

  def self.it_should_not_leak(klass)
    it "should not leak #{klass}" do
      GC.start

      count = count_instances_of(klass)

      load_defaults!
      GC.start

      count_instances_of(klass).should <= count
    end
  end

  it_should_not_leak ActiveAdmin::Namespace
  it_should_not_leak ActiveAdmin::Resource

end
require 'spec_helper'

describe "Stylesheets" do
  if Rails.version[0..2] == '3.1'
    require "sprockets"
    context "when Rails 3.1.x" do
      let(:css) do
        assets = Rails.application.assets
        assets.find_asset("active_admin.css")
      end
      it "should successfully render the scss stylesheets using sprockets" do
        css.should_not be_nil
      end
      it "should not have any syntax errors" do
        css.to_s.should_not include("Syntax error:")
      end
    end
  end

  if Rails.version[0..2] == '3.0'
    context "when Rails 3.0.x" do
      let(:stylesheet_path) do
        Rails.root + 'public/stylesheets/active_admin.css'
      end

      before do
        "rm #{stylesheet_path}" if File.exists?(stylesheet_path)
        Sass::Plugin.force_update_stylesheets
      end

      it "should render the scss stylesheets using SASS" do
        File.exists?(stylesheet_path).should be_true
      end

      it "should not have any syntax errors" do
        css = File.read(stylesheet_path)
        css.should_not include("Syntax error:")
      end
    end
  end
end
module Jasmine
  class Config

    # Add your overrides or custom config code here

  end
end


# Note - this is necessary for rspec2, which has removed the backtrace
module Jasmine
  class SpecBuilder
    def declare_spec(parent, spec)
      me = self
      example_name = spec["name"]
      @spec_ids << spec["id"]
      backtrace = @example_locations[parent.description + " " + example_name]
      parent.it example_name, {} do
        me.report_spec(spec["id"])
      end
    end
  end
end
$:.unshift(ENV['JASMINE_GEM_PATH']) if ENV['JASMINE_GEM_PATH'] # for gem testing purposes

require 'rubygems'
require 'jasmine'
jasmine_config_overrides = File.expand_path(File.join(File.dirname(__FILE__), 'jasmine_config.rb'))
require jasmine_config_overrides if File.exist?(jasmine_config_overrides)
if Jasmine::rspec2?
  require 'rspec'
else
  require 'spec'
end

jasmine_config = Jasmine::Config.new
spec_builder = Jasmine::SpecBuilder.new(jasmine_config)

should_stop = false

if Jasmine::rspec2?
  RSpec.configuration.after(:suite) do
    spec_builder.stop if should_stop
  end
else
  Spec::Runner.configure do |config|
    config.after(:suite) do
      spec_builder.stop if should_stop
    end
  end
end

spec_builder.start
should_stop = true
spec_builder.declare_suitesrequire File.expand_path("../spec_helper_without_rails", __FILE__)

module ActiveAdminIntegrationSpecHelper
  extend self

  def load_defaults!
    ActiveAdmin.unload!
    ActiveAdmin.load!
    ActiveAdmin.register(Category)
    ActiveAdmin.register(User)
    ActiveAdmin.register(Post){ belongs_to :user, :optional => true }
    reload_menus!
  end

  def reload_menus!
    ActiveAdmin.application.namespaces.values.each{|n| n.reset_menu! }
  end

  # Sometimes we need to reload the routes within
  # the application to test them out
  def reload_routes!
    Rails.application.reload_routes!
  end

  # Helper method to load resources and ensure that Active Admin is
  # setup with the new configurations.
  #
  # Eg:
  #   load_resources do
  #     ActiveAdmin.regiser(Post)
  #   end
  #
  def load_resources
    ActiveAdmin.unload!
    yield
    reload_menus!
    reload_routes!
  end

  # Sets up a describe block where you can render controller 
  # actions. Uses the Admin::PostsController as the subject
  # for the describe block
  def describe_with_render(*args, &block)
    describe *args do
      include RSpec::Rails::ControllerExampleGroup
      render_views  
      # metadata[:behaviour][:describes] = ActiveAdmin.namespaces[:admin].resources['Post'].controller
      module_eval &block
    end
  end

  def arbre(assigns = {}, helpers = mock_action_view, &block)
    Arbre::Context.new(assigns, helpers, &block)
  end

  def render_arbre_component(assigns = {}, helpers = mock_action_view, &block)
    arbre(assigns, helpers, &block).children.first
  end

  # Setup a describe block which uses capybara and rails integration
  # test methods.
  def describe_with_capybara(*args, &block)
    describe *args do
      include RSpec::Rails::IntegrationExampleGroup
      module_eval &block
    end
  end

  # Returns a fake action view instance to use with our renderers
  def mock_action_view(assigns = {})
    controller = ActionView::TestCase::TestController.new
    ActionView::Base.send :include, ActionView::Helpers
    ActionView::Base.send :include, ActiveAdmin::ViewHelpers
    ActionView::Base.send :include, Rails.application.routes.url_helpers
    ActionView::Base.new(ActionController::Base.view_paths, assigns, controller)
  end  
  alias_method :action_view, :mock_action_view

  # A mock resource to register
  class MockResource
  end

end

ENV['RAILS_ENV'] = 'test'
ENV['RAILS_ROOT'] = File.expand_path("../rails/rails-#{ENV['RAILS']}", __FILE__)

# Create the test app if it doesn't exists
unless File.exists?(ENV['RAILS_ROOT'])
  system 'rake setup'
end

# Ensure the Active Admin load path is happy
require 'rails'
require 'active_admin'
ActiveAdmin.application.load_paths = [ENV['RAILS_ROOT'] + "/app/admin"]

require ENV['RAILS_ROOT'] + '/config/environment'

require 'rspec/rails'

# Setup Some Admin stuff for us to play with
include ActiveAdminIntegrationSpecHelper
load_defaults!
reload_routes!

# Disabling authentication in specs so that we don't have to worry about
# it allover the place
ActiveAdmin.application.authentication_method = false
ActiveAdmin.application.current_user_method = false

# Don't add asset cache timestamps. Makes it easy to integration
# test for the presence of an asset file
ENV["RAILS_ASSET_ID"] = ''

RSpec.configure do |config|
  config.use_transactional_fixtures = true
  config.use_instantiated_fixtures = false
  config.include Devise::TestHelpers, :type => :controller
  config.render_views = false
end

# All RSpec configuration needs to happen before any examples
# or else it whines.
require 'integration_example_group'
RSpec.configure do |c|
  c.include RSpec::Rails::IntegrationExampleGroup, :example_group => { :file_path => /\bspec\/integration\// }
  c.include Devise::TestHelpers, :type => :controller
end

# Ensure this is defined for Ruby 1.8
module MiniTest; class Assertion < Exception; end; end

RSpec::Matchers.define :have_tag do |*args|

  match_unless_raises Test::Unit::AssertionFailedError do |response|
    tag = args.shift
    content = args.first.is_a?(Hash) ? nil : args.shift
    
    options = {
      :tag => tag.to_s
    }.merge(args[0] || {})
    
    options[:content] = content if content

    begin
      begin
        assert_tag(options)
      rescue NoMethodError
        # We are not in a controller, so let's do the checking ourselves
        doc = HTML::Document.new(response, false, false)
        tag = doc.find(options)
        assert tag, "expected tag, but no tag found matching #{options.inspect} in:\n#{response.inspect}"
      end
    # In Ruby 1.9, MiniTest::Assertion get's raised, so we'll
    # handle raising a Test::Unit::AssertionFailedError
    rescue MiniTest::Assertion => e
      raise Test::Unit::AssertionFailedError, e.message
    end
  end
end

# improve the performance of the specs suite by not logging anything
# see http://blog.plataformatec.com.br/2011/12/three-tips-to-improve-the-performance-of-your-test-suite/
Rails.logger.level = 4
$LOAD_PATH.unshift(File.dirname(__FILE__))
$LOAD_PATH << File.expand_path('../support', __FILE__)

ENV['BUNDLE_GEMFILE'] = File.expand_path('../../Gemfile', __FILE__)
require "bundler"
Bundler.setup

require 'detect_rails_version'
ENV['RAILS'] = detect_rails_version
# Detects the current version of Rails that is being used
#
#
unless defined? RAILS_VERSION_FILE
  RAILS_VERSION_FILE = File.expand_path("../../../.rails-version", __FILE__)
end

unless defined? TRAVIS_CONFIG
  require 'yaml'
  filename = File.expand_path("../../../.travis.yml", __FILE__)
  TRAVIS_CONFIG = YAML.load_file filename
  TRAVIS_RAILS_VERSIONS = TRAVIS_CONFIG['env'].grep(/RAILS=(.*)/){ $1 }.sort
end

unless defined? DEFAULT_RAILS_VERSION
  DEFAULT_RAILS_VERSION = TRAVIS_RAILS_VERSIONS.last
end

def detect_rails_version
  version = version_from_file || version_from_env || DEFAULT_RAILS_VERSION

  puts "Detected Rails: #{version}" if ENV['DEBUG']

  version
end

def version_from_file
  if File.exists?(RAILS_VERSION_FILE)
    version = File.read(RAILS_VERSION_FILE).chomp.strip
    version = nil if version == ""

    version
  end
end

def version_from_env
  ENV['RAILS']
end

def write_rails_version(version)
  File.open(RAILS_VERSION_FILE, "w+"){|f| f << version }
end
require 'action_dispatch'
require 'capybara/rails'
require 'capybara/dsl'

module RSpec
  module Rails
    module IntegrationExampleGroup
      extend ActiveSupport::Concern

      include ActionDispatch::Integration::Runner
      include RSpec::Rails::TestUnitAssertionAdapter
      include ActionDispatch::Assertions
      include Capybara::DSL
      include RSpec::Matchers

      def app
        ::Rails.application
      end

      def last_response
        page
      end

      included do
        before do
          @router = ::Rails.application.routes
        end
      end
    end
  end
end
# Rails template to build the sample app for specs

# Create a cucumber database and environment
copy_file File.expand_path('../templates/cucumber.rb', __FILE__), "config/environments/cucumber.rb"
copy_file File.expand_path('../templates/cucumber_with_reloading.rb', __FILE__), "config/environments/cucumber_with_reloading.rb"

gsub_file 'config/database.yml', /^test:.*\n/, "test: &test\n"
gsub_file 'config/database.yml', /\z/, "\ncucumber:\n  <<: *test\n  database: db/cucumber.sqlite3"
gsub_file 'config/database.yml', /\z/, "\ncucumber_with_reloading:\n  <<: *test\n  database: db/cucumber.sqlite3"

# Generate some test models
generate :model, "post title:string body:text published_at:datetime author_id:integer category_id:integer starred:boolean"
inject_into_file 'app/models/post.rb', "  belongs_to :author, :class_name => 'User'\n  belongs_to :category\n  accepts_nested_attributes_for :author\n", :after => "class Post < ActiveRecord::Base\n"

# We'll put this basic delegator in app/models in order to simplify auto-loading.
copy_file File.expand_path('../templates/post_decorator.rb', __FILE__), "app/models/post_decorator.rb"

# Rails 3.2.3 model generator declare attr_accessible
inject_into_file 'app/models/post.rb', "  attr_accessible :author\n", :before => "end" if Rails::VERSION::STRING >= '3.2'
generate :model, "user type:string first_name:string last_name:string username:string age:integer"
inject_into_file 'app/models/user.rb', "  has_many :posts, :foreign_key => 'author_id'\n", :after => "class User < ActiveRecord::Base\n"
generate :model, "publisher --migration=false --parent=User"
generate :model, 'category name:string description:text'
inject_into_file 'app/models/category.rb', "  has_many :posts\n  accepts_nested_attributes_for :posts\n", :after => "class Category < ActiveRecord::Base\n"
generate :model, 'store name:string'

# Generate a model with string ids
generate :model, "tag name:string"
gsub_file(Dir['db/migrate/*_create_tags.rb'][0], /\:tags\sdo\s.*/, ":tags, :id => false, :primary_key => :id do |t|\n\t\t\tt.string :id\n")
id_model_setup = <<-EOF
  self.primary_key = :id
  before_create :set_id
  
  private
  def set_id
    self.id = 8.times.inject("") { |s,e| s << (i = Kernel.rand(62); i += ((i < 10) ? 48 : ((i < 36) ? 55 : 61 ))).chr }
  end
EOF
inject_into_file 'app/models/tag.rb', id_model_setup, :after => "class Tag < ActiveRecord::Base\n"

if Rails::VERSION::MAJOR == 3 && Rails::VERSION::MINOR == 1 #Rails 3.1 Gotcha
  gsub_file 'app/models/tag.rb', /self\.primary_key.*$/, "define_attr_method :primary_key, :id"
end

# Configure default_url_options in test environment
inject_into_file "config/environments/test.rb", "  config.action_mailer.default_url_options = { :host => 'example.com' }\n", :after => "config.cache_classes = true\n"

# Add our local Active Admin to the load path
inject_into_file "config/environment.rb", "\n$LOAD_PATH.unshift('#{File.expand_path(File.join(File.dirname(__FILE__), '..', '..', 'lib'))}')\nrequire \"active_admin\"\n", :after => "require File.expand_path('../application', __FILE__)"

# Add some translations
append_file "config/locales/en.yml", File.read(File.expand_path('../templates/en.yml', __FILE__))

# Add predefined admin resources
directory File.expand_path('../templates/admin', __FILE__), "app/admin"

run "rm Gemfile"
run "rm -r test"
run "rm -r spec"

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

# we need this routing path, named "logout_path", for testing
route <<-EOS
  devise_scope :user do
    match '/admin/logout' => 'active_admin/devise/sessions#destroy', :as => :logout
  end
EOS

generate :'active_admin:install'

# Setup a root path for devise
route "root :to => 'admin/dashboard#index'"

rake "db:migrate"
rake "db:test:prepare"
run "/usr/bin/env RAILS_ENV=cucumber rake db:migrate"

# Setup parallel_tests
def setup_parallel_tests_database(after, force_insert_same_content = false)
  inject_into_file 'config/database.yml', "<%= ENV['TEST_ENV_NUMBER'] %>", :after => after, :force => force_insert_same_content
end

setup_parallel_tests_database "test.sqlite3"
setup_parallel_tests_database "cucumber.sqlite3", true

# Note: this is hack!
# Somehow, calling parallel_tests tasks from Rails generator using Thor does not work ...
# RAILS_ENV variable never makes it to parallel_tests tasks.
# We need to call these tasks in the after set up hook in order to creates cucumber DBs + run migrations on test & cucumber DBs
create_file 'lib/tasks/parallel.rake' do
  <<'RAKE'
namespace :parallel do
  def run_in_parallel(cmd, options)
    count = "-n #{options[:count]}" if options[:count]
    executable = 'parallel_test'
    command = "#{executable} --exec '#{cmd}' #{count} #{'--non-parallel' if options[:non_parallel]}"
    abort unless system(command)
  end

  desc "create cucumber databases via db:create --> parallel:create_cucumber_db[num_cpus]"
  task :create_cucumber_db, :count do |t, args|
    run_in_parallel("rake db:create RAILS_ENV=cucumber", args)
  end

  desc "load dumped schema for cucumber databases"
  task :load_schema_cucumber_db, :count do |t,args|
    run_in_parallel("rake db:schema:load RAILS_ENV=cucumber", args)
  end
end
RAKE
end
# Use the default
apply File.expand_path("../rails_template.rb", __FILE__)

# Register Active Admin controllers
%w{ Post User Category }.each do |type|
  generate :'active_admin:resource', type
end

scopes = <<-EOF
  scope :all, :default => true

  scope :drafts do |posts|
    posts.where(["published_at IS NULL"])
  end

  scope :scheduled do |posts|
    posts.where(["posts.published_at IS NOT NULL AND posts.published_at > ?", Time.now.utc])
  end

  scope :published do |posts|
    posts.where(["posts.published_at IS NOT NULL AND posts.published_at < ?", Time.now.utc])
  end

  scope :my_posts do |posts|
    posts.where(:author_id => current_admin_user.id)
  end
EOF
inject_into_file 'app/admin/posts.rb', scopes , :after => "ActiveAdmin.register Post do\n"

# Setup some default data
append_file "db/seeds.rb", <<-EOF
  users = ["Jimi Hendrix", "Jimmy Page", "Yngwie Malmsteen", "Eric Clapton", "Kirk Hammett"].collect do |name|
    first, last = name.split(" ")
    User.create!  :first_name => first,
                  :last_name => last,
                  :username => [first,last].join('-').downcase,
                  :age => rand(80)
  end

  categories = ["Rock", "Pop Rock", "Alt-Country", "Blues", "Dub-Step"].collect do |name|
    Category.create! :name => name
  end

  published_at_values = [Time.now.utc - 5.days, Time.now.utc - 1.day, nil, Time.now.utc + 3.days]

  1_000.times do |i|
    user = users[i % users.size]
    cat = categories[i % categories.size]
    published_at = published_at_values[i % published_at_values.size]
    Post.create :title => "Blog Post \#{i}",
                :body => "Blog post \#{i} is written by \#{user.username} about \#{cat.name}",
                :category => cat,
                :published_at => published_at,
                :author => user,
                :starred => true
  end
EOF

rake 'db:seed'
ActiveAdmin.register Store
require File.expand_path('config/environments/test', Rails.root)

# rails/railties/lib/rails/test_help.rb aborts if the environment is not 'test'. (Rails 3.0.0.beta3)
# We can't run Cucumber/RSpec/Test_Unit tests in different environments then.
#
# For now, I patch StringInquirer so that Rails.env.test? returns true when Rails.env is 'test' or 'cucumber'
#
# https://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/4458-rails-should-allow-test-to-run-in-cucumber-environment
module ActiveSupport
  class StringInquirer < String
    def method_missing(method_name, *arguments)
      if method_name.to_s[-1,1] == "?"
        test_string = method_name.to_s[0..-2]
        if test_string == 'test'
          self == 'test' or self == 'cucumber'
        else
          self == test_string
        end
      else
        super
      end
    end
  end
end
require File.expand_path('config/environments/cucumber', Rails.root)

Rails.application.class.configure do
  config.cache_classes = false
end
# Minimal example of a decorator
require_dependency 'post'

# DelegateClass(Post) does not delegate attribute methods
# in some environments:
# http://travis-ci.org/#!/gregbell/active_admin/jobs/2021466
#
class PostDecorator < SimpleDelegator
  delegate :id, :to => :__getobj__

  def self.decorate(object)
    new(object)
  end

  def self.decorate_collection(collection)
    DecoratedEnumerableProxy.new(collection)
  end

  def self.model_name
    ActiveModel::Name.new Post
  end

  def decorator_method
    'A method only available on the decorator'
  end

  # Minimal example of decorating a collection.
  # A full example can be found in the draper project:
  # https://github.com/jcasimir/draper/blob/master/lib/draper/decorated_enumerable_proxy.rb
  class DecoratedEnumerableProxy < DelegateClass(ActiveRecord::Relation)
    include Enumerable

    delegate :as_json, :collect, :map, :each, :[], :all?, :include?, :first, :last, :shift, :to => :decorated_collection

    def klass
      PostDecorator
    end

    def wrapped_collection
      __getobj__
    end

    def decorated_collection
      @decorated_collection ||= wrapped_collection.collect { |member| klass.decorate(member) }
    end
    alias_method :to_ary, :decorated_collection

    def each(&blk)
      to_ary.each(&blk)
    end
  end
end

require 'spec_helper'

require 'active_admin/abstract_view_factory'

describe ActiveAdmin::AbstractViewFactory do
  
  let(:view_factory){ ActiveAdmin::AbstractViewFactory.new }
  let(:mock_view){ Class.new }

  describe "registering a new view key" do
    before do
      view_factory.register :my_new_view_class => mock_view
    end

    it "should respond to :my_new_view_class" do
      view_factory.respond_to?(:my_new_view_class)
    end

    it "should respond to :my_new_view_class=" do
      view_factory.respond_to?(:my_new_view_class=)
    end

    it "should generate a getter method" do
      view_factory.my_new_view_class.should == mock_view
    end

    it "should be settable view a setter method" do
      view_factory.my_new_view_class = "Some Obj"
      view_factory.my_new_view_class.should == "Some Obj"
    end
  end

  describe "array syntax access" do
    before do
      view_factory.register :my_new_view_class => mock_view
    end

    it "should be available through array syntax" do
      view_factory[:my_new_view_class].should == mock_view
    end

    it "should be settable through array syntax" do
      view_factory[:my_new_view_class] = "My New View Class"
      view_factory[:my_new_view_class].should == "My New View Class"
    end
  end

  describe "registering default views" do
    before do
      ActiveAdmin::AbstractViewFactory.register :my_default_view_class => mock_view
    end
    it "should generate a getter method" do
      view_factory.my_default_view_class.should == mock_view
    end
    it "should be settable view a setter method and not change default" do
      view_factory.my_default_view_class = "Some Obj"
      view_factory.my_default_view_class.should == "Some Obj"
      view_factory.default_for(:my_default_view_class).should == mock_view
    end
  end

  describe "subclassing the ViewFactory" do
    let(:subclass) do
      ActiveAdmin::AbstractViewFactory.register :my_subclassed_view => "From Parent"
      Class.new(ActiveAdmin::AbstractViewFactory) do
        def my_subclassed_view
          "From Subclass"
        end
      end
    end

    it "should use the subclass implementation" do
      factory = subclass.new
      factory.my_subclassed_view.should == "From Subclass"
    end
  end


end
require 'spec_helper' 

describe 'defining new actions from registration blocks' do

  let(:controller){ Admin::PostsController }

  describe "generating a new member action" do
    before do
      action!
      reload_routes!
    end

    after(:each) do
      controller.clear_member_actions!
    end
    
    context "with a block" do
      let(:action!) do
        ActiveAdmin.register Post do
          member_action :comment do
            # Do nothing
          end
        end
      end
        
      it "should create a new public instance method" do
        controller.public_instance_methods.collect(&:to_s).should include("comment")
      end
      it "should add itself to the member actions config" do
        controller.active_admin_config.member_actions.size.should == 1
      end
      it "should create a new named route" do
        Rails.application.routes.url_helpers.methods.collect(&:to_s).should include("comment_admin_post_path")
      end
    end

    context "without a block" do
      let(:action!) do 
        ActiveAdmin.register Post do
          member_action :comment
        end
      end
      it "should still generate a new empty action" do
        controller.public_instance_methods.collect(&:to_s).should include("comment")
      end
    end

    context "with :title" do
      let(:action!) do 
        ActiveAdmin.register Post do
          member_action :comment, :title => "My Awesome Comment"
        end
      end

      subject { find_before_filter controller, :comment }

      it { should set_page_title_to "My Awesome Comment" }
    end
  end

  describe "generate a new collection action" do
    before do
      action!
      reload_routes!
    end
    after(:each) do
      controller.clear_collection_actions!
    end

    context "with a block" do
      let(:action!) do
        ActiveAdmin.register Post do
          collection_action :comments do
            # Do nothing
          end
        end
      end
      it "should create a new public instance method" do
        controller.public_instance_methods.collect(&:to_s).should include("comments")
      end
      it "should add itself to the member actions config" do
        controller.active_admin_config.collection_actions.size.should == 1
      end
      it "should create a new named route" do
        Rails.application.routes.url_helpers.methods.collect(&:to_s).should include("comments_admin_posts_path")
      end
    end
    context "without a block" do
      let(:action!) do 
        ActiveAdmin.register Post do
          collection_action :comments
        end
      end
      it "should still generate a new empty action" do
        controller.public_instance_methods.collect(&:to_s).should include("comments")
      end
    end
    context "with :title" do
      let(:action!) do 
        ActiveAdmin.register Post do
          collection_action :comments, :title => "My Awesome Comments"
        end
      end

      subject { find_before_filter controller, :comments }

      it { should set_page_title_to "My Awesome Comments" }
    end
  end

  def find_before_filter(controller, action)
    controller._process_action_callbacks.detect { |f| f.kind == :before && f.options[:only] == [action] }
  end

  RSpec::Matchers.define :set_page_title_to do |expected|
    match do |filter|
      filter.raw_filter.call
      @actual = filter.klass.instance_variable_get(:@page_title)
      @actual == expected
    end

    failure_message_for_should do |filter|
      message = "expected before_filter to set the @page_title to '#{expected}', but was '#{@actual}'"
    end
  end
end
require 'spec_helper'

describe ActiveAdmin do
  describe "#default_namespace" do
    it "should delegate to ActiveAdmin.application" do
      ActiveAdmin.application.should_receive(:default_namespace)

      ActiveAdmin.default_namespace
    end

    it "should be deprecated" do
      ActiveAdmin::Deprecation.should_receive(:warn)

      ActiveAdmin.default_namespace
    end
  end

  %w(register register_page unload! load! routes).each do |method|
    it "delegates ##{method} to application" do
      ActiveAdmin.application.should_receive(method)

      ActiveAdmin.send(method)
    end
  end
end
require 'spec_helper'
require 'fileutils'

describe ActiveAdmin::Application do

  let(:application) do
    ActiveAdmin::Application.new.tap do |app|
      # Manually override the load paths becuase RSpec messes these up
      app.load_paths = [File.expand_path('app/admin', Rails.root)]
    end
  end

  it "should have a default load path of ['app/admin']" do
    application.load_paths.should == [File.expand_path('app/admin', Rails.root)]
  end

  it "should remove app/admin from the autoload path to remove the possibility of conflicts" do
    ActiveSupport::Dependencies.autoload_paths.should_not include(File.join(Rails.root, "app/admin"))
  end

  it "should remove app/admin from the eager load paths (Active Admin deals with loading)" do
    Rails.application.config.eager_load_paths.should_not include(File.join(Rails.root, "app/admin"))
  end

  it "should store the site's title" do
    application.site_title.should == ""
  end

  it "should set the site title" do
    application.site_title = "New Title"
    application.site_title.should == "New Title"
  end

  it "should store the site's title link" do
    application.site_title_link.should == ""
  end

  it "should set the site's title link" do
    application.site_title_link = "http://www.mygreatsite.com"
    application.site_title_link.should == "http://www.mygreatsite.com"
  end

  it "should store the site's title image" do
    application.site_title_image.should == ""
  end

  it "should set the site's title image" do
    application.site_title_image = "http://railscasts.com/assets/episodes/stills/284-active-admin.png?1316476106"
    application.site_title_image.should == "http://railscasts.com/assets/episodes/stills/284-active-admin.png?1316476106"
  end

  it "should have a view factory" do
    application.view_factory.should be_an_instance_of(ActiveAdmin::ViewFactory)
  end

  it "should have deprecated admin notes by default" do
    application.admin_notes.should be_nil
  end

  it "should allow comments by default" do
    application.allow_comments.should == true
  end

  describe "authentication settings" do

    it "should have no default current_user_method" do
      application.current_user_method.should == false
    end

    it "should have no default authentication method" do
      application.authentication_method.should == false
    end

    it "should have a logout link path (Devise's default)" do
      application.logout_link_path.should == :destroy_admin_user_session_path
    end

    it "should have a logout link method (Devise's default)" do
      application.logout_link_method.should == :get
    end
  end

  describe "inheritable settings" do
    it "should set csv_options" do
      application.csv_options.should == {}
    end

    context "when deprecated" do
      it "should set and warn csv_column_separator" do
        ActiveAdmin::Deprecation.should_receive(:warn)
        application.csv_column_separator.should == ','
      end
    end
  end

  describe "files in load path" do
    it "should load files in the first level directory" do
      application.files.should include(File.expand_path("app/admin/dashboard.rb", Rails.root))
    end

    it "should load files from subdirectories" do
      FileUtils.mkdir_p(File.expand_path("app/admin/public", Rails.root))
      test_file = File.expand_path("app/admin/public/posts.rb", Rails.root)
      FileUtils.touch(test_file)
      application.files.should include(test_file)
    end
  end

  describe "#namespace" do

    it "should yield a new namespace" do
      application.namespace :new_namespace do |ns|
        ns.name.should == :new_namespace
      end
    end

    it "should return an instantiated namespace" do
      admin = application.namespace :admin
      admin.should == application.namespaces[:admin]
    end

    it "should yield an existing namespace" do
      expect {
        application.namespace :admin do |ns|
          ns.should == application.namespaces[:admin]
          raise "found"
        end
      }.to raise_error("found")
    end
  end

  describe "#register_page" do
    it "finds or create the namespace and register the page to it" do
      namespace = mock
      application.should_receive(:namespace).with("public").and_return namespace
      namespace.should_receive(:register_page).with("My Page", {:namespace => "public"})

      application.register_page("My Page", :namespace => "public")
    end
  end

end
require 'spec_helper' 

module MockRegistration
  extend ActiveAdmin::AssetRegistration
end

describe ActiveAdmin::AssetRegistration do

  before do
    MockRegistration.clear_stylesheets!
    MockRegistration.clear_javascripts!
  end

  it "should register a stylesheet file" do
    MockRegistration.register_stylesheet "active_admin.css"
    MockRegistration.stylesheets.length.should == 1
    MockRegistration.stylesheets.first.path.should == "active_admin.css"
  end

  it "should clear all existing stylesheets" do
    MockRegistration.register_stylesheet "active_admin.css"
    MockRegistration.stylesheets.length.should == 1
    MockRegistration.clear_stylesheets!
    MockRegistration.stylesheets.length.should == 0
  end
  
  it "should allow media option when registering stylesheet" do
    MockRegistration.register_stylesheet "active_admin.css", :media => :print
    MockRegistration.stylesheets.first.options[:media].should == :print
  end

  it "should register a javascript file" do
    MockRegistration.register_javascript "active_admin.js"
    MockRegistration.javascripts.should == ["active_admin.js"]
  end

  it "should clear all existing javascripts" do
    MockRegistration.register_javascript "active_admin.js"
    MockRegistration.javascripts.should == ["active_admin.js"]    
    MockRegistration.clear_javascripts!
    MockRegistration.javascripts.should == []
  end
end
require 'spec_helper'

describe ActiveAdmin::AuthorizationAdapter do

  let(:adapter) { ActiveAdmin::AuthorizationAdapter.new(stub, stub) }

  describe "#authorized?" do

    it "should always return true" do
      adapter.authorized?(:read, "Resource").should == true
    end

  end

  describe "#scope_collection" do

    it "should return the collection unscoped" do
      collection = stub
      adapter.scope_collection(collection).should == collection
    end

  end

  describe "using #normalized in a subclass" do

    let(:auth_class) do
      Class.new(ActiveAdmin::AuthorizationAdapter) do 

        def authorized?(action, subject = nil)
          case subject
          when normalized(String)
            true
          else
            false
          end
        end

      end
    end

    let(:adapter) { auth_class.new(stub, stub) }

    it "should match agains a class" do
      adapter.authorized?(:read, String).should == true
    end

    it 'should match against an instance' do
      adapter.authorized?(:read, "String").should == true
    end

    it 'should not match a different class' do
      adapter.authorized?(:read, Hash).should == false
    end

    it 'should not match a different instance' do
      adapter.authorized?(:read, {}).should == false
    end

  end

end
require 'spec_helper'

describe Admin::PostsController, "Controller Authorization", :type => :controller do

  let(:user) { AdminUser.create!(:email => "example@admin.com", :password => "password", :password_confirmation => "password") }
  let(:app) { ActiveAdmin.application }
  let(:authorization){ controller.send(:active_admin_authorization) }

  before do
  # TODO: Get these tests passing...
    pending

    load_defaults!
    @request.env["devise.mapping"] = Devise.mappings[:admin]
    @resource.namespace.current_user_method = :current_admin_user

    sign_in(user)
  end

  it "should authorize the index action" do
    authorization.should_receive(:authorized?).
      with(ActiveAdmin::Authorization::READ, Post).
      and_return(true)

    get :index
  end

  it "should authorize the new action" do
    authorization.should_receive(:authorized?).
      with(ActiveAdmin::Authorization::CREATE, an_instance_of(Post)).
      and_return(true)

    get :new
  end

  it "should authorize the create action with the new resource" do
    mock_post = mock("Post", :save => true, :errors => [])
    Post.should_receive(:new).at_least(:once).and_return(mock_post)

    authorization.should_receive(:authorized?).
      with(ActiveAdmin::Authorization::CREATE, mock_post).
      and_return(true)

    post :create
  end

end
require 'spec_helper'

class AutoLinkMockResource
  attr_accessor :namespace
  def initialize(namespace)
    @namespace = namespace
  end
end

describe "auto linking resources" do
  include ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  include ActiveAdmin::ViewHelpers::AutoLinkHelper
  include ActiveAdmin::ViewHelpers::DisplayHelper

  let(:active_admin_config) { AutoLinkMockResource.new(namespace) }
  let(:active_admin_namespace){ ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin) }
  let(:post){ Post.create! :title => "Hello World" }

  def admin_post_path(post)
    "/admin/posts/#{post.id}"
  end

  context "when the resource is not registered" do
    it "should return the display name of the object" do
      auto_link(post).should == "Hello World"
    end
  end

  context "when the resource is registered" do
    before do
      active_admin_namespace.register Post
    end
    it "should return a link with the display name of the object" do
      self.should_receive(:link_to).with("Hello World", admin_post_path(post))
      auto_link(post)
    end
  end

end
require 'spec_helper'

describe ActiveAdmin::BaseController do
  let(:controller) { ActiveAdmin::BaseController.new }

end
require 'spec_helper'

describe ActiveAdmin::BatchActions::ResourceExtension do

  let(:resource) do
    namespace = ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin)
    namespace.batch_actions = true
    namespace.register(Post)
  end
  
  describe "default action" do

    it "should have the default action by default" do
      resource.batch_actions.size.should == 1 and resource.batch_actions.first.sym == :destroy
    end

  end
  
  describe "adding a new batch action" do

    before do
      resource.clear_batch_actions!
      resource.add_batch_action :flag, "Flag" do
        # Empty
      end
    end

    it "should add an batch action" do
      resource.batch_actions.size.should == 1
    end

    it "should store an instance of BatchAction" do
      resource.batch_actions.first.should be_an_instance_of(ActiveAdmin::BatchAction)
    end

    it "should store the block in the batch action" do
      resource.batch_actions.first.block.should_not be_nil
    end

  end
  
  describe "removing batch action" do
    
    before do
      resource.remove_batch_action :destroy
    end
    
    it "should allow for batch action removal" do
      resource.batch_actions.size.should == 0
    end
    
  end

  describe "#batch_action_path" do

    it "returns the path as a symbol" do
      resource.batch_action_path.should == "/admin/posts/batch_action"
    end

  end

  describe "#display_if_block" do

    it "should return true by default" do
      action = ActiveAdmin::BatchAction.new :default, "Default"
      action.display_if_block.call.should == true
    end

    it "should return the :if block if set" do
      action = ActiveAdmin::BatchAction.new :with_block, "With Block", :if => proc { false } 
      action.display_if_block.call.should == false
    end

  end
  
  describe "batch action priority" do
    
    it "should have a default priority" do
      action = ActiveAdmin::BatchAction.new :default, "Default"
      action.priority.should == 10
    end
    
    it "should correctly order two actions" do
      priority_one = ActiveAdmin::BatchAction.new :one, "One", :priority => 1
      priority_ten = ActiveAdmin::BatchAction.new :ten, "Ten", :priority => 10
      priority_one.should be < priority_ten
    end
    
  end

end
require 'spec_helper'

describe "Batch Actions Settings" do
  let(:app) { ActiveAdmin::Application.new }
  let(:ns) { ActiveAdmin::Namespace.new(app, "Admin") }
  let(:post_resource) { ns.register Post }

  it "should be disabled globally by default" do
    # Note: the default initializer would set it to true

    app.batch_actions.should be_false
    ns.batch_actions.should be_false
    post_resource.batch_actions_enabled?.should be_false
  end

  it "should be settable to true" do
    app.batch_actions = true
    app.batch_actions.should == true
  end

  it "should be an inheritable_setting" do
    app.batch_actions = true
    ns.batch_actions.should == true
  end

  it "should be settable at the namespace level" do
    app.batch_actions = true
    ns.batch_actions = false

    app.batch_actions.should == true
    ns.batch_actions.should == false
  end

  it "should be settable at the resource level" do
    post_resource.batch_actions_enabled?.should == false
    post_resource.batch_actions = true
    post_resource.batch_actions_enabled?.should == true
  end

  it "should inherit the setting on the resource from the namespace" do
    ns.batch_actions = false
    post_resource.batch_actions_enabled?.should == false
    post_resource.batch_actions.should be_empty

    post_resource.batch_actions = true
    post_resource.batch_actions_enabled?.should == true
    post_resource.batch_actions.should_not be_empty
  end

  it "should inherit the setting from the namespace when set to nil" do
    ns.batch_actions = true

    post_resource.batch_actions = true
    post_resource.batch_actions_enabled?.should == true
    post_resource.batch_actions.should_not be_empty

    post_resource.batch_actions = nil
    post_resource.batch_actions_enabled?.should == true # inherited from namespace
    post_resource.batch_actions.should_not be_empty
  end
end
require 'spec_helper' 

describe ActiveAdmin::Resource::BelongsTo do


  let(:application){ ActiveAdmin::Application.new }
  let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }
  let(:post){ namespace.register(Post) }
  let(:belongs_to){ ActiveAdmin::Resource::BelongsTo.new(post, :user) }

  it "should have an owner" do
    belongs_to.owner.should == post
  end

  it "should have a namespace" do
    belongs_to.namespace.should == namespace
  end

  describe "finding the target" do
    context "when the resource has been registered" do
      let(:user){ namespace.register(User) }
      before { user } # Ensure user is registered

      it "should return the target resource" do
        belongs_to.target.should == user
      end
    end

    context "when the resource has not been registered" do
      it "should raise a ActiveAdmin::BelongsTo::TargetNotFound" do
        lambda {
          belongs_to.target
        }.should raise_error(ActiveAdmin::Resource::BelongsTo::TargetNotFound)
      end
    end
  end

  it "should be optional" do
    belongs_to = ActiveAdmin::Resource::BelongsTo.new post, :user, :optional => true
    belongs_to.should be_optional
  end
end
require 'spec_helper'

describe "Breadcrumbs" do

  include ActiveAdmin::ViewHelpers

  describe "generating a trail from paths" do

    # Mock our params
    def params; {}; end
    # Mock link to and return a hash
    def link_to(name, url); {:name => name, :path => url}; end

    let(:trail) { breadcrumb_links(path) }

    context "when request '/admin'" do
      let(:path){ "/admin" }

      it "should not have any items" do
        trail.size.should == 0
      end
    end

    context "when path '/admin/posts'" do
      let(:path) { "/admin/posts" }

      it "should have one item" do
        trail.size.should == 1
      end
      it "should have a link to /admin" do
        trail[0][:name].should == "Admin"
        trail[0][:path].should == "/admin"
      end
    end

    context "when path '/admin/posts/1'" do
      let(:path) { "/admin/posts/1" }

      it "should have 2 items" do
        trail.size.should == 2
      end
      it "should have a link to /admin" do
        trail[0][:name].should == "Admin"
        trail[0][:path].should == "/admin"
      end
      it "should have a link to /admin/posts" do
        trail[1][:name].should == "Posts"
        trail[1][:path].should == "/admin/posts"
      end
    end

    context "when path '/admin/posts/1/comments'" do
      let(:path) { "/admin/posts/1/comments" }

      it "should have 3 items" do
        trail.size.should == 3
      end
      it "should have a link to /admin" do
        trail[0][:name].should == "Admin"
        trail[0][:path].should == "/admin"
      end
      it "should have a link to /admin/posts" do
        trail[1][:name].should == "Posts"
        trail[1][:path].should == "/admin/posts"
      end

      context "when Post.find(1) doesn't exist" do
        it "should have a link to /admin/posts/1" do
          trail[2][:name].should == "1"
          trail[2][:path].should == "/admin/posts/1"
        end
      end

      context "when Post.find(1) does exist" do
        before do
          Post.stub!(:find_by_id).and_return{ mock(:display_name => "Hello World") }
        end
        it "should have a link to /admin/posts/1 using display name" do
          trail[2][:name].should == "Hello World"
          trail[2][:path].should == "/admin/posts/1"
        end
      end
    end

    context "when path '/admin/posts/4e24d6249ccf967313000000/comments'" do
      let(:path) { "/admin/posts/4e24d6249ccf967313000000/comments" }

      it "should have 3 items" do
        trail.size.should == 3
      end
      it "should have a link to /admin" do
        trail[0][:name].should == "Admin"
        trail[0][:path].should == "/admin"
      end
      it "should have a link to /admin/posts" do
        trail[1][:name].should == "Posts"
        trail[1][:path].should == "/admin/posts"
      end

      context "when Post.find(4e24d6249ccf967313000000) doesn't exist" do
        it "should have a link to /admin/posts/4e24d6249ccf967313000000" do
          trail[2][:name].should == "4e24d6249ccf967313000000"
          trail[2][:path].should == "/admin/posts/4e24d6249ccf967313000000"
        end
      end

      context "when Post.find(4e24d6249ccf967313000000) does exist" do
        before do
          Post.stub!(:find_by_id).with('4e24d6249ccf967313000000').and_return{ mock(:display_name => "Hello World") }
        end
        it "should have a link to /admin/posts/4e24d6249ccf967313000000 using display name" do
          trail[2][:name].should == "Hello World"
          trail[2][:path].should == "/admin/posts/4e24d6249ccf967313000000"
        end
      end
    end

    context "when path '/admin/posts/1/coments/1'" do
      let(:path) { "/admin/posts/1/comments/1" }

      it "should have 4 items" do
        trail.size.should == 4
      end
      it "should have a link to /admin" do
        trail[0][:name].should == "Admin"
        trail[0][:path].should == "/admin"
      end
      it "should have a link to /admin/posts" do
        trail[1][:name].should == "Posts"
        trail[1][:path].should == "/admin/posts"
      end
      it "should have a link to /admin/posts/1" do
        trail[2][:name].should == "1"
        trail[2][:path].should == "/admin/posts/1"
      end
      it "should have a link to /admin/posts/1/comments" do
        trail[3][:name].should == "Comments"
        trail[3][:path].should == "/admin/posts/1/comments"
      end
    end

  end
end
require 'spec_helper'

describe ActiveAdmin::CanCanAdapter do

  describe "full integration" do

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ ActiveAdmin::Namespace.new(application, "Admin") }
    let(:resource){ namespace.register(Post) }

    let :mock_ability_class do
      Class.new do
        include CanCan::Ability

        def initialize(user)
          can :read, Post
          cannot :update, Post
        end

      end
    end

    it "should initialize the ability stored in the namespace configuration" do
      namespace.authorization_adapter = ActiveAdmin::CanCanAdapter
      namespace.cancan_ability_class = mock_ability_class

      auth = namespace.authorization_adapter.new(resource, mock)

      auth.authorized?(:read, Post).should == true
      auth.authorized?(:update, Post).should == false
    end

  end

end
require 'spec_helper'

describe "Comments" do
  let(:application){ ActiveAdmin::Application.new }

  describe ActiveAdmin::Comment do
    subject { ActiveAdmin::Comment }

    describe "Associations and Validations" do
      before do
        pending "This is not passing on Travis-CI. See Issue #1273."
      end

      it { should belong_to :resource }
      it { should belong_to :author }

      it { should validate_presence_of :resource }
      it { should validate_presence_of :body }
      it { should validate_presence_of :namespace }
    end

    describe ".find_for_resource_in_namespace" do
      let(:post){ Post.create!(:title => "Hello World") }
      let(:namespace_name){ "admin" }

      before do
        @comment = ActiveAdmin::Comment.create! :resource => post,
                                                :body => "A Comment",
                                                :namespace => namespace_name
      end

      it "should return a comment for the resource in the same namespace" do
        ActiveAdmin::Comment.find_for_resource_in_namespace(post, namespace_name).should == [@comment]
      end

      it "should not return a comment for the same resource in a different namespace" do
        ActiveAdmin::Comment.find_for_resource_in_namespace(post, 'public').should == []
      end

      it "should not return a comment for a different resource" do
        another_post = Post.create! :title => "Another Hello World"
        ActiveAdmin::Comment.find_for_resource_in_namespace(another_post, namespace_name).should == []
      end
    end
    
    describe ".resource_id_cast" do
      let(:post) { Post.create!(:title => "Testing.") }
      let(:namespace_name) { "admin" }
      
      it "should cast resource_id as string" do
        comment = ActiveAdmin::Comment.create! :resource => post,
                                                :body => "Another Comment",
                                                :namespace => namespace_name
        ActiveAdmin::Comment.resource_id_cast(comment).class.should eql String
      end
    end

    describe ".resource_id_type" do
      it "should be :string" do
        ActiveAdmin::Comment.resource_id_type.should eql :string
      end
    end
    
    describe "Commenting on resource with string id" do
      let(:tag){ Tag.create!(:name => "cooltags") }
      let(:namespace_name){ "admin" }
      
      it "should allow commenting" do
        comment = ActiveAdmin::Comment.create! :resource => tag, 
                                                :body => "Another Comment", 
                                                :namespace => namespace_name
                                                
        ActiveAdmin::Comment.find_for_resource_in_namespace(tag, namespace_name).should == [comment]
      end
    end
  end

  describe ActiveAdmin::Comments::NamespaceHelper do
    describe "#comments?" do

      it "should have comments when the namespace allows comments" do
        ns = ActiveAdmin::Namespace.new(application, :admin)
        ns.allow_comments = true
        ns.comments?.should be_true
      end

      it "should not have comments when the namespace does not allow comments" do
        ns = ActiveAdmin::Namespace.new(application, :admin)
        ns.allow_comments = false
        ns.comments?.should be_false
      end

      it "should have comments when the application allows comments and no local namespace config" do
        application.allow_comments = true
        ns = ActiveAdmin::Namespace.new(application, :admin)
        ns.comments?.should be_true
      end

      it "should not have comments when the application does not allow commands and no local namespace config" do
        application.allow_comments = false
        ns = ActiveAdmin::Namespace.new(application, :admin)
        ns.comments?.should be_false
      end

    end
  end

  describe ActiveAdmin::Comments::ResourceHelper do
    it "should add an attr_accessor :comments to ActiveAdmin::Resource" do
      ns = ActiveAdmin::Namespace.new(application, :admin)
      resource = ActiveAdmin::Resource.new(ns, Post)
      resource.comments.should be_nil
      resource.comments = true
      resource.comments.should be_true
    end

    it "should not have comment if set to false by in allow_comments_in" do
      ns = ActiveAdmin::Namespace.new(application, application.default_namespace)
      resource = ActiveAdmin::Resource.new(ns, Post)
      resource.comments = false
      resource.comments?.should be_false
    end
  end
end
require 'spec_helper'

class MockComponentClass < ActiveAdmin::Component; end

describe ActiveAdmin::Component do

  let(:component_class){ MockComponentClass }
  let(:component){ component_class.new }

  it "should be a subclass of an html div" do
    ActiveAdmin::Component.ancestors.should include(Arbre::HTML::Div)
  end

  it "should render to a div, even as a subclass" do
    component.tag_name.should == 'div'
  end

end
shared_examples_for "ActiveAdmin::Config" do
  describe "namespace" do
    it "should return the namespace" do
      config.namespace.should == namespace
    end
  end

  describe "page_presenters" do
    it "should return an empty hash by default" do
      config.page_presenters.should == {}
    end
  end

  it { respond_to :controller_name }
  it { respond_to :controller }
  it { respond_to :route_prefix }
  it { respond_to :route_collection_path }
  it { respond_to :comments? }
  it { respond_to :belongs_to? }
  it { respond_to :action_items? }
  it { respond_to :sidebar_sections? }

  describe "Naming" do
    it "implements #resource_label" do
      expect { config.resource_label }.should_not raise_error
    end

    it "implements #plural_resource_label" do
      expect { config.plural_resource_label }.should_not raise_error
    end
  end

  describe "Menu" do
    describe "#menu_item_options" do

      it "initializes a new menu item with defaults" do
          config.menu_item_options[:label].call.should == config.plural_resource_label
      end

      it "initialize a new menu item with custom options" do
        config.menu_item_options = { :label => "Hello" }
        config.menu_item_options[:label].should == "Hello"
      end

    end

    describe "#include_in_menu?" do
      it "should be included in menu by default" do
        config.include_in_menu?.should == true
      end

      it "should not be included in menu when menu set to false" do
        config.menu_item_options = false
        config.include_in_menu?.should == false
      end
    end

  end
end
require 'spec_helper' 

describe ActiveAdmin, "filters" do
  let(:application){ ActiveAdmin::Application.new }

  describe "before filters" do
    it "should add a new before filter to ActiveAdmin::BaseController" do
      ActiveAdmin::BaseController.should_receive(:before_filter).and_return(true)
      application.before_filter :my_filter, :only => :show
    end
  end
  
  describe "skip before filters" do
    it "should add a new skip before filter to ActiveAdmin::BaseController" do
      ActiveAdmin::BaseController.should_receive(:skip_before_filter).and_return(true)
      application.skip_before_filter :my_filter, :only => :show
    end
  end

  describe "after filters" do
    it "should add a new after filter to ActiveAdmin::BaseController" do
      ActiveAdmin::BaseController.should_receive(:after_filter).and_return(true)
      application.after_filter :my_filter, :only => :show
    end
  end

  describe "around filters" do
    it "should add a new around filter to ActiveAdmin::BaseController" do
      ActiveAdmin::BaseController.should_receive(:around_filter).and_return(true)
      application.around_filter :my_filter, :only => :show
    end
  end

end
require 'spec_helper'

describe ActiveAdmin::CSVBuilder do

  describe '.default_for_resource using Post' do
    let(:csv_builder) { ActiveAdmin::CSVBuilder.default_for_resource(Post) }

    it "should return a default csv_builder for Post" do
      csv_builder.should be_a(ActiveAdmin::CSVBuilder)
    end

    specify "the first column should be Id" do
      csv_builder.columns.first.name.should == 'Id'
      csv_builder.columns.first.data.should == :id
    end

    specify "the following columns should be content_column" do
      csv_builder.columns[1..-1].each_with_index do |column, index|
        column.name.should == Post.content_columns[index].name.titleize
        column.data.should == Post.content_columns[index].name.to_sym
      end
    end
  end

  context 'when empty' do
    let(:builder){ ActiveAdmin::CSVBuilder.new }

    it "should have no columns" do
      builder.columns.should == []
    end
  end

  context "with a symbol column (:title)" do
    let(:builder) do
      ActiveAdmin::CSVBuilder.new do
        column :title
      end
    end

    it "should have one column" do
      builder.columns.size.should == 1
    end

    describe "the column" do
      let(:column){ builder.columns.first }

      it "should have a name of 'Title'" do
        column.name.should == "Title"
      end

      it "should have the data :title" do
        column.data.should == :title
      end
    end
  end

  context "with a block and title" do
    let(:builder) do
      ActiveAdmin::CSVBuilder.new do
        column "My title" do
          # nothing
        end
      end
    end

    it "should have one column" do
      builder.columns.size.should == 1
    end

    describe "the column" do
      let(:column){ builder.columns.first }

      it "should have a name of 'My title'" do
        column.name.should == "My title"
      end

      it "should have the data :title" do
        column.data.should be_an_instance_of(Proc)
      end
    end
  end

  context "with a separator" do
    let(:builder) do
      ActiveAdmin::CSVBuilder.new :separator => ";"
    end

    it "should have proper separator" do
      builder.column_separator.should == ";"
    end
  end

  context "with csv_options" do
    let(:builder) do
      ActiveAdmin::CSVBuilder.new :options => {:force_quotes => true}
    end

    it "should have proper separator" do
      builder.options.should == {:force_quotes => true}
    end
  end

end
require 'spec_helper' 

require 'active_admin/dashboards/dashboard_controller'
require 'active_admin/dashboards/section'

module Admin
  class TestDashboardController < ActiveAdmin::PageController
    include ActiveAdmin::Dashboards::DashboardController
  end
end

class TestDashboardController < ActiveAdmin::PageController
  include ActiveAdmin::Dashboards::DashboardController
end

describe ActiveAdmin::Dashboards::DashboardController do

  describe "getting the namespace name" do
    subject{ controller.send :namespace }

    context "when admin namespace" do
      let(:controller){ Admin::TestDashboardController.new }
      it { should == :admin }
    end

    context "when root namespace" do
      let(:controller){ TestDashboardController.new }
      it { should == :root }
    end
  end

  describe "conditionally displaying sections" do
    before { ActiveAdmin::Dashboards.clear_all_sections! }
    let(:controller){ Admin::TestDashboardController.new }
    
    context "when :if not specified" do
      before do
        @section = ActiveAdmin::Dashboards.add_section('Stats').last
      end
      
      it "should include section" do
        controller.send(:find_sections).should include(@section)
      end
    end
    
    context "when :if option specified as a method" do
      before do
        @section = ActiveAdmin::Dashboards.add_section('Secret Codes', :if => :i_am_awesome?).last
      end
      
      it "should call the method of the same name" do
        controller.should_receive(:i_am_awesome?).and_return(true)
        controller.send(:find_sections).should include(@section)
        
        controller.should_receive(:i_am_awesome?).and_return(false)
        controller.send(:find_sections).should_not include(@section)
      end
    end
    
    context "when :if option specified as block" do
      before do
        @proc    = Proc.new { true }
        @section = ActiveAdmin::Dashboards.add_section('Secret Codes', :if => proc {}).last
      end
      
      it "should evaluate the block" do
        controller.should_receive(:instance_exec).with(&@proc).and_return(true)
        controller.send(:find_sections).should include(@section)
        
        controller.should_receive(:instance_exec).with(&@proc).and_return(false)
        controller.send(:find_sections).should_not include(@section)
      end
    end
  end
  
end
require 'spec_helper' 

describe ActiveAdmin::Dashboards::Section do

  def section(options = {})
    name = options.delete(:name) || "Recent Posts"
    ActiveAdmin::Dashboards::Section.new(:admin, name, options){ }
  end

  describe "accessors" do
    it "should have a namespace" do
      section.namespace.should == :admin
    end

    it "should have a block" do
      section.block.class.should == Proc
    end

    it "should have a name" do
      section.name.should == 'Recent Posts'
    end
  end

  describe "priority" do
    context "when not set" do
      subject{ section.priority }
      it { should == ActiveAdmin::Dashboards::Section::DEFAULT_PRIORITY }
    end

    context "when set" do
      subject{ section(:priority => 1).priority }
      it { should == 1 }
    end
  end

  describe "icon" do
    it "should set the icon" do
      s = section(:icon => :my_icon)
      s.icon.should == :my_icon
    end
    it "should be nil by default" do
      section.icon.should be_nil
    end
  end

  describe "sorting sections" do
    it "should sort by priority then alpha" do
      s1 = section :name => "Woot"
      s2 = section :name => :Alpha
      s3 = section :name => "Zulu", :priority => 1
      s4 = section :name => "Beta", :priority => 100
      [s1,s2,s3,s4].sort.should == [s3, s2, s1, s4]
    end
  end

end
require 'spec_helper' 

describe ActiveAdmin::Dashboards do

  after(:each) do
    ActiveAdmin::Dashboards.clear_all_sections!
  end

  describe "adding sections" do
    before do
      ActiveAdmin::Dashboards.clear_all_sections!
      ActiveAdmin::Dashboards.add_section('Recent Posts')
    end
    it "should add a new section namespaced" do
      ActiveAdmin::Dashboards.sections[:admin].first.should be_an_instance_of(ActiveAdmin::Dashboards::Section)
    end
  end

  describe "adding sections using the build syntax" do
    before do
      ActiveAdmin::Dashboards.clear_all_sections!
      ActiveAdmin::Dashboards.build do
        section "Recent Posts" do
        end
      end
    end

    it "should add a new section" do
      ActiveAdmin::Dashboards.sections[:admin].first.should be_an_instance_of(ActiveAdmin::Dashboards::Section)
    end
  end

  describe "clearing all sections" do
    before do
      ActiveAdmin::Dashboards.add_section('Recent Posts')
    end
    it "should clear all sections" do
      ActiveAdmin::Dashboards.clear_all_sections!
      ActiveAdmin::Dashboards.sections.keys.should be_empty
    end
  end

  describe "finding namespaced sections" do
    context "when the namespace exists" do
      before do
        ActiveAdmin::Dashboards.add_section('Recent Posts')
      end
      it "should return an array of sections" do
        ActiveAdmin::Dashboards.sections_for_namespace(:admin).should_not be_empty
      end
    end

    context "when the namespace does not exists" do
      it "should return an empty array" do
        ActiveAdmin::Dashboards.sections_for_namespace(:not_a_namespace).should be_empty
      end
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Devise::Controller do

  let(:controller_class) do
    klass = Class.new do
      def self.layout(*); end
      def self.helper(*); end
    end
    klass.send(:include, ActiveAdmin::Devise::Controller)
    klass
  end

  let(:controller) { controller_class.new }
  
  context 'with a RAILS_RELATIVE_URL_ROOT set' do
    
    before { Rails.configuration.action_controller[:relative_url_root] = '/foo' }
    
    it "should set the root path to the default namespace" do
      controller.root_path.should == "/foo/admin"
    end

    it "should set the root path to '/' when no default namespace" do
      ActiveAdmin.application.stub!(:default_namespace => false)
      controller.root_path.should == "/foo/"
    end
    
  end
  
  context 'without a RAILS_RELATIVE_URL_ROOT set' do
    
    before { Rails.configuration.action_controller[:relative_url_root] = nil }
    
    it "should set the root path to the default namespace" do
      controller.root_path.should == "/admin"
    end
    
    it "should set the root path to '/' when no default namespace" do
      ActiveAdmin.application.stub!(:default_namespace => false)
      controller.root_path.should == "/"
    end
    
  end

  context "within a scoped route" do

    SCOPE = '/aa_scoped'

    before do
      # Remove existing routes
      routes = Rails.application.routes
      routes.clear!

      # Add scoped routes
      routes.draw do
        scope :path => SCOPE do
          ActiveAdmin.routes(self)
          devise_for :admin_users, ActiveAdmin::Devise.config
        end
      end
    end

    after do
      # Resume default routes
      reload_routes!
    end

    it "should include scope path in root_path" do
      controller.root_path.should == "#{SCOPE}/admin"
    end

  end
  
  describe "#config" do
    let(:config) { ActiveAdmin::Devise.config }

    describe ":sign_out_via option" do

      subject { config[:sign_out_via] }

      context "when Devise does not implement sign_out_via (version < 1.2)" do
        before do
          ::Devise.should_receive(:respond_to?).with(:sign_out_via).and_return(false)
        end

        it "should not contain any customization for sign_out_via" do
          config.should_not have_key(:sign_out_via)
        end
      end

      context "when Devise implements sign_out_via (version >= 1.2)" do
        before do
          ::Devise.should_receive(:respond_to?).with(:sign_out_via).and_return(true)
          ::Devise.stub!(:sign_out_via) { :delete }
        end

        it "should contain the application.logout_link_method" do
            ::Devise.should_receive(:sign_out_via).and_return(:delete)
            ActiveAdmin.application.should_receive(:logout_link_method).and_return(:get)

            config[:sign_out_via].should include(:get)
        end

        it "should contain Devise's logout_via_method(s)" do
            ::Devise.should_receive(:sign_out_via).and_return([:delete, :post])
            ActiveAdmin.application.should_receive(:logout_link_method).and_return(:get)

            config[:sign_out_via].should == [:delete, :post, :get]
        end
      end

    end # describe ":sign_out_via option"
  end # describe "#config"

end
require 'spec_helper'

describe "display names" do

  include ActiveAdmin::ViewHelpers

  [:display_name, :full_name, :name, :username, :login, :title, :email, :to_s].each do |m|
    it "should return #{m} if defined" do
      r = Class.new do
        define_method m do
          m.to_s
        end
      end.new
      display_name(r).should == m.to_s
    end
  end

  it "should memeoize the result for the class" do
    c = Class.new do
      def name
        "My Name"
      end
    end
    display_name(c.new).should == "My Name"
    ActiveAdmin.application.should_not_receive(:display_name_methods)
    display_name(c.new).should == "My Name"
  end

end
require 'spec_helper'


module MockModuleToInclude
  def self.included(dsl)
  end
end

describe ActiveAdmin::DSL do

  let(:config){ mock }
  let(:application) { ActiveAdmin::Application.new }
  let(:namespace) { ActiveAdmin::Namespace.new application, :admin }
  let(:resource_config) { ActiveAdmin::Resource.new namespace, Post }
  let(:dsl){ ActiveAdmin::DSL.new(config) }

  describe "#include" do

    it "should call the included class method on the module that is included" do
      MockModuleToInclude.should_receive(:included).with(dsl)
      dsl.run_registration_block do
        include MockModuleToInclude
      end
    end

  end

  describe "#menu" do

    it "should set the menu_item_options on the configuration" do
      config.should_receive(:menu_item_options=).with({:parent => "Admin"})
      dsl.run_registration_block do
        menu :parent => "Admin"
      end
    end

  end

  describe "#navigation_menu" do

    it "should set the navigation_menu_name on the configuration" do
      config.should_receive(:navigation_menu_name=).with(:admin)
      dsl.run_registration_block do
        navigation_menu :admin
      end
    end

    it "should accept a block" do

      dsl = ActiveAdmin::DSL.new(resource_config)
      dsl.run_registration_block do
        navigation_menu { :dynamic_menu }
      end

      resource_config.navigation_menu_name.should == :dynamic_menu

    end

  end

end
require 'spec_helper'
require 'active_admin/event'

describe ActiveAdmin::EventDispatcher do

  let(:test_event){ 'active_admin.test_event' }
  let(:dispatcher){ ActiveAdmin::EventDispatcher.new }

  it "should add a subscriber for an event" do
    dispatcher.subscribers(test_event).size.should == 0
    dispatcher.subscribe(test_event){ true }
    dispatcher.subscribers(test_event).size.should == 1
  end

  it "should add a subscriber for multiple events" do
    dispatcher.subscribe(test_event, test_event + "1"){ true }
    dispatcher.subscribers(test_event).size.should == 1
    dispatcher.subscribers(test_event + "1").size.should == 1
  end

  it "should call the dispatch block with no arguments" do
    dispatcher.subscribe(test_event){ raise StandardError, "From Event Handler" }
    lambda {
      dispatcher.dispatch(test_event)
    }.should raise_error(StandardError, "From Event Handler")
  end

  it "should call the dispatch block with one argument" do
    arg = nil
    dispatcher.subscribe(test_event){|passed_in| arg = passed_in }
    dispatcher.dispatch(test_event, "My Arg")
    arg.should == "My Arg"
  end

  it "should clear all subscribers" do
    dispatcher.subscribe(test_event){ false }
    dispatcher.subscribe(test_event + "_2"){ false }
    dispatcher.clear_all_subscribers!
    dispatcher.subscribers(test_event).size.should == 0
    dispatcher.subscribers(test_event + "_2").size.should == 0
  end

  it "should have a dispatcher available from ActiveAdmin::Event" do
    ActiveAdmin::Event.should be_an_instance_of(ActiveAdmin::EventDispatcher)
  end

end
require 'spec_helper' 


describe ActiveAdmin::Filters::ViewHelper do

  # Setup an ActionView::Base object which can be used for
  # generating the form for.
  let(:helpers) do 
    view = action_view
    def view.collection_path
      "/posts"
    end

    def view.protect_against_forgery?
      false
    end

    def view.a_helper_method
      "A Helper Method"
    end

    view
  end

  def render_filter(search, filters)
    render_arbre_component({:filter_args => [search, filters]}, helpers) do
      text_node active_admin_filters_form_for(*assigns[:filter_args])
    end
  end

  def filter(name, options = {})
    render_filter Post.search, @filters.push(options.merge(:attribute => name))
  end

  before(:each) { @filters = [] }


  describe "the form in general" do
    let(:body) { filter :title }

    it "should generate a form which submits via get" do
      body.should have_tag("form", :attributes => { :method => 'get', :class => 'filter_form' })
    end

    it "should generate a filter button" do
      body.should have_tag("input", :attributes => { :type => "submit",
                                                        :value => "Filter" })
    end

    it "should only generate the form once" do
      body.to_s.scan(/q\[title_contains\]/).size.should == 1
    end

    it "should generate a clear filters link" do
      body.should have_tag("a", "Clear Filters", :attributes => { :class => "clear_filters_btn" })
    end
  end

  describe "string attribute" do
    let(:body) { filter :title }

    it "should generate a search field for a string attribute" do
      body.should have_tag("input", :attributes => { :name => "q[title_contains]"})
    end

    it "should label a text field with search" do
      body.should have_tag('label', 'Search Title')
    end

    it "should translate the label for text field" do
      begin
        I18n.backend.store_translations(:en, :activerecord => { :attributes => { :post => { :title => "Name" } } })
        body.should have_tag('label', 'Search Name')
      ensure
        I18n.backend.reload!
      end
    end

    context "using starts_with and as" do
      let(:body) { filter :title_starts_with, :as => :string }

      it "should generate a search field for a string attribute with query starts_with" do
        body.should have_tag("input", :attributes => { :name => "q[title_starts_with]" })
      end
    end

    context "using ends_with and as" do
      let(:body) { filter :title_ends_with, :as => :string }

      it "should generate a search field for a string attribute with query starts_with" do
        body.should have_tag("input", :attributes => { :name => "q[title_ends_with]" })
      end
    end
  end

  describe "text attribute" do
    let(:body) { filter :body }

    it "should generate a search field for a text attribute" do
      body.should have_tag("input", :attributes => { :name => "q[body_contains]"})
    end

    it "should label a text field with search" do
      body.should have_tag('label', 'Search Body')
    end
  end

  describe "datetime attribute" do
    let(:body) { filter :created_at }

    it "should generate a date greater than" do
      body.should have_tag("input", :attributes => { :name => "q[created_at_gte]", :class => "datepicker"})
    end
    it "should generate a seperator" do
      body.should have_tag("span", :attributes => { :class => "seperator"})
    end
    it "should generate a date less than" do
      body.should have_tag("input", :attributes => { :name => "q[created_at_lte]", :class => "datepicker"})
    end
  end

  describe "integer attribute" do
    let(:body) { filter :id }

    it "should generate a select option for equal to" do
      body.should have_tag("option", "Equal To", :attributes => { :value => 'id_eq' })
    end
    it "should generate a select option for greater than" do
      body.should have_tag("option", "Greater Than")
    end
    it "should generate a select option for less than" do
      body.should have_tag("option", "Less Than")
    end
    it "should generate a text field for input" do
      body.should have_tag("input", :attributes => {
                                          :name => /q\[(id_eq|id_equals)\]/ })
    end
    it "should select the option which is currently being filtered"
  end

  describe "boolean attribute" do
    context "boolean datatypes" do
      let(:body) { filter :starred }

      it "should create a check box for equals to" do
        body.should have_tag("input", :attributes => {
                                            :name => "q[starred_eq]",
                                            :type => "checkbox" })
      end
    end

    context "non-boolean data types" do
      let(:body) { filter :title_is_present, :as => :boolean }

      it "should create a check box for equals to" do
        body.should have_tag("input", :attributes => {
                                            :name => "q[title_is_present]",
                                            :type => "checkbox" })
      end
    end
  end

  describe "belong to" do
    before do
      @john = User.create :first_name => "John", :last_name => "Doe", :username => "john_doe"
      @jane = User.create :first_name => "Jane", :last_name => "Doe", :username => "jane_doe"
    end

    context "when given as the _id attribute name" do
      let(:body) { filter :author_id }

      it "should not render as an integer" do
        body.should_not have_tag("input", :attributes => {
                                                :name => "q[author_id_eq]"})
      end
      it "should render as belongs to select" do
        body.should have_tag("select", :attributes => {
                                            :name => "q[author_id_eq]"})
        body.should have_tag("option", "john_doe", :attributes => {
                                                           :value => @john.id })
        body.should have_tag("option", "jane_doe", :attributes => {
                                                          :value => @jane.id })
      end
    end

    context "when given as the name of the relationship" do
      let(:body) { filter :author }

      it "should generate a select" do
        body.should have_tag("select", :attributes => {
                                            :name => "q[author_id_eq]"})
      end
      it "should set the default text to 'Any'" do
        body.should have_tag("option", "Any", :attributes => {
                                                    :value => "" })
      end
      it "should create an option for each related object" do
        body.should have_tag("option", "john_doe", :attributes => {
                                                          :value => @john.id })
        body.should have_tag("option", "jane_doe", :attributes => {
                                                          :value => @jane.id })
      end

      context "with a proc" do
        let :body do
          filter :title, :as => :select, :collection => proc{ ['Title One', 'Title Two'] }
        end

        it "should use call the proc as the collection" do
          body.should have_tag("option", "Title One")
          body.should have_tag("option", "Title Two")
        end

        it "should render the collection in the context of the view" do
          body = filter(:title, :as => :select, :collection => proc{[a_helper_method]})
          body.should have_tag("option", "A Helper Method")
        end
      end
    end

    context "as check boxes" do
      let(:body) { filter :author, :as => :check_boxes }

      it "should create a check box for each related object" do
        body.should have_tag("input", :attributes => {
                                            :name => "q[author_id_in][]",
                                            :type => "checkbox",
                                            :value => @john.id })
        body.should have_tag("input", :attributes => {
                                            :name => "q[author_id_in][]",
                                            :type => "checkbox",          
                                            :value => @jane.id })
      end
    end

    context "when polymorphic relationship" do
      let(:body) do
        search = ActiveAdmin::Comment.search
        render_filter(search, [{:attribute => :resource}])
      end
      it "should not generate any field" do
        body.should have_tag("form", :attributes => { :method => 'get' })
      end
    end
  end # belongs to


  describe "conditional display" do

    context "with :if block" do
      let(:body) do
        filter :body,   :if => proc{true}
        filter :author, :if => proc{false}
      end

      it "should be displayed if true" do
        body.should have_tag("input", :attributes => { :name => "q[body_contains]"})
      end

      it "should NOT be displayed if false" do
        body.should_not have_tag("input", :attributes => { :name => "q[author_id_eq]"})
      end
    end

    context "with :unless block" do
      let(:body) do
        filter :created_at, :unless => proc{false}
        filter :updated_at, :unless => proc{true}
      end

      it "should be displayed if false" do
        body.should have_tag("input", :attributes => { :name => "q[created_at_gte]"})
      end

      it "should NOT be displayed if true" do
        body.should_not have_tag("input", :attributes => { :name => "q[updated_at_gte]"})
      end
    end
  end

end
require 'spec_helper'

describe ActiveAdmin::Filters::ResourceExtension do

  let(:resource) do
    namespace = ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin)
    namespace.register(Post)
  end

  it "should return the defaults if no filters are set" do
    resource.filters.map{|f| f[:attribute].to_s }.sort.should == %w{
      author body category created_at published_at starred title updated_at
    }
  end

  it "should not have defaults when filters are disabled on the resource" do
    resource.filters = false
    resource.filters.should be_empty
  end

  it "should not have defaults when the filters are disabled on the namespace" do
    resource.namespace.filters = false
    resource.filters.should be_empty
  end

  it "should not have defaults when the filters are disabled on the application" do
    resource.namespace.application.filters = false
    resource.filters.should be_empty
  end

  context "filter removal" do
    it "should work" do
      resource.filters.should include :attribute => :author
      resource.remove_filter :author
      resource.filters.should_not include :attribute => :author
    end

    it "should be lazy" do
      resource.should_not_receive :default_filters # this hits the DB
      resource.remove_filter :author
    end

    it "should not prevent the default filters from being added" do
      resource.remove_filter :author
      resource.filters.should_not be_empty
    end
  end

  # TODO: wrap the below in a context like "filter removal" was above
  it "should add a filter" do
    resource.add_filter :title
    resource.filters.should == [{:attribute => :title}]
  end

  it "should add a filter with options" do
    resource.add_filter :title, :as => :string
    resource.filters.should == [{:attribute => :title, :as => :string}]
  end

  it "should preserve default filters" do
    resource.preserve_default_filters!
    resource.add_filter :count, :as => :string
    resource.filters.map{|f| f[:attribute].to_s }.sort.should == %w{
      author body category count created_at published_at starred title updated_at
    }
  end

  it "should raise an exception if trying to add a filter when they are disabled" do
    resource.filters = false
    expect {
      resource.add_filter :title
    }.should raise_error(RuntimeError)
  end

  it "should reset filters" do
    resource.add_filter :title
    resource.filters.size.should == 1
    resource.reset_filters!
    resource.filters.size.should > 1
  end

  it "should add a sidebar section for the filters" do
    resource.sidebar_sections.first.name.should == :filters
  end

end
require 'spec_helper'

describe ActiveAdmin::FormBuilder do

  # Setup an ActionView::Base object which can be used for
  # generating the form for.
  let(:helpers) do
    view = action_view
    def view.posts_path
      "/posts"
    end

    def view.protect_against_forgery?
      false
    end

    def view.url_for(*args)
      if args.first == {:action => "index"}
        posts_path
      else
        super
      end
    end

    def view.a_helper_method
      "A Helper Method"
    end

    view
  end

  def build_form(options = {}, form_object = Post.new, &block)
    options = {:url => helpers.posts_path}.merge(options)

    render_arbre_component({:form_object => form_object, :form_options => options, :form_block => block}, helpers)do
      text_node active_admin_form_for(assigns[:form_object], assigns[:form_options], &assigns[:form_block])
    end.to_s
  end

  context "in general with actions" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :title
          f.input :body
        end
        f.actions do
          f.action :submit, :label => "Submit Me"
          f.action :submit, :label => "Another Button"
        end
      end
    end

   it "should generate a text input" do
      body.should have_tag("input", :attributes => { :type => "text",
                                                     :name => "post[title]" })
    end
    it "should generate a textarea" do
      body.should have_tag("textarea", :attributes => { :name => "post[body]" })
    end
    it "should only generate the form once" do
      body.scan(/Title/).size.should == 1
    end
    it "should generate actions" do
      body.should have_tag("input", :attributes => {  :type => "submit",
                                                          :value => "Submit Me" })
      body.should have_tag("input", :attributes => {  :type => "submit",
                                                          :value => "Another Button" })
    end
  end

  context "in general with actions" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :title
          f.input :body
        end
        f.actions do
          f.action :submit, :button_html => { :value => "Submit Me" }
          f.action :submit, :button_html => { :value => "Another Button" }
        end
      end
    end

    it "should generate a text input" do
      body.should have_tag("input", :attributes => { :type => "text",
                                                     :name => "post[title]" })
    end
    it "should generate a textarea" do
      body.should have_tag("textarea", :attributes => { :name => "post[body]" })
    end
    it "should only generate the form once" do
      body.scan(/Title/).size.should == 1
    end
    it "should generate actions" do
      body.should have_tag("input", :attributes => {  :type => "submit",
                                                          :value => "Submit Me" })
      body.should have_tag("input", :attributes => {  :type => "submit",
                                                          :value => "Another Button" })
    end
  end

  context "when polymorphic relationship" do
    it "should raise error" do
      lambda {
        comment = ActiveAdmin::Comment.new
        build_form({:url => "admins/comments"}, comment) do |f|
          f.inputs :resource
        end
      }.should raise_error(Formtastic::PolymorphicInputWithoutCollectionError)
    end
  end

  describe "passing in options with actions" do
    let :body do
      build_form :html => { :multipart => true } do |f|
        f.inputs :title
        f.actions
      end
    end
    it "should pass the options on to the form" do
      body.should have_tag("form", :attributes => { :enctype => "multipart/form-data" })
    end
  end

  describe "passing in options with actions" do
    let :body do
      build_form :html => { :multipart => true } do |f|
        f.inputs :title
        f.actions
      end
    end
    it "should pass the options on to the form" do
      body.should have_tag("form", :attributes => { :enctype => "multipart/form-data" })
    end
  end


  context "with actions" do
    it "should generate the form once" do
      body = build_form do |f|
        f.inputs do
          f.input :title
        end
        f.actions
      end
      body.scan(/id=\"post_title\"/).size.should == 1
    end
    it "should generate one button and a cancel link" do
      body = build_form do |f|
        f.actions
      end
      body.scan(/type=\"submit\"/).size.should == 1
      body.scan(/class=\"cancel\"/).size.should == 1
    end
    it "should generate multiple actions" do
      body = build_form do |f|
        f.actions do
          f.action :submit, :label => "Create & Continue"
          f.action :submit, :label => "Create & Edit"
        end
      end
      body.scan(/type=\"submit\"/).size.should == 2
      body.scan(/class=\"cancel\"/).size.should == 0
    end

  end

  context "with actons" do
    it "should generate the form once" do
      body = build_form do |f|
        f.inputs do
          f.input :title
        end
        f.actions
      end
      body.scan(/id=\"post_title\"/).size.should == 1
    end
    it "should generate one button and a cancel link" do
      body = build_form do |f|
        f.actions
      end
      body.scan(/type=\"submit\"/).size.should == 1
      body.scan(/class=\"cancel\"/).size.should == 1
    end
    it "should generate multiple actions" do
      body = build_form do |f|
        f.actions do
          f.action :submit, :label => "Create & Continue"
          f.action :submit, :label => "Create & Edit"
        end
      end
      body.scan(/type=\"submit\"/).size.should == 2
      body.scan(/class=\"cancel\"/).size.should == 0
    end
  end

  context "without passing a block to inputs" do
    let :body do
      build_form do |f|
        f.inputs :title, :body
      end
    end
    it "should have a title input" do
      body.should have_tag("input", :attributes => { :type => "text",
                                                          :name => "post[title]" })
    end
    it "should have a body textarea" do
      body.should have_tag("textarea", :attributes => { :name => "post[body]" })
    end
  end

  context "with semantic fields for" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :title
          f.input :body
        end
        f.instance_eval do
          @object.author = User.new
        end
        f.semantic_fields_for :author do |author|
          author.inputs :first_name, :last_name
        end
      end
    end
    it "should generate a nested text input once" do
      body.scan("post_author_attributes_first_name_input").size.should == 1
    end
  end

  context "with collection inputs" do
    before do
      User.create :first_name => "John", :last_name => "Doe"
      User.create :first_name => "Jane", :last_name => "Doe"
    end

    describe "as select" do
      let :body do
        build_form do |f|
          f.input :author
        end
      end
      it "should create 2 options" do
        body.scan(/\<option/).size.should == 3
      end
    end

    describe "as radio buttons" do
      let :body do
        build_form do |f|
          f.input :author, :as => :radio
        end
      end
      it "should create 2 radio buttons" do
        body.scan(/type=\"radio\"/).size.should == 2
      end
    end

  end

  context "with inputs 'for'" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :title
          f.input :body
        end
        f.instance_eval do
          @object.author = User.new
        end
        f.inputs :name => 'Author', :for => :author do |author|
          author.inputs :first_name, :last_name
        end
      end
    end
    it "should generate a nested text input once" do
      body.scan("post_author_attributes_first_name_input").size.should == 1
    end
    it "should add an author first name field" do
      body.should have_tag("input", :attributes => { :name => "post[author_attributes][first_name]"})
    end
  end

  context "with wrapper html" do
    it "should set a class" do
      body = build_form do |f|
        f.input :title, :wrapper_html => { :class => "important" }
      end
      body.should have_tag("li", :attributes => {:class => "important string input optional stringish"})
    end
  end

  context "with has many inputs" do
    describe "with simple block" do
      let :body do
        build_form({:url => '/categories'}, Category.new) do |f|
          f.object.posts.build
          f.has_many :posts do |p|
            p.input :title
          end
        end
      end

      it "should translate the association name in header" do
        begin
          I18n.backend.store_translations(:en, :activerecord => { :models => { :post => { :one => "Blog Post", :other => "Blog Posts" } } })
          body.should have_tag('h3', 'Blog Posts')
        ensure
          I18n.backend.reload!
        end
      end

      it "should use model name when there is no translation for given model in header" do
        body.should have_tag('h3', 'Post')
      end

      it "should translate the association name in has many new button" do
        begin
          I18n.backend.store_translations(:en, :activerecord => { :models => { :post => { :one => "Blog Post", :other => "Blog Posts" } } })
          body.should have_tag('a', 'Add New Blog Post')
        ensure
          I18n.backend.reload!
        end
      end

      it "should use model name when there is no translation for given model in has many new button" do
        body.should have_tag('a', 'Add New Post')
      end

      it "should render the nested form" do
        body.should have_tag("input", :attributes => {:name => "category[posts_attributes][0][title]"})
      end

      it "should add a link to remove new nested records" do
        Capybara.string(body).should have_css(".has_many > fieldset > ol > li > a", :class => "button", :href => "#", :content => "Delete")
      end

      it "should include the nested record's class name in the js" do
        body.should have_tag("a", :attributes => { :onclick => /NEW_POST_RECORD/ })
      end

      it "should add a link to add new nested records" do
        Capybara.string(body).should have_css(".has_many > fieldset > ol > li > a", :class => "button", :href => "#", :content => "Add New Post")
      end
    end

    describe "with complex block" do
      let :body do
        build_form({:url => '/categories'}, Category.new) do |f|
          f.object.posts.build
          f.has_many :posts do |p,i|
            p.input :title, :label => "Title #{i}"
          end
        end
      end

      it "should accept a block with a second argument" do
        body.should have_tag("label", "Title 1")
      end
    end

    pending "should render the block if it returns nil" do
      body = build_form({:url => '/categories'}, Category.new) do |f|
        f.object.posts.build
        f.has_many :posts do |p|
          p.input :title
          nil
        end
      end

      body.should have_tag("input", :attributes => {:name => "category[posts_attributes][0][title]"})
    end
  end

  {
    "input :title, :as => :string"               => /id\=\"post_title\"/,
    "input :title, :as => :text"                 => /id\=\"post_title\"/,
    "input :created_at, :as => :time_select"     => /id\=\"post_created_at_2i\"/,
    "input :created_at, :as => :datetime_select" => /id\=\"post_created_at_2i\"/,
    "input :created_at, :as => :date_select"     => /id\=\"post_created_at_2i\"/,
  }.each do |source, regex|
   it "should properly buffer #{source}" do
     body = build_form do |f|
       f.inputs do
         f.instance_eval(source)
         f.instance_eval(source)
       end
     end
     body.scan(regex).size.should == 2
   end
  end

  describe "datepicker input" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :created_at, :as => :datepicker
        end
      end
    end
    it "should generate a text input with the class of datepicker" do
      body.should have_tag("input", :attributes => {  :type => "text",
                                                          :class => "datepicker",
                                                          :name => "post[created_at]" })
    end
  end

  describe "inputs block with nil return value" do
    let :body do
      build_form do |f|
        f.inputs do
          f.input :title
          nil
        end
      end
    end

    it "should generate a single input field" do
      body.should have_tag("input", :attributes => { :type => "text", :name => "post[title]" })
    end
  end

end
require 'spec_helper'


if Rails.version[0..2] == '3.1'
  describe "Installing in Rails 3.1" do

    it "should add active_admin.css to app/assets/stylesheets/" do
      File.exists?(Rails.root + "app/assets/stylesheets/active_admin.css.scss").should be_true
    end

    it "should add active_admin.js to app/assets/javascripts" do
      File.exists?(Rails.root + "app/assets/javascripts/active_admin.js").should be_true
    end

  end
end
require 'spec_helper'

describe ActiveAdmin::Helpers::Collection do

  include ActiveAdmin::Helpers::Collection

  before(:all) do
    Post.delete_all
    Post.create!(:title => "A post")
    Post.create!(:title => "A post")
    Post.create!(:title => "An other post")
  end

  after(:all) do
    Post.delete_all
  end

  describe "#collection_size" do
    it "should return the collection size for an ActiveRecord class" do
      collection_size(Post).should == 3
    end

    it "should return the collection size for an ActiveRecord::Relation" do
      collection_size(Post.where(:title => "A post")).should == 2
    end

    it "should return the collection size for a collection with group by" do
      collection_size(Post.group(:title)).should == 2
    end

    it "should return the collection size for a collection with group by, select and custom order" do
      collection_size(Post.select("title, count(*) as nb_posts").group(:title).order("nb_posts")).should == 2
    end

    it "should take the defined collection by default" do
      def collection; Post; end

      collection_size.should == 3

      def collection; Post.where(:title => "An other post"); end

      collection_size.should == 1
    end
  end

  describe "#collection_is_empty?" do
    it "should return true when the collection is empty" do
      collection_is_empty?(Post.where(:title => "Non existing post")).should be_true
    end

    it "should return false when the collection is not empty" do
      collection_is_empty?(Post.where(:title => "A post")).should be_false
    end

    it "should take the defined collection by default" do
      def collection; Post; end

      collection_is_empty?.should be_false

      def collection; Post.where(:title => "Non existing post"); end

      collection_is_empty?.should be_true
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::ScopeChain do

  include ActiveAdmin::ScopeChain

  describe "#scope_chain" do
    let(:relation) { mock }

    context "when Scope has a scope method" do
      let(:scope) { ActiveAdmin::Scope.new :published }

      it "should call the method on the relation and return it" do
        relation.should_receive(:published).and_return(:scoped_relation)
        scope_chain(scope, relation).should == :scoped_relation
      end
    end

    context "when Scope has the scope method method ':all'" do
      let(:scope) { ActiveAdmin::Scope.new :all }

      it "should return the relation" do
        scope_chain(scope, relation).should == relation
      end
    end

    context "when Scope has a name and a scope block" do
      let(:scope) { ActiveAdmin::Scope.new("My Scope"){|s| :scoped_relation } }

      it "should instance_exec the block and return it" do
        scope_chain(scope, relation).should == :scoped_relation
      end
    end
  end
end

require 'spec_helper'
require 'active_admin/helpers/settings'

describe ActiveAdmin::Settings do

  # A Class with settings module included
  let(:klass) do
    Class.new do
      include ActiveAdmin::Settings
    end
  end

  it "should add a new setting with a default" do
    klass.setting :my_setting, "Hello World"
    klass.default_settings[:my_setting].should == "Hello World"
  end

  it "should initialize the defaults" do
    klass.setting :my_setting, "Hello World"
    klass.new.my_setting.should == "Hello World"
  end

  it "should support settings of nil" do
    klass.setting :my_setting, :some_val
    inst = klass.new
    inst.my_setting = nil
    inst.my_setting.should == nil
  end

end
require 'spec_helper'

describe ActiveAdmin::MenuCollection do

  let(:menus) { ActiveAdmin::MenuCollection.new }

  describe "#add" do

    it "should initialize a new menu when first item" do
      menus.add :default, :label => "Hello World"

      menus.fetch(:default).items.size.should == 1
      menus.fetch(:default)["Hello World"].should be_an_instance_of(ActiveAdmin::MenuItem)
    end

    it "should add items to an existing menu" do
      menus.add :default, :label => "Hello World"
      menus.add :default, :label => "Hello World Again"

      menus.fetch(:default).items.size.should == 2
    end

  end

  describe "#clear!" do

    it "should remove all menus" do
      menus.add :default, :label => "Hello World"

      menus.clear!

      expect {
        menus.fetch(:non_default_menu)
      }.to raise_error(ActiveAdmin::MenuCollection::NoMenuError)

    end

  end

  describe "#on_build" do

    it "runs a callback when fetching a menu" do
      menus.on_build do |m|
        m.add :default, :label => "Hello World"
      end

      menus.fetch(:default)["Hello World"].should_not be_nil
    end

    it "re-runs the callbacks when the menu is cleared" do
      menus.on_build do |m|
        m.add :default, :label => "Hello World"
      end

      menus.fetch(:default)["Hello World"].should_not be_nil
      menus.clear!
      menus.fetch(:default)["Hello World"].should_not be_nil
    end

  end

end
require 'spec_helper_without_rails'
require 'active_admin/menu'
require 'active_admin/menu_item'

module ActiveAdmin
  describe MenuItem do

    it "should have a label" do
      item = MenuItem.new(:label => "Dashboard")
      item.label.should == "Dashboard"
    end

    it "should have a url" do
      item = MenuItem.new(:url => "/admin")
      item.url.should == "/admin"
    end

    it "should have a priority of 10 by default" do
      item = MenuItem.new
      item.priority.should == 10
    end

    context "conditional display" do
      it "should store a Proc internally and evaluate it when requested" do
        item = MenuItem.new
        item.instance_variable_get(:@should_display).should be_a Proc
        item.display?.should_not be_a Proc
      end

      it "should show the item by default" do
        MenuItem.new.display?.should == true
      end

      it "should hide the item" do
        MenuItem.new(:if => proc{false}).display?.should == false
      end
    end

    it "should default to an empty hash for html_options" do
      item = MenuItem.new
      item.html_options.should be_empty
    end

    it "should accept an options hash for link_to" do
      item = MenuItem.new :html_options => { :target => :blank }
      item.html_options.should include(:target => :blank)
    end

    context "with no items" do
      it "should be empty" do
        item = MenuItem.new
        item.items.should be_empty
      end

      it "should accept new children" do
        item = MenuItem.new :label => "Dashboard"
        item.add            :label => "My Child Dashboard"
        item.items.first.should be_a MenuItem
        item.items.first.label.should == "My Child Dashboard"
      end
    end

    context "with many children" do
      let(:item) do
        i = MenuItem.new(:label => "Dashboard")
        i.add :label => "Blog"
        i.add :label => "Cars"
        i.add :label => "Users", :priority => 1
        i.add :label => "Settings", :priority => 2
        i.add :label => "Analytics", :priority => 44
        i
      end

      it "should contain 5 submenu items" do
        item.items.count.should == 5
      end

      it "should give access to the menu item as an array" do
        item['Blog'].label.should == 'Blog'
      end

      it "should sort items based on priority and name" do    
        item.items[0].label.should == 'Users'
        item.items[1].label.should == 'Settings'
        item.items[2].label.should == 'Blog'
        item.items[3].label.should == 'Cars'
        item.items[4].label.should == 'Analytics'
      end

      it "children should hold a reference to their parent" do
        item["Blog"].parent.should == item
      end
    end

    describe "accessing ancestory" do
      let(:item){ MenuItem.new :label => "Blog" }

      context "with no parent" do
        it "should return an empty array" do
         item.ancestors.should == [] 
        end
      end

      context "with one parent" do
        let(:sub_item) do 
          item.add :label => "Create New"
          item["Create New"]
        end
        it "should return an array with the parent" do
          sub_item.ancestors.should == [item]
        end
      end

      context "with many parents" do
        before(:each) do
          c1 = {:label => "C1"}
          c2 = {:label => "C2"}
          c3 = {:label => "C3"}

          item.add(c1).add(c2).add(c3)

          item
        end
        let(:sub_item){ item["C1"]["C2"]["C3"] }
        it "should return an array with the parents in reverse order" do
          sub_item.ancestors.should == [item["C1"]["C2"], item["C1"], item]
        end
      end
    end # accessing ancestory


    describe "#id" do
      it "should be normalized" do
        MenuItem.new(:id => "Foo Bar").id.should == "foo_bar"
      end

      it "should not accept Procs" do
        expect{ MenuItem.new(:id => proc{"Dynamic"}).id }.to raise_error TypeError
      end
    end

  end
end
require 'spec_helper'
require 'active_admin/menu'
require 'active_admin/menu_item'

include ActiveAdmin

describe ActiveAdmin::Menu do

  context "with no items" do
    it "should have an empty item collection" do
      menu = Menu.new
      menu.items.should be_empty
    end

    it "should accept new items" do
      menu = Menu.new
      menu.add :label => "Dashboard"
      menu.items.first.label.should == "Dashboard"
    end
  end

  context "with many items" do
    let(:menu) do
      Menu.new do |m|
        m.add :label => "Dashboard"
        m.add :label => "Blog"
      end
    end

    it "should give access to the menu item as an array" do
      menu['Dashboard'].label.should == 'Dashboard'
    end
  end

  describe "adding items with children" do
    it "should add an empty item if the parent does not exist" do
      menu = Menu.new
      menu.add :parent => "Admin", :label => "Users"

      menu["Admin"]["Users"].should be_an_instance_of(ActiveAdmin::MenuItem)
    end

    it "should add a child to a parent if it exists" do
      menu = Menu.new
      menu.add :parent => "Admin", :label => "Users"
      menu.add :parent => "Admin", :label => "Projects"

      menu["Admin"]["Projects"].should be_an_instance_of(ActiveAdmin::MenuItem)
    end

    it "should assign children regardless of resource file load order" do
      menu = Menu.new
      menu.add :parent => "Users", :label => "Posts"
      menu.add :label  => "Users", :url   => "/some/url"

      menu["Users"].url.should == "/some/url"
      menu["Users"]["Posts"].should be_a ActiveAdmin::MenuItem
    end
  end

  describe "sorting items" do
    it "should sort children by the result of their label proc" do
      menu = Menu.new
      menu.add :label => proc{ "G" }, :id => "not related 1"
      menu.add :label => proc{ "B" }, :id => "not related 2"
      menu.add :label => proc{ "A" }, :id => "not related 3"

      menu.items.map(&:label).should == %w[A B G]
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Resource, "authorization" do

  let(:app){ ActiveAdmin::Application.new }
  let(:namespace){ ActiveAdmin::Namespace.new(app, :admin) }
  let(:mock_auth){ mock }

  describe "authorization_adapter" do

    it "should return AuthorizationAdapter by default" do
      namespace.authorization_adapter.should == ActiveAdmin::AuthorizationAdapter
    end

    it "should be settable on the namespace" do
      namespace.authorization_adapter.should == ActiveAdmin::AuthorizationAdapter
      namespace.authorization_adapter = mock_auth

      namespace.authorization_adapter.should == mock_auth
    end

    it "should be settable on the application" do
      namespace.authorization_adapter.should == ActiveAdmin::AuthorizationAdapter
      app.authorization_adapter = mock_auth

      namespace.authorization_adapter.should == mock_auth
    end

  end

end
require 'spec_helper' 

describe ActiveAdmin::Namespace, "registering a page" do

  let(:application){ ActiveAdmin::Application.new }

  let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }
  let(:menu){ namespace.fetch_menu(:default) }

  context "with no configuration" do
    before do
      namespace.register_page "Status"
    end

    it "should store the namespaced registered configuration" do
      namespace.resources.keys.should include('Status')
    end

    it "should create a new controller in the default namespace" do
      defined?(Admin::StatusController).should be_true
    end

    it "should create a menu item" do
      menu["Status"].should be_an_instance_of(ActiveAdmin::MenuItem)
    end
  end # context "with no configuration"

  context "with a block configuration" do
    it "should be evaluated in the dsl" do
      lambda {
        namespace.register_page "Status" do
          raise "Hello World"
        end
      }.should raise_error
    end
  end # context "with a block configuration"

  describe "adding to the menu" do
    describe "adding as a top level item" do
      before do
        namespace.register_page "Status"
      end

      it "should add a new menu item" do
        menu['Status'].should_not be_nil
      end
    end # describe "adding as a top level item"

    describe "adding as a child" do
      before do
        namespace.register_page "Status" do
          menu :parent => 'Extra'
        end
      end
      it "should generate the parent menu item" do
        menu['Extra'].should_not be_nil
      end
      it "should generate its own child item" do
        menu['Extra']['Status'].should_not be_nil
      end
    end # describe "adding as a child"

    describe "disabling the menu" do
      before do
        namespace.register_page "Status" do
          menu false
        end
      end
      it "should not create a menu item" do
        menu["Status"].should be_nil
      end
    end # describe "disabling the menu"
  end # describe "adding to the menu"
end
require 'spec_helper' 

describe ActiveAdmin::Namespace, "registering a resource" do

  let(:application){ ActiveAdmin::Application.new }

  let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

  let(:menu){ namespace.fetch_menu(:default) }

  context "with no configuration" do
    before do
      namespace.register Category
    end
    it "should store the namespaced registered configuration" do
      namespace.resources.keys.should include('Category')
    end
    it "should create a new controller in the default namespace" do
      defined?(Admin::CategoriesController).should be_true
    end
    it "should create the dashboard controller" do
      defined?(Admin::DashboardController).should be_true
    end
    it "should create a menu item" do
      menu["Categories"].should be_a ActiveAdmin::MenuItem
      menu["Categories"].instance_variable_get(:@url).should be_a Proc
    end
  end # context "with no configuration"

  context "with a block configuration" do
    it "should be evaluated in the dsl" do
      lambda {
        namespace.register Category do
          raise "Hello World"
        end
      }.should raise_error
    end
  end # context "with a block configuration"

  context "with a resource that's namespaced" do
    before do
      module ::Mock; class Resource; def self.has_many(arg1, arg2); end; end; end
      namespace.register Mock::Resource
    end

    it "should store the namespaced registered configuration" do
      namespace.resources.keys.should include('Mock::Resource')
    end
    it "should create a new controller in the default namespace" do
      defined?(Admin::MockResourcesController).should be_true
    end
    it "should create a menu item" do
      menu["Mock Resources"].should be_an_instance_of(ActiveAdmin::MenuItem)
    end

    it "should use the resource as the model in the controller" do
      Admin::MockResourcesController.resource_class.should == Mock::Resource
    end
  end # context "with a resource that's namespaced"

  describe "finding resource instances" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    it "should return the resource when its been registered" do
      post = namespace.register Post
      namespace.resource_for(Post).should == post
    end

    it 'should return nil when the resource has not been registered' do
      namespace.resource_for(Post).should == nil
    end

    it "should return the parent when the parent class has been registered and the child has not" do
      user = namespace.register User
      namespace.resource_for(Publisher).should == user
    end

    it "should return the resource if it and it's parent were registered" do
      user = namespace.register User
      publisher = namespace.register Publisher
      namespace.resource_for(Publisher).should == publisher
    end
  end # describe "finding resource instances"

  describe "adding to the menu" do
    describe "adding as a top level item" do
      before do
        namespace.register Category
      end
      it "should add a new menu item" do
        menu['Categories'].should_not be_nil
      end
    end # describe "adding as a top level item"

    describe "adding as a child" do
      before do
        namespace.register Category do
          menu :parent => 'Blog'
        end
      end
      it "should generate the parent menu item" do
        menu['Blog'].should_not be_nil
      end
      it "should generate its own child item" do
        menu['Blog']['Categories'].should_not be_nil
      end
    end # describe "adding as a child"

    describe "disabling the menu" do
      before do
        namespace.register Category do
          menu false
        end
      end
      it "should not create a menu item" do
        menu["Categories"].should be_nil
      end
    end # describe "disabling the menu"

    describe "adding as a belongs to" do
      context "when not optional" do
        before do
          namespace.register Post do
            belongs_to :author
          end
        end
        it "should not show up in the menu" do
          menu["Posts"].should be_nil
        end
      end
      context "when optional" do
        before do
          namespace.register Post do
            belongs_to :author, :optional => true
          end
        end
        it "should show up in the menu" do
          menu["Posts"].should_not be_nil
        end
      end
    end
  end # describe "adding to the menu"

  describe "dashboard controller name" do
    context "when namespaced" do
      it "should be namespaced" do
        namespace = ActiveAdmin::Namespace.new(application, :admin)
        namespace.dashboard_controller_name.should == "Admin::DashboardController"
      end
    end
    context "when not namespaced" do
      it "should not be namespaced" do
        namespace = ActiveAdmin::Namespace.new(application, :root)
        namespace.dashboard_controller_name.should == "DashboardController"
      end
    end
  end # describe "dashboard controller name"
end # describe "registering a resource"
require 'spec_helper' 

describe ActiveAdmin::Namespace do

  let(:application){ ActiveAdmin::Application.new }

  context "when new" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    it "should have an application instance" do
      namespace.application.should == application
    end

    it "should have a name" do
      namespace.name.should == :admin
    end

    it "should have no resources" do
      namespace.resources.resources.should be_empty
    end

    it "should not have any menu item" do
      if ActiveAdmin::Dashboards.built?
        # DEPRECATED behavior. If a dashboard was built while running this
        # spec, then an item gets added to the menu
        namespace.fetch_menu(:default).children.should_not be_empty
      else
        namespace.fetch_menu(:default).children.should be_empty
      end
    end
  end # context "when new"

  describe "settings" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    it "should inherit the site title from the application" do
      ActiveAdmin::Namespace.setting :site_title, "Not the Same"
      namespace.site_title.should == application.site_title
    end

    it "should be able to override the site title" do
      namespace.site_title.should == application.site_title
      namespace.site_title = "My Site Title"
      namespace.site_title.should_not == application.site_title
    end
  end


  describe "#fetch_menu" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    it "returns the menu" do
      namespace.fetch_menu(:default).should be_an_instance_of(ActiveAdmin::Menu)
    end

    it "should have utility nav menu" do
      namespace.fetch_menu(:utility_navigation).should be_an_instance_of(ActiveAdmin::Menu)
    end

    it "should raise an exception if the menu doesn't exist" do
      expect {
        namespace.fetch_menu(:not_a_menu_that_exists)
      }.to raise_error(KeyError)
    end
  end

  describe "#build_menu" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    it "should set the block as a menu build callback" do
      namespace.build_menu do |menu|
        menu.add :label => "menu item"
      end

      namespace.fetch_menu(:default)["menu item"].should_not be_nil
    end

    it "should set a block on a custom menu" do
      namespace.build_menu :test do |menu|
        menu.add :label => "menu item"
      end

      namespace.fetch_menu(:test)["menu item"].should_not be_nil
    end
  end

  describe "utility navigation" do
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }
    let(:menu) do 
      namespace.build_menu :utility_navigation do |menu|
        menu.add :label => "ActiveAdmin.info", :url => "http://www.activeadmin.info", :html_options => { :target => :blank }
        namespace.add_logout_button_to_menu menu, 1, :class => "matt"
      end
      namespace.fetch_menu(:utility_navigation)
    end

    it "should have a logout button to the far left" do
      menu["Logout"].should_not be_nil
      menu["Logout"].priority.should == 1
    end

    it "should have a static link with a target of :blank" do
      menu["ActiveAdmin.info"].should_not be_nil
      menu["ActiveAdmin.info"].html_options.should include(:target => :blank)
    end

  end

end
require 'spec_helper'

describe ActiveAdmin::PageController do
  let(:controller) { ActiveAdmin::PageController.new }
end
# encoding: utf-8

require 'spec_helper' 
require File.expand_path('config_shared_examples', File.dirname(__FILE__))

module ActiveAdmin
  describe Page do

    it_should_behave_like "ActiveAdmin::Config"
    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= namespace.register_page("Chocolate I lØve You!", options)
    end

    describe "controller name" do
      it "should return a namespaced controller name" do
        config.controller_name.should == "Admin::ChocolateILoveYouController"
      end
      context "when non namespaced controller" do
        let(:namespace){ ActiveAdmin::Namespace.new(application, :root) }
        it "should return a non namespaced controller name" do
          config.controller_name.should == "ChocolateILoveYouController"
        end
      end
    end

    describe "#resource_name" do
      it "returns the name" do
        config.resource_name.should == "Chocolate I lØve You!"
      end

      it "returns the singular, lowercase name" do
        config.resource_name.singular.should == "chocolate i lØve you!"
      end
    end

    describe "#plural_resource_label" do
      it "returns the singular name" do
        config.plural_resource_label.should == "Chocolate I lØve You!"
      end
    end

    describe "#underscored_resource_name" do
      it "returns the resource name underscored" do
        config.underscored_resource_name.should == "chocolate_i_love_you"
      end
    end

    describe "#camelized_resource_name" do
      it "returns the resource name camel case" do
        config.camelized_resource_name.should == "ChocolateILoveYou"
      end
    end

    it "should not belong_to anything" do
      config.belongs_to?.should == false
    end

    it "should not have any action_items" do
      config.action_items?.should == false
    end

    it "should not have any sidebar_sections" do
      config.sidebar_sections?.should == false
    end

  end
end
require 'spec_helper'

describe "#pretty_format" do
  include ActiveAdmin::ViewHelpers::DisplayHelper

  context "when a String is passed in" do
    it "should return the String passed in" do
      pretty_format("hello").should == "hello"
    end
  end

  context "when a Date or a Time is passed in" do
    it "should return a localized Date or Time with long format" do
      t = Time.now
      self.should_receive(:localize).with(t, {:format => :long}) { "Just Now!" }
      pretty_format(t).should == "Just Now!"
    end
  end

  context "when an ActiveRecord object is passed in" do
    it "should delegate to auto_link" do
      post = Post.new
      self.should_receive(:auto_link).with(post) { "model name" }
      pretty_format(post).should == "model name"
    end
  end

  context "when something else is passed in" do
    it "should delegate to display_name" do
      something = Class.new.new
      self.should_receive(:display_name).with(something) { "I'm not famous" }
      pretty_format(something).should == "I'm not famous"
    end
  end
end
require 'spec_helper'

describe ActiveAdmin do

  describe "use_asset_pipeline?" do

    before(:each) do
      @orig_rails_version = Rails::VERSION::MINOR
    end

    after(:each) do
      silence_warnings { Rails::VERSION::MINOR = @orig_rails_version }
    end

    it "should be false when using rails 3.0.x" do
      silence_warnings { Rails::VERSION::MINOR = 0 }
      ActiveAdmin.use_asset_pipeline?.should be_false
    end

    context "when rails 3.1.x" do
      before(:each) do
        @orig_rails_app = Rails.application.dup
        silence_warnings { Rails::VERSION::MINOR = 1 }
      end

      after(:each) do
        Rails.application = @orig_rails_app
      end

      it "should be false without asset pipeline enabled" do
        assets = mock(:enabled => false)
        Rails.application.config.stub!(:assets => assets)
        ActiveAdmin.use_asset_pipeline?.should be_false
      end

      it "should be true with asset pipeline enabled" do
        assets = mock(:enabled => true)
        Rails.application.config.stub!(:assets => assets)
        ActiveAdmin.use_asset_pipeline?.should be_true
      end
    end
  end
end
require 'spec_helper'

# Ensure we have both constants to play with
begin
  ActionDispatch::Reloader
rescue
  module ActionDispatch; module Reloader; def self.to_prepare; end; end; end
end

begin
  ActionDispatch::Callbacks
rescue
  module ActionDispatch; module Callbacks; def self.to_prepare; end; end; end
end

major_rails_version = Rails.version[0..2]


describe ActiveAdmin::Reloader do

  let(:rails_app){ mock(:reload_routes! => true)}
  let(:mock_app){ mock(:load_paths => ["app/admin"], :unload! => true)}
  let(:reloader){ ActiveAdmin::Reloader.build(rails_app, mock_app, rails_version) }

  context "when Rails version < 3.2" do
    let(:rails_version){ TRAVIS_RAILS_VERSIONS.grep(/^3.1/).first }

    describe "initialization" do

      it "should initialize a new file update checker" do
        ActiveSupport::FileUpdateChecker.should_receive(:new).with(mock_app.load_paths).and_return(mock(:execute_if_updated => true))
        ActiveAdmin::Reloader.build(rails_app, mock_app, TRAVIS_RAILS_VERSIONS.grep(/^3.1/).first)
      end

      it "should build a RailsLessThan31Reloader" do
        reloader.class.should == ActiveAdmin::Reloader::RailsLessThan31Reloader
      end

    end

    describe "#reloader_class" do

      it "should use ActionDispatch::Reloader if rails 3.1" do
        reloader = ActiveAdmin::Reloader.build rails_app, mock_app, TRAVIS_RAILS_VERSIONS.grep(/^3.1/).first
        reloader.reloader_class.should == ActionDispatch::Reloader
      end

      it "should use ActionDispatch::Callbacks if rails 3.0" do
        reloader = ActiveAdmin::Reloader.build rails_app, mock_app, TRAVIS_RAILS_VERSIONS.grep(/^3.0/).first
        reloader.reloader_class.should == ActionDispatch::Callbacks
      end

    end

    describe "#reload!" do

      it "should unload the active admin app" do
        mock_app.should_receive(:unload!)
        reloader.reload!
      end

      it "should reload the rails app routes" do
        rails_app.should_receive(:reload_routes!)
        reloader.reload!
      end

      it 'should reset the files within the file_update_checker' do
        reloader.file_update_checker.paths.should_receive(:clear)
        reloader.file_update_checker.paths.should_receive(:<<).with("app/admin")
        reloader.reload!
      end

    end

    describe "#watched_paths" do
      let(:mock_app){ ActiveAdmin::Application.new }
      let(:admin_path){ File.join(Rails.root, "app", "admin") }

      before do
        mock_app.load_paths = [admin_path]
      end

      it "should return the load path directories" do
        reloader.watched_paths.should include(admin_path)
      end

      it "should include all files in the directory" do
        root = Rails.root + "/app/admin"
        reloader.watched_paths.should include(*Dir["#{admin_path}/**/*.rb"])
      end

    end

  end

  context "when Rails >= 3.2" do
    let(:rails_version){ TRAVIS_RAILS_VERSIONS.grep(/^3.2/).first }

    describe "initialization" do

      it "should build a Rails32Reloader" do
        reloader.class.should == ActiveAdmin::Reloader::Rails32Reloader
      end

    end

    describe "attach!" do
      before do
        mock_app.load_paths << "app/active_admin"
        ActionDispatch::Reloader.stub!(:to_prepare => true)
      end

      it "should the load paths to the watchable_dirs" do
        config = mock(:watchable_dirs => {})
        rails_app.should_receive(:config).twice.and_return(config)
        reloader.attach!

        config.watchable_dirs["app/admin"].should == [:rb]
        config.watchable_dirs["app/active_admin"].should == [:rb]
      end
    end
  end

end
require 'spec_helper'

describe ActiveAdmin::Resource::ActionItems do

  let(:resource) do
    namespace = ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin)
    namespace.register(Post)
  end

  describe "adding a new action item" do

    before do
      resource.clear_action_items!
      resource.add_action_item do
        # Empty ...
      end
    end

    it "should add an action item" do
      resource.action_items.size.should == 1
    end

    it "should store an instance of ActionItem" do
      resource.action_items.first.should be_an_instance_of(ActiveAdmin::ActionItem)
    end

    it "should store the block in the action item" do
      resource.action_items.first.block.should_not be_nil
    end

  end

  describe "setting an action item to only display on specific controller actions" do

    before do
      resource.clear_action_items!
      resource.add_action_item :only => :index do
        raise StandardError
      end
      resource.add_action_item :only => :show do
        # Empty ...
      end
    end

    it "should return only relevant action items" do
      resource.action_items_for(:index).size.should == 1
      lambda {
        resource.action_items_for(:index).first.call
      }.should raise_exception(StandardError)
    end

  end

  describe "default action items" do

    it "should have 3 action items" do
      resource.action_items.size.should == 3
    end

  end

end
require 'spec_helper' 

module ActiveAdmin
  describe Resource, "Menu" do

    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= Resource.new(namespace, Category, options)
    end

    # TODO...

  end
end
require 'spec_helper'

module ActiveAdmin
  describe Resource, "Naming" do

    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= Resource.new(namespace, Category, options)
    end

    module ::Mock class Resource < ActiveRecord::Base; end; end
    module NoActiveModel class Resource; end; end

    describe "singular resource name" do
      context "when class" do
        it "should be the underscored singular resource name" do
          config.resource_name.singular.should == "category"
        end
      end
      context "when a class in a module" do
        it "should underscore the module and the class" do
          Resource.new(namespace, Mock::Resource).resource_name.singular.should == "mock_resource"
        end
      end
      context "when you pass the 'as' option" do
        it "should underscore the passed through string" do
          config(:as => "Blog Category").resource_name.singular.should == "blog_category"
        end
      end
    end

    describe "resource label" do
      it "should return a pretty name" do
        config.resource_label.should == "Category"
      end

      it "should return the plural version" do
        config.plural_resource_label.should == "Categories"
      end

      context "when the :as option is given" do
        it "should return the custom name" do
          config(:as => "My Category").resource_label.should == "My Category"
        end
      end

      context "when a class in a module" do
        it "should include the module and the class" do
          Resource.new(namespace, Mock::Resource).resource_label.should == "Mock Resource"
        end

        it "should include the module and the pluralized class" do
          Resource.new(namespace, Mock::Resource).plural_resource_label.should == "Mock Resources"
        end
      end

      describe "I18n integration" do
        describe "singular label" do
          it "should return the titleized model_name.human" do
            config.resource_name.should_receive(:translate).and_return "Da category"

            config.resource_label.should == "Da category"
          end
        end

        describe "plural label" do
          it "should return the titleized plural version defined by i18n if available" do
            config.resource_name.should_receive(:translate).at_least(:once).and_return "Da categories"
            config.plural_resource_label.should == "Da categories"
          end
        end

        context "when the :as option is given" do
          describe "singular label" do
            it "should translate the custom name" do
              config = config(:as => 'My Category')
              config.resource_name.should_receive(:translate).and_return "Translated category"
              config.resource_label.should == "Translated category"
            end
          end

          describe "plural label" do
            it "should translate the custom name" do
              config = config(:as => 'My Category')
              config.resource_name.should_receive(:translate).at_least(:once).and_return "Translated categories"
              config.plural_resource_label.should == "Translated categories"
            end
          end
        end

      end
    end

  end
end
require 'spec_helper'

describe ActiveAdmin::Resource::PagePresenters do

  let(:namespace){ ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin) }
  let(:resource){ namespace.register(Post) }

  it "should have an empty set of configs on initialize" do
    resource.page_presenters.should == {}
  end

  it "should add a show page presenter" do
    page_presenter = ActiveAdmin::PagePresenter.new
    resource.set_page_presenter(:show, page_presenter)
    resource.page_presenters[:show].should == page_presenter
  end

  it "should add an index page presenter" do
    page_presenter = ActiveAdmin::PagePresenter.new({:as => :table})
    resource.set_page_presenter(:index, page_presenter)
    resource.page_presenters[:index].default.should == page_presenter
  end

  describe "#get_page_presenter" do

    it "should return a page config when set" do
      page_presenter = ActiveAdmin::PagePresenter.new
      resource.set_page_presenter(:index, page_presenter)
      resource.get_page_presenter(:index).should == page_presenter
    end

    it "should return a specific index page config when set" do
      page_presenter = ActiveAdmin::PagePresenter.new
      resource.set_page_presenter(:index, page_presenter)
      resource.get_page_presenter(:index, "table").should == page_presenter
    end

    it "should return nil when no page config set" do
      resource.get_page_presenter(:index).should == nil
    end

  end

end
require 'spec_helper' 

module ActiveAdmin
  describe Resource, "Pagination" do

    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= Resource.new(namespace, Category, options)
    end

    describe "#paginate" do
      it "should default to true" do
        config.paginate.should == true
      end

      it "should be settable to false" do
        config.paginate = false
        config.paginate.should == false
      end
    end

    describe "#per_page" do
      it "should default to namespace.default_per_page" do
        namespace.should_receive(:default_per_page).and_return(5)
        config.per_page.should == 5
      end
      
      it "should be settable" do
        config.per_page = 5
        config.per_page.should == 5
      end
    end
  end
end
require 'spec_helper' 

module ActiveAdmin
  describe Resource, "Scopes" do

    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= Resource.new(namespace, Category, options)
    end

    describe "adding a scope" do

      it "should add a scope" do
        config.scope :published
        config.scopes.first.should be_a(ActiveAdmin::Scope)
        config.scopes.first.name.should == "Published"
      end

      it "should retrive a scope by its id" do
        config.scope :published
        config.get_scope_by_id(:published).name.should == "Published"
      end

      it "should not add a scope with the same name twice" do
        config.scope :published
        config.scope :published
        config.scopes.size.should == 1
      end

      it "should update a scope with the same id" do
        config.scope :published
        config.scopes.first.scope_block.should be_nil
        config.scope(:published){  }
        config.scopes.first.scope_block.should_not be_nil
      end

    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Resource::Sidebars do

  let(:resource) do
    namespace = ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :admin)
    namespace.register(Post)
  end

  let(:sidebar) { ActiveAdmin::SidebarSection.new(:help) }

  describe "adding a new sidebar section" do

    before do
      resource.clear_sidebar_sections!
      resource.sidebar_sections << sidebar
    end

    it "should add a sidebar section" do
      resource.should have(1).sidebar_sections
    end

  end

  describe "retrieving sections for a controller action" do

    let(:only_index){ ActiveAdmin::SidebarSection.new(:help, :only => :index) }
    let(:only_show){ ActiveAdmin::SidebarSection.new(:help, :only => :show) }

    before do
      resource.clear_sidebar_sections!
      resource.sidebar_sections << only_index
      resource.sidebar_sections << only_show
    end

    it "should only return the relevant action items" do
      resource.should have(2).sidebar_sections
      resource.sidebar_sections_for("index").should == [only_index]
    end

  end

end
require 'spec_helper'
require 'active_admin/resource_collection'

include ActiveAdmin

describe ActiveAdmin::ResourceCollection do

  let(:collection){ ResourceCollection.new }

  it "should have no resources when new" do
    collection.resources.should == []
  end

  it "should be enumerable" do
    resource = mock(:resource_name => "MyResource")
    collection.add(resource)
    collection.each{|r| r.should == resource }
  end

  it "should return the available keys" do
    resource = mock(:resource_name => "MyResource")
    collection.add resource
    collection.keys.should == [resource.resource_name]
  end

  describe "adding a new resource" do
    let(:resource){ mock(:resource_name => "MyResource") }

    it "should return the resource" do
      collection.add(resource).should == resource
    end

    it "should add a new resource" do
      collection.add(resource)
      collection.resources.should == [resource]
    end

    it "should be available by name" do
      collection.add(resource)
      collection.find_by_key(resource.resource_name).should == resource
    end
  end

  describe "adding a new resource when the key already exists" do
    let(:stored_resource){ mock(:resource_name => "MyResource") }
    let(:resource){ mock(:resource_name => "MyResource") }

    before do
      collection.add(stored_resource)
    end

    it "should return the original resource" do
      collection.add(resource).should == stored_resource
    end

    it "should not add a new resource" do
      collection.add(resource)
      collection.resources.should == [stored_resource]
    end
  end

  describe "adding an existing resource key with a different resource class" do
    let(:stored_resource){ mock(:resource_name => "MyResource", :resource_class => mock) }
    let(:resource){ mock(:resource_name => "MyResource", :resource_class => mock) }

    it "should raise a ActiveAdmin::ResourceMismatchError" do
      collection.add(stored_resource)
      lambda {
        collection.add(resource)
      }.should raise_error(ActiveAdmin::ResourceMismatchError)
    end

  end

  describe "#find_by_resource_class" do

    let(:base_class){ mock(:to_s => "BaseClass")}
    let(:resource_from_base_class){ mock(:resource_name => "MyBaseClassResource", :resource_class => base_class )}
    let(:resource_class){ mock(:base_class => base_class, :to_s => "ResourceClass") }
    let(:resource){ mock(:resource_name => "MyResource", :resource_class => resource_class) }

    it "should find a resource when it's in the collection" do
      collection.add resource
      collection.find_by_resource_class(resource_class).should == resource
    end

    it "should return nil when the resource class is not in the collection" do
      collection.find_by_resource_class(resource_class).should == nil
    end

    it "should return the resource when it and it's base class is in the collection" do
      collection.add resource_from_base_class
      collection.find_by_resource_class(resource_class).should == resource_from_base_class
    end

    it "should return nil the resource_class does not repond to base_class and it's not in the collection" do
      collection.find_by_resource_class(mock).should == nil
    end
  end

end
require 'spec_helper'

describe ActiveAdmin::ResourceController::DataAccess do
  let(:params) do
    {}
  end

  let(:controller) do
    rc = Admin::PostsController.new
    rc.stub!(:params) do
      params
    end
    rc
  end

  describe "searching" do
    let(:params){ {:q => {} }}

    it "should call the metasearch method" do
      chain = mock("ChainObj")
      chain.should_receive(:metasearch).with(params[:q]).once.and_return(Post.search)
      controller.send :apply_filtering, chain
    end

  end

  describe "sorting" do

    context "for table columns" do
      let(:params){ {:order => "id_asc" }}
      it "should prepend the table name" do
        chain = mock("ChainObj")
        chain.should_receive(:reorder).with("\"posts\".\"id\" asc").once.and_return(Post.search)
        controller.send :apply_sorting, chain
      end
    end

    context "for virtual columns" do
      let(:params){ {:order => "virtual_id_asc" }}
      it "should not prepend the table name" do
        chain = mock("ChainObj")
        chain.should_receive(:reorder).with("\"virtual_id\" asc").once.and_return(Post.search)
        controller.send :apply_sorting, chain
      end
    end

  end

  describe "scoping" do

    context "when no current scope" do
      it "should set collection_before_scope to the chain and return the chain" do
        chain = mock("ChainObj")
        controller.send(:apply_scoping, chain).should == chain
        controller.send(:collection_before_scope).should == chain
      end
    end

    context "when current scope" do
      it "should set collection_before_scope to the chain and return the scoped chain" do
        chain = mock("ChainObj")
        scoped_chain = mock("ScopedChain")
        current_scope = mock("CurrentScope")
        controller.stub!(:current_scope) { current_scope }

        controller.should_receive(:scope_chain).with(current_scope, chain) { scoped_chain }
        controller.send(:apply_scoping, chain).should == scoped_chain
        controller.send(:collection_before_scope).should == chain
      end
    end

  end

end
require 'spec_helper'

describe ActiveAdmin::ResourceController::Sidebars do
  let(:controller){ Admin::PostsController }

  context 'without before_filter' do
    before do
      ActiveAdmin.register Post
    end

    subject { find_before_filter controller, :skip_sidebar! }

    it { should set_skip_sidebar_to nil }
  end

  describe '#skip_sidebar!' do
    before do
      ActiveAdmin.register Post do
        before_filter :skip_sidebar!
      end
    end

    subject { find_before_filter controller, :skip_sidebar! }

    it { should set_skip_sidebar_to true }
  end

  def find_before_filter(controller, filter)
    #raise controller._process_action_callbacks.map(&:filter).inspect
    controller._process_action_callbacks.detect { |f| f.raw_filter == filter.to_sym }
  end

  RSpec::Matchers.define :set_skip_sidebar_to do |expected|
    match do |filter|
      klass = filter && filter.klass || controller
      object = klass.new
      object.send filter.raw_filter if filter
      @actual = object.instance_variable_get(:@skip_sidebar)
      @actual == expected
    end

    failure_message_for_should do |filter|
      message = "expected before_filter to set @skip_sidebar to '#{expected}', but was '#{@actual}'"
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::ResourceController do

  before(:all) { load_defaults! }

  let(:controller) { ActiveAdmin::ResourceController.new }

  describe "authenticating the user" do
    let(:controller){ Admin::PostsController.new }

    it "should do nothing when no authentication_method set" do
      namespace = controller.class.active_admin_config.namespace
      namespace.should_receive(:authentication_method).once.and_return(nil)

      controller.send(:authenticate_active_admin_user)
    end

    it "should call the authentication_method when set" do
      namespace = controller.class.active_admin_config.namespace

      namespace.should_receive(:authentication_method).twice.
        and_return(:authenticate_admin_user!)

      controller.should_receive(:authenticate_admin_user!).and_return(true)

      controller.send(:authenticate_active_admin_user)
    end

  end

  describe "retrieving the current user" do
    let(:controller){ Admin::PostsController.new }

    it "should return nil when no current_user_method set" do
      namespace = controller.class.active_admin_config.namespace
      namespace.should_receive(:current_user_method).once.and_return(nil)

      controller.send(:current_active_admin_user).should == nil
    end

    it "should call the current_user_method when set" do
      user = mock
      namespace = controller.class.active_admin_config.namespace

      namespace.should_receive(:current_user_method).twice.
        and_return(:current_admin_user)

      controller.should_receive(:current_admin_user).and_return(user)

      controller.send(:current_active_admin_user).should == user
    end
  end


  describe "callbacks" do
    let(:application){ ::ActiveAdmin::Application.new }
    let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }

    before :all do
      namespace.register Post do
        after_build :call_after_build
        before_save :call_before_save
        after_save :call_after_save
        before_create :call_before_create
        after_create :call_after_create
        before_update :call_before_update
        after_update :call_after_update
        before_destroy :call_before_destroy
        after_destroy :call_after_destroy

        controller do
          def call_after_build(obj); end
          def call_before_save(obj); end
          def call_after_save(obj); end
          def call_before_create(obj); end
          def call_after_create(obj); end
          def call_before_update(obj); end
          def call_after_update(obj); end
          def call_before_destroy(obj); end
          def call_after_destroy(obj); end
        end
      end
    end

    describe "performing create" do
      let(:controller){ Admin::PostsController.new }
      let(:resource){ mock("Resource", :save => true) }

      before do
        resource.should_receive(:save)
      end

      it "should call the before create callback" do
        controller.should_receive(:call_before_create).with(resource)
        controller.send :create_resource, resource
      end
      it "should call the before save callback" do
        controller.should_receive(:call_before_save).with(resource)
        controller.send :create_resource, resource
      end
      it "should call the after save callback" do
        controller.should_receive(:call_after_save).with(resource)
        controller.send :create_resource, resource
      end
      it "should call the after create callback" do
        controller.should_receive(:call_after_create).with(resource)
        controller.send :create_resource, resource
      end
    end

    describe "performing update" do
      let(:controller){ Admin::PostsController.new }
      let(:resource){ mock("Resource", :attributes= => true, :save => true) }
      let(:attributes){ [{}] }

      before do
        resource.should_receive(:attributes=).with(attributes[0])
        resource.should_receive(:save)
      end

      it "should call the before update callback" do
        controller.should_receive(:call_before_update).with(resource)
        controller.send :update_resource, resource, attributes
      end
      it "should call the before save callback" do
        controller.should_receive(:call_before_save).with(resource)
        controller.send :update_resource, resource, attributes
      end
      it "should call the after save callback" do
        controller.should_receive(:call_after_save).with(resource)
        controller.send :update_resource, resource, attributes
      end
      it "should call the after create callback" do
        controller.should_receive(:call_after_update).with(resource)
        controller.send :update_resource, resource, attributes
      end
    end

    describe "performing destroy" do
      let(:controller){ Admin::PostsController.new }
      let(:resource){ mock("Resource", :destroy => true) }

      before do
        resource.should_receive(:destroy)
      end

      it "should call the before destroy callback" do
        controller.should_receive(:call_before_destroy).with(resource)
        controller.send :destroy_resource, resource
      end

      it "should call the after destroy callback" do
        controller.should_receive(:call_after_destroy).with(resource)
        controller.send :destroy_resource, resource
      end
    end
  end
end

describe Admin::PostsController, :type => "controller" do

  describe 'retreiving the resource' do
    let(:controller){ Admin::PostsController.new }
    let(:post) { Post.new :title => "An incledibly unique Post Title" }

    before do
      Post.stub(:find).and_return(post)
      controller.class_eval { public :resource }
      controller.stub(:params).and_return({ :id => '1' })
    end

    subject { controller.resource }

    it "returns a Post" do
      subject.should be_kind_of(Post)
    end

    context 'with a decorator' do
      let(:config) { controller.class.active_admin_config }
      before { config.decorator_class_name = '::PostDecorator' }
      it 'returns a PostDecorator' do
        subject.should be_kind_of(PostDecorator)
      end

      it 'returns a PostDecorator that wraps the post' do
        subject.title.should == post.title
      end
    end
  end

  describe 'retreiving the resource collection' do
    let(:controller){ Admin::PostsController.new }
    before do
      Post.create!(:title => "An incledibly unique Post Title") if Post.count == 0
      controller.class_eval { public :collection }
    end

    subject { controller.collection }

    it {
      pending # doesn't pass when running whole spec suite (WTF)
      should be_kind_of(ActiveRecord::Relation)
    }

    it "returns a collection of posts" do
      pending # doesn't pass when running whole spec suite (WTF)
      subject.first.should be_kind_of(Post)
    end

    context 'with a decorator' do
      let(:config) { controller.class.active_admin_config }
      before { config.decorator_class_name = '::PostDecorator' }

      it 'returns a PostDecorator' do
        pending # doesn't pass when running whole spec suite (WTF)
        subject.should be_kind_of(PostDecorator::DecoratedEnumerableProxy)
      end

      it 'returns a PostDecorator that wraps the post' do
        pending # doesn't pass when running whole spec suite (WTF)
        subject.first.title.should == Post.first.title
      end
    end
  end


  describe "performing batch_action" do
    let(:controller){ Admin::PostsController.new }
    before do
      batch_action = ActiveAdmin::BatchAction.new :flag, "Flag" do
        redirect_to collection_path
      end

      controller.class.active_admin_config.stub!(:batch_actions).and_return([batch_action])
    end

    describe "when params batch_action matches existing BatchAction" do
      it "should call the block with args" do
        pending # dont know how to check if the block was called
      end
    end

    describe "when params batch_action doesn't match a BatchAction" do
      it "should raise an error" do
        pending # doesn't pass when running whole spec suite (WTF)

        lambda {
          post(:batch_action, :batch_action => "derp", :collection_selection => ["1"])
        }.should raise_error("Couldn't find batch action \"derp\"")
      end
    end

    describe "when params batch_action is blank" do
      it "should raise an error" do
        pending # doesn't pass when running whole spec suite (WTF)

        lambda {
          post(:batch_action, :collection_selection => ["1"])
        }.should raise_error("Couldn't find batch action \"\"")
      end
    end

  end

end
require 'spec_helper' 

describe "Registering an object to administer" do
  let(:application){ ActiveAdmin::Application.new }

  context "with no configuration" do
    let(:namespace) { ActiveAdmin::Namespace.new(application, :admin) }
    it "should call register on the namespace" do
      application.namespaces[namespace.name] = namespace
      namespace.should_receive(:register)

      application.register Category
    end

    it "should dispatch a Resource::RegisterEvent" do
      ActiveAdmin::Event.should_receive(:dispatch).with(ActiveAdmin::Resource::RegisterEvent, an_instance_of(ActiveAdmin::Resource))
      application.register Category
    end
  end

  context "with a different namespace" do
    it "should call register on the namespace" do
      namespace = ActiveAdmin::Namespace.new(application, :hello_world)
      application.namespaces[namespace.name] = namespace
      namespace.should_receive(:register)

      application.register Category, :namespace => :hello_world
    end

    it "should generate a Namespace::RegisterEvent and a Resource::RegisterEvent" do
      ActiveAdmin::Event.should_receive(:dispatch).with(ActiveAdmin::Namespace::RegisterEvent, an_instance_of(ActiveAdmin::Namespace))
      ActiveAdmin::Event.should_receive(:dispatch).with(ActiveAdmin::Resource::RegisterEvent, an_instance_of(ActiveAdmin::Resource))
      application.register Category, :namespace => :not_yet_created
    end
  end

  context "with no namespace" do
    it "should call register on the root namespace" do
      namespace = ActiveAdmin::Namespace.new(application, :root)
      application.namespaces[namespace.name] = namespace
      namespace.should_receive(:register)

      application.register Category, :namespace => false
    end
  end

  context "when being registered multiple times" do
    it "should run the dsl in the same config object" do
      config_1 = ActiveAdmin.register(Category) { filter :name }
      config_2 = ActiveAdmin.register(Category) { filter :id }
      config_1.should == config_2
      config_1.filters.size.should == 2
    end

    context "with different resource classes" do
      it "should raise an ActiveAdmin::ResourceMismatch" do
        lambda {
          ActiveAdmin.register Category
          ActiveAdmin.register Post, :as => "Category"
        }.should raise_error(ActiveAdmin::ResourceMismatchError)
      end
    end
  end

end
require 'spec_helper' 
require File.expand_path('config_shared_examples', File.dirname(__FILE__))

module ActiveAdmin
  describe Resource do

    it_should_behave_like "ActiveAdmin::Config"

    before { load_defaults! }

    let(:application){ ActiveAdmin::Application.new }
    let(:namespace){ Namespace.new(application, :admin) }

    def config(options = {})
      @config ||= Resource.new(namespace, Category, options)
    end

    it { respond_to :resource_class }

    describe "#resource_table_name" do
      it "should return the resource's table name" do
        config.resource_table_name.should == '"categories"'
      end
      context "when the :as option is given" do
        it "should return the resource's table name" do
          config(:as => "My Category").resource_table_name.should == '"categories"'
        end
      end
    end

    describe "#resource_column_names" do
      it "should return the resource's column names" do
        config.resource_column_names.should == Category.column_names
      end
    end

    describe '#decorator_class' do
      it 'returns nil by default' do
        config.decorator_class.should be_nil
      end
      context 'when a decorator is defined' do
        let(:resource) { namespace.register(Post) { decorate_with PostDecorator } }
        specify '#decorator_class_name should return PostDecorator' do
          resource.decorator_class_name.should == '::PostDecorator'
        end

        it 'returns the decorator class' do
          resource.decorator_class.should == PostDecorator
        end
      end
    end


    describe "controller name" do
      it "should return a namespaced controller name" do
        config.controller_name.should == "Admin::CategoriesController"
      end
      context "when non namespaced controller" do
        let(:namespace){ ActiveAdmin::Namespace.new(application, :root) }
        it "should return a non namespaced controller name" do
          config.controller_name.should == "CategoriesController"
        end
      end
    end

    describe "#include_in_menu?" do
      let(:namespace){ ActiveAdmin::Namespace.new(application, :admin) }
      subject{ resource }

      context "when regular resource" do
        let(:resource){ namespace.register(Post) }
        it { should be_include_in_menu }
      end

      context "when menu set to false" do
        let(:resource){ namespace.register(Post){ menu false } }
        it { should_not be_include_in_menu }
      end
    end

    describe "#belongs_to" do

      it "should build a belongs to configuration" do
        config.belongs_to_config.should be_nil
        config.belongs_to :posts
        config.belongs_to_config.should_not be_nil
      end

      it "should set the target menu to the belongs to target" do
        config.menu_item_menu_name.should == ActiveAdmin::DEFAULT_MENU
        config.belongs_to :posts
        config.menu_item_menu_name.should == :posts
      end

    end

    describe "route names" do
      it "should return the route prefix" do
        config.route_prefix.should == "admin"
      end
      it "should return the route collection path" do
        config.route_collection_path.should == "/admin/categories"
      end

      context "when in the root namespace" do
        let(:config){ application.register Category, :namespace => false}
        it "should have a nil route_prefix" do
          config.route_prefix.should == nil
        end

        it "should generate a correct route" do
          config
          reload_routes!
          config.route_collection_path.should == "/categories"
        end
      end

      context "when registering a plural resource" do
        class ::News; def self.has_many(*); end end

        it "should return the plurali route with _index" do
          config = application.register News
          reload_routes!
          config.route_collection_path.should == "/admin/news"
        end
      end
    end

    describe "scoping" do
      context "when using a block" do
        before do
          @resource = application.register Category do
            scope_to do
              "scoped"
            end
          end
        end
        it "should call the proc for the begin of association chain" do
          begin_of_association_chain = @resource.controller.new.send(:begin_of_association_chain)
          begin_of_association_chain.should == "scoped"
        end
      end

      context "when using a symbol" do
        before do
          @resource = application.register Category do
            scope_to :current_user
          end
        end
        it "should call the method for the begin of association chain" do
          controller = @resource.controller.new
          controller.should_receive(:current_user).and_return(true)
          begin_of_association_chain = controller.send(:begin_of_association_chain)
          begin_of_association_chain.should == true
        end
      end

      context "when not using a block or symbol" do
        before do
          @resource = application.register Category do
            scope_to "Some string"
          end
        end
        it "should raise and exception" do
          lambda {
            @resource.controller.new.send(:begin_of_association_chain)
          }.should raise_error(ArgumentError)
        end
      end

      describe "getting the method for the association chain" do
        context "when a simple registration" do
          before do
            @resource = application.register Category do
              scope_to :current_user
            end
          end
          it "should return the pluralized collection name" do
            @resource.controller.new.send(:method_for_association_chain).should == :categories
          end
        end
        context "when passing in the method as an option" do
          before do
            @resource = application.register Category do
              scope_to :current_user, :association_method => :blog_categories
            end
          end
          it "should return the method from the option" do
            @resource.controller.new.send(:method_for_association_chain).should == :blog_categories
          end
        end
      end
    end


    describe "sort order" do

      context "when resource class responds to primary_key" do
        it "should sort by primary key desc by default" do
          MockResource.should_receive(:primary_key).and_return("pk")
          config = Resource.new(namespace, MockResource)
          config.sort_order.should == "pk_desc"
        end
      end

      context "when resource class does not respond to primary_key" do
        it "should default to id" do
          config = Resource.new(namespace, MockResource)
          config.sort_order.should == "id_desc"
        end
      end

      it "should be set-able" do
        config.sort_order = "task_id_desc"
        config.sort_order.should == "task_id_desc"
      end

    end

    describe "adding a scope" do

      it "should add a scope" do
        config.scope :published
        config.scopes.first.should be_a(ActiveAdmin::Scope)
        config.scopes.first.name.should == "Published"
      end

      it "should retrive a scope by its id" do
        config.scope :published
        config.get_scope_by_id(:published).name.should == "Published"
      end
    end

    describe "#csv_builder" do
      context "when no csv builder set" do
        it "should return a default column builder with id and content columns" do
          config.csv_builder.columns.size.should == Category.content_columns.size + 1
        end
      end

      context "when csv builder set" do
        it "shuld return the csv_builder we set" do
          csv_builder = CSVBuilder.new
          config.csv_builder = csv_builder
          config.csv_builder.should == csv_builder
        end
      end
    end
  end
end
# encoding: utf-8

require 'spec_helper'

describe ActiveAdmin, "Routing", :type => :routing do

  before do
    load_defaults!
    reload_routes!
  end

  include Rails.application.routes.url_helpers

  describe "root" do
    before do
      pending "Y U NO PASS?"
    end
    context "when default configuration" do
      context "when in admin namespace" do
        it "should route the admin dashboard" do
          get('/admin').should route_to('admin/dashboard#index')
        end
      end

      context "when in root namespace" do
        before(:each) do
          load_resources { ActiveAdmin.register(Post, :namespace => false) }
          reload_routes!
        end

        it "should route the root dashboard" do
          pending "Y U NO PASS?"

          get('/').should route_to('dashboard#index')
        end
      end
    end

    context "when customized configuration to root to post#index" do
      before do
        @original_root = ActiveAdmin.application.root_to
        ActiveAdmin.application.root_to = "posts#index"
      end

      after do
        ActiveAdmin.application.root_to = @original_root
        reload_routes!
      end

      context "when in admin namespace" do
        before do
          load_resources { ActiveAdmin.register(Post) }
        end

        it "should route to admin/posts#index" do
          get('/admin').should route_to('admin/posts#index')
        end
      end

      context "when in root namespace" do
        before do
          load_resources { ActiveAdmin.register(Post, :namespace => false) }
        end

        it "should route to posts#index" do
          pending "Y U NO PASS?"

          get('/').should route_to('posts#index')
        end
      end
    end
  end

  describe "standard resources" do
    context "when in admin namespace" do
      it "should route the index path" do
        admin_posts_path.should == "/admin/posts"
      end

      it "should route the show path" do
        admin_post_path(1).should == "/admin/posts/1"
      end

      it "should route the new path" do
        new_admin_post_path.should == "/admin/posts/new"
      end

      it "should route the edit path" do
        edit_admin_post_path(1).should == "/admin/posts/1/edit"
      end
    end

    context "when in root namespace" do
      before(:each) do
        load_resources { ActiveAdmin.register(Post, :namespace => false) }
      end

      it "should route the index path" do
        posts_path.should == "/posts"
      end

      it "should route the show path" do
        post_path(1).should == "/posts/1"
      end

      it "should route the new path" do
        new_post_path.should == "/posts/new"
      end

      it "should route the edit path" do
        edit_post_path(1).should == "/posts/1/edit"
      end
    end

    context "with member action" do
      context "without an http verb" do
        before do
          load_resources do 
            ActiveAdmin.register(Post){ member_action "do_something" }
          end
        end

        it "should default to GET" do
          {:get  => "/admin/posts/1/do_something"}.should     be_routable
          {:post => "/admin/posts/1/do_something"}.should_not be_routable
        end
      end

      context "with one http verb" do
        before do
          load_resources do 
            ActiveAdmin.register(Post){ member_action "do_something", :method => :post }
          end
        end

        it "should properly route" do
          {:post => "/admin/posts/1/do_something"}.should be_routable
        end
      end

      context "with two http verbs" do
        before do
          load_resources do 
            ActiveAdmin.register(Post){ member_action "do_something", :method => [:put, :delete] }
          end
        end

        it "should properly route the first verb" do
          {:put => "/admin/posts/1/do_something"}.should be_routable
        end

        it "should properly route the second verb" do        
          {:delete => "/admin/posts/1/do_something"}.should be_routable     
        end
      end
    end
  end

  describe "belongs to resource" do
    it "should route the nested index path" do
      admin_user_posts_path(1).should == "/admin/users/1/posts"
    end

    it "should route the nested show path" do
      admin_user_post_path(1,2).should == "/admin/users/1/posts/2"
    end

    it "should route the nested new path" do
      new_admin_user_post_path(1).should == "/admin/users/1/posts/new"
    end

    it "should route the nested edit path" do
      edit_admin_user_post_path(1,2).should == "/admin/users/1/posts/2/edit"
    end

    context "with collection action" do
      before do
        load_resources do
          ActiveAdmin.register(Post) do
            belongs_to :user, :optional => true
          end
          ActiveAdmin.register(User) do
            collection_action "do_something"
          end
        end
      end

      it "should properly route the collection action" do
        { :get => "/admin/users/do_something" }.
          should route_to({ :controller => 'admin/users',:action => 'do_something'})
      end
    end
  end

  describe "page" do
    context "when default namespace" do
      before(:each) do
        load_resources { ActiveAdmin.register_page("Chocolate I lØve You!") }
      end

      it "should route to the page under /admin" do
        admin_chocolate_i_love_you_path.should == "/admin/chocolate_i_love_you"
      end

      context "when in the root namespace" do
        before(:each) do
          load_resources { ActiveAdmin.register_page("Chocolate I lØve You!", :namespace => false) }
        end

        it "should route to page under /" do
          chocolate_i_love_you_path.should == "/chocolate_i_love_you"
        end
      end

      context "when singular page name" do
        before(:each) do
          load_resources { ActiveAdmin.register_page("Log") }
        end

        it "should not inject _index_ into the route name" do
          admin_log_path.should == "/admin/log"
        end
      end
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Sass::Helpers do

  include ActiveAdmin::Sass::Helpers

  context "when not using the asset pipeline" do

    before(:all)do
      @actual_rails_version = Rails::VERSION::MINOR
      silence_warnings { Rails::VERSION::MINOR = 0 }
    end

    after(:all) do
      silence_warnings { Rails::VERSION::MINOR = @actual_rails_version }
    end

    it "should generate an image asset path to /images/active_admin" do
      active_admin_image_path(Sass::Script::String.new('test.jpg')).should ==
          Sass::Script::String.new("/images/active_admin/test.jpg", true)
    end

  end

  context "when using the asset pipeline" do
    before(:all)do
      @actual_rails_version = Rails::VERSION::MINOR
      silence_warnings { Rails::VERSION::MINOR = 1 }
    end

    after(:all) do
      silence_warnings { Rails::VERSION::MINOR = @actual_rails_version }
    end

    before do
      assets = mock(:enabled => true)
      Rails.application.config.stub!(:assets => assets)
    end

    it "should call the sass-rails asset helper" do
      self.should_receive(:asset_path).with(Sass::Script::String.new("active_admin/test.jpg"), Sass::Script::String.new('image'))
      active_admin_image_path(::Sass::Script::String.new('test.jpg'))
    end

  end

end
require 'spec_helper'

describe ActiveAdmin::Scope do

  describe "creating a scope" do
    subject{ scope }

    context "when just a scope method" do
      let(:scope)        { ActiveAdmin::Scope.new :published }
      its(:name)         { should == "Published"}
      its(:id)           { should == "published"}
      its(:scope_method) { should == :published }
    end

    context "when scope method is :all" do
      let(:scope)        { ActiveAdmin::Scope.new :all }
      its(:name)         { should == "All"}
      its(:id)           { should == "all"}
      # :all does not return a chain but an array of active record
      # instances. We set the scope_method to nil then.
      its(:scope_method) { should == nil }
      its(:scope_block)  { should == nil }
    end

    context 'when a name and scope method is :all' do
      let(:scope)        { ActiveAdmin::Scope.new 'Tous', :all }
      its(:name)         { should eq 'Tous' }
      its(:scope_method) { should be_nil }
      its(:scope_block)  { should be_nil }
    end

    context "when a name and scope method" do
      let(:scope)        { ActiveAdmin::Scope.new "With API Access", :with_api_access }
      its(:name)         { should == "With API Access"}
      its(:id)           { should == "with_api_access"}
      its(:scope_method) { should == :with_api_access }
    end

    context "when a name and scope block" do
      let(:scope)        { ActiveAdmin::Scope.new("My Scope"){|s| s } }
      its(:name)         { should == "My Scope"}
      its(:id)           { should == "my_scope"}
      its(:scope_method) { should == nil }
      its(:scope_block)  { should be_a(Proc)}
    end

    context "with a proc as the label" do
      it "should raise an exception if a second argument isn't provided" do
        expect{ ActiveAdmin::Scope.new proc{ Date.today.strftime '%A' }
        }.to raise_error
      end

      it "should properly render the proc" do
        scope = ActiveAdmin::Scope.new proc{ Date.today.strftime '%A' }, :foobar
        scope.name.should eq Date.today.strftime '%A'
      end
    end

  end # describe "creating a scope"

  describe "#display_if_block" do

    it "should return true by default" do
      scope = ActiveAdmin::Scope.new(:default)
      scope.display_if_block.call.should == true
    end

    it "should return the :if block if set" do
      scope = ActiveAdmin::Scope.new(:with_block, nil, :if => proc{ false })
      scope.display_if_block.call.should == false
    end

  end

  describe "show_count" do

    it "should allow setting of show_count to prevent showing counts" do
      scope = ActiveAdmin::Scope.new(:default, nil, :show_count => false)
      scope.show_count.should == false
    end

    it "should set show_count to true if not passed in" do
      scope = ActiveAdmin::Scope.new(:default)
      scope.show_count.should == true
    end

  end

end
require 'spec_helper'

def it_should_have_view(key, value)
  it "should have #{value} for view key '#{key}'" do
    subject.send(key).should  == value
  end
end

describe ActiveAdmin::ViewFactory do

  it_should_have_view :global_navigation,    ActiveAdmin::Views::TabbedNavigation
  it_should_have_view :site_title,           ActiveAdmin::Views::SiteTitle
  it_should_have_view :action_items,         ActiveAdmin::Views::ActionItems
  it_should_have_view :header,               ActiveAdmin::Views::Header
  it_should_have_view :blank_slate,          ActiveAdmin::Views::BlankSlate
  it_should_have_view :action_list_popover,  ActiveAdmin::Views::ActionListPopover

  it_should_have_view :dashboard_page,       ActiveAdmin::Views::Pages::Dashboard
  it_should_have_view :layout,               ActiveAdmin::Views::Pages::Layout

end
require 'spec_helper'

describe ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper do

  describe "class methods" do
    before :each do

      begin
        # The mime type to be used in respond_to |format| style web-services in rails
        Mime::Type.register "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", :xlsx
      rescue NameError
        puts "Mime module not defined. Skipping registration of xlsx"
      end

      class Foo
        include ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
      end
    end

    it "extends the class to add a formats class method that returns the default formats." do
      Foo.formats.should == [:csv, :xml, :json]
    end

    it "does not let you alter the formats array directly" do
      Foo.formats << :xlsx
      Foo.formats.should == [:csv, :xml, :json]
    end

    it "allows us to add new formats" do
      Foo.add_format :xlsx
      Foo.formats.should == [:csv, :xml, :json, :xlsx]
    end

    it "raises an exception if you provide an unregisterd mime type extension" do
      expect{ Foo.add_format :hoge }.to raise_error
    end

  end
end
require 'active_admin/view_helpers/fields_for'

describe ActiveAdmin::ViewHelpers::FormHelper, ".fields_for" do
  include ActiveAdmin::ViewHelpers::FormHelper

  it "should skip :action, :controller and :commit" do
    fields_for_params(
      :scope => "All", :action => "index", :controller => "PostController", :commit => "Filter", :utf8 => "Yes!").
      should == [ { :scope => "All" } ]
  end

  it "should skip the except" do
    fields_for_params({:scope => "All", :name => "Greg"}, :except => :name).
      should == [ { :scope => "All" } ]
  end

  it "should allow an array for the except" do
    fields_for_params({:scope => "All", :name => "Greg", :age => "12"}, :except => [:name, :age]).
      should == [ { :scope => "All" } ]
  end

  it "should work with hashes" do
    params = fields_for_params(:filters => { :name => "John", :age => "12" })

    params.size.should == 2
    params.should include({"filters[name]" => "John" })
    params.should include({ "filters[age]" => "12" })
  end

  it "should work with nested hashes" do
    fields_for_params(:filters => { :user => { :name => "John" }}).
      should == [ { "filters[user][name]" => "John" } ]
  end

  it "should work with arrays" do
    fields_for_params(:people => ["greg", "emily", "philippe"]).
      should == [ { "people[]" => "greg" },
                  { "people[]" => "emily" },
                  { "people[]" => "philippe" } ]
  end

  it "should work with symbols" do
    fields_for_params(:filter => :id).
      should == [ { :filter => "id" } ]
  end

  it "should work with booleans" do
    fields_for_params(:booleantest => false).should == [ { :booleantest => false } ]
  end
end
require 'spec_helper'

describe ActiveAdmin::ViewHelpers::FormHelper do
  describe ".hidden_field_tags_for" do
    let(:view) { action_view }

    it "should render hidden field tags for params" do
      view.hidden_field_tags_for(:scope => "All", :filter => "None").should == 
        %{<input id="hidden_active_admin_scope" name="scope" type="hidden" value="All" />\n<input id="hidden_active_admin_filter" name="filter" type="hidden" value="None" />}
    end

    it "should generate not default id for hidden input" do
      view.hidden_field_tags_for(:scope => "All")[/id="([^"]+)"/, 1].should_not == "scope"
    end

    it "should filter out the field passed via the option :except" do
      view.hidden_field_tags_for({:scope => "All", :filter => "None"}, :except => :filter).should == 
        %{<input id="hidden_active_admin_scope" name="scope" type="hidden" value="All" />}
    end
  end
end

require 'spec_helper'

describe MethodOrProcHelper do
  let(:receiver) { mock }

  let(:context) do
    obj = mock(:receiver_in_context => receiver)
    obj.extend MethodOrProcHelper
    obj
  end

  describe "#call_method_or_exec_proc" do

    it "should call the method in the context when a symbol" do
      context.call_method_or_exec_proc(:receiver_in_context).
        should == receiver
    end

    it "should call the method in the context when a string" do
      context.call_method_or_exec_proc("receiver_in_context").
        should == receiver
    end

    it "should exec a proc in the context" do
      test_proc = Proc.new{ raise "Success" if receiver_in_context }

      expect {
        context.call_method_or_exec_proc(test_proc)
      }.to raise_error("Success")
    end

  end

  describe "#call_method_or_proc_on" do

    context "when a symbol" do

      it 'should call the method on the receiver' do
        receiver.should_receive(:hello).and_return("hello")

        context.call_method_or_proc_on(receiver, "hello").
          should == "hello"
      end

      it "should receive additional arguments" do
        receiver.should_receive(:hello).with("world").and_return("hello world")

        context.call_method_or_proc_on(receiver, :hello, "world").
          should == "hello world"
      end

    end

    context "when a proc" do

      it "should exec the block in the context and pass in the receiver" do
        test_proc = Proc.new do |arg|
          raise "Success!" if arg == receiver_in_context
        end

        expect {
          context.call_method_or_proc_on(receiver,test_proc)
        }.to raise_error("Success!")
      end

      it "should receive additional arguments" do
        test_proc = Proc.new do |arg1, arg2|
          raise "Success!" if arg1 == receiver_in_context && arg2 == "Hello"
        end

        expect {
          context.call_method_or_proc_on(receiver, test_proc, "Hello")
        }.to raise_error("Success!")
      end

    end

    context "when a proc and :exec => false" do

      it "should call the proc and pass in the receiver" do
        obj_not_in_context = mock

        test_proc = Proc.new do |arg|
          raise "Success!" if arg == receiver && obj_not_in_context
        end

        expect {
          context.call_method_or_proc_on(receiver,test_proc, :exec => false)
        }.to raise_error("Success!")
      end

    end


  end

end
require 'spec_helper'

describe ActiveAdmin::Views::ActionListPopover do

  let(:the_popover) do
    arbre {
      action_list_popover :id => "my_awesome_action_list_popover" do
        action "My First Great Action", "#"
        action "My Second Great Action", "http://www.google.com"
      end
    }.children.first
  end

  it "should have an id" do
    the_popover.id.should == "my_awesome_action_list_popover"
  end

  describe "the action list" do
    subject do
      the_popover.find_by_class("popover_contents").first
    end

    its(:tag_name) { should eql("ul") }

    its(:content){ should include("<li><a href=\"#\">My First Great Action</a></li>") }
    its(:content){ should include("<li><a href=\"http://www.google.com\">My Second Great Action</a></li>") }

  end

end
require 'spec_helper'

describe ActiveAdmin::Views::AttributesTable do

  describe "creating with the dsl" do
    let(:helpers) { action_view }

    let(:post) do
      post = Post.new :title => "Hello World", :body => nil
      post.stub!(:id){ 1 }
      post.stub!(:new_record?){ false }
      post
    end

    let(:assigns){ { :post => post } }

    # Loop through a few different ways to make the same table
    # and ensure that they produce the same results
    {
      "when attributes are passed in to the builder methods" => proc {
        render_arbre_component(assigns) {
          attributes_table_for post, :id, :title, :body
        }
      },
      "when attributes are built using the block" => proc {
        render_arbre_component(assigns) {
          attributes_table_for post do
            rows :id, :title, :body
          end
        }
      },
      "when each attribute is passed in by itself" => proc {
        render_arbre_component(assigns) {
          attributes_table_for post do
            row :id
            row :title
            row :body
          end
        }
      },
      "when you create each row with a custom block" => proc {
        render_arbre_component(assigns) {
          attributes_table_for post do
            row("Id")   { post.id }
            row("Title"){ post.title }
            row("Body") { post.body }
          end
        }
      }

    }.each do |context_title, table_decleration|
      context context_title do
        let(:table) { instance_eval &table_decleration }

        it "should render a div wrapper with the class '.attributes_table'" do
          table.tag_name.should == 'div'
          table.attr(:class).should include('attributes_table')
        end

        it "should add id and type class" do
          table.class_names.should include("post")
          table.id.should == "attributes_table_post_1"
        end

        it "should render 3 rows" do
          table.find_by_tag("tr").size.should == 3
        end

        describe "rendering the rows" do
          [
            ["Id" , "2"],
            ["Title" , "Hello World"],
            ["Body" , "<span class=\"empty\">Empty</span>"]
          ].each_with_index do |set, i|
            let(:title){ set[0] }
            let(:content){ set[1] }
            let(:current_row){ table.find_by_tag("tr")[i] }

            describe "for #{set[0]}" do
              it "should have the title '#{set[0]}'" do
                current_row.find_by_tag("th").first.content.should == title
              end
              it "should have the content '#{set[1]}'" do
                current_row.find_by_tag("td").first.content.chomp.strip.should == content
              end
            end
          end
        end # describe rendering rows

      end
    end # describe dsl styles

    it "should allow html options for the row itself" do
      table = render_arbre_component(assigns) {
        attributes_table_for(post) do
          row("Wee", :class => "custom_row", :style => "custom_style") { }
        end
      }
      table.find_by_tag("tr").first.to_s.
        split("\n").first.lstrip.
          should == '<tr class="custom_row" style="custom_style">'
    end

    it "should allow html content inside the attributes table" do
      table = render_arbre_component(assigns) {
        attributes_table_for(post) do
          row("ID"){ span(post.id, :class => 'id') }
        end
      }
      table.find_by_tag("td").first.content.chomp.strip.should == "<span class=\"id\">1</span>"
    end

    it "should check if an association exists when an attribute has id in it" do
      post.author = User.new(:username => "john_doe")
      table = render_arbre_component(assigns) {
        attributes_table_for post, :author_id
      }
      table.find_by_tag("td").first.content.should == "john_doe"
    end

  end

end
require 'spec_helper'
require 'active_admin/batch_actions/views/batch_action_popover'

describe ActiveAdmin::BatchActions::BatchActionPopover do

  let(:the_popover) do
    render_arbre_component do
      batch_action_popover do
        action ActiveAdmin::BatchAction.new( :action_1, "Action 1" )
        action ActiveAdmin::BatchAction.new( :action_2, "Action 2" )
        action ActiveAdmin::BatchAction.new( :action_3, "Action 3" )
      end
    end
  end
  
  it "should have an id" do
    the_popover.id.should == "batch_actions_popover"
  end
  
  describe "the action list" do
    subject do
      the_popover.find_by_class("popover_contents").first
    end

    its(:tag_name) { should eql("ul") }
    
    its(:content){ should include("<li><a href=\"#\" class=\"batch_action\" data-action=\"action_1\">Action 1 Selected</a></li>") }
    its(:content){ should include("<li><a href=\"#\" class=\"batch_action\" data-action=\"action_2\">Action 2 Selected</a></li>") }
    its(:content){ should include("<li><a href=\"#\" class=\"batch_action\" data-action=\"action_3\">Action 3 Selected</a></li>") }
    
  end

end
require 'spec_helper'

describe ActiveAdmin::Views::BlankSlate do

  describe "#blank_slate" do
    subject do
      render_arbre_component do
        blank_slate("There are no Posts yet. <a href=\"/posts/new\">Create one</a></span>")
      end
    end

    its(:tag_name)    { should eql 'div' }
    its(:class_list)  { should include('blank_slate_container') }

    its(:content)     { should include '<span class="blank_slate">There are no Posts yet. <a href="/posts/new">Create one</a></span>' }
  end
end
require 'spec_helper'

describe ActiveAdmin::Views::Columns do

  describe "Rendering one column" do
    let(:cols) do
      render_arbre_component do
        columns do
          column { span "Hello World" }
        end
      end
    end

    it "should have the class .columns" do
      cols.class_list.should include("columns")
    end

    it "should have one column" do
      cols.children.size.should == 1
      cols.children.first.class_list.should include("column")
    end

    it "should have one column with the width 100.0%" do
      cols.children.first.attr(:style).should include("width: 100.0%")
    end
  end

  describe "Rendering two columns" do
    let(:cols) do
      render_arbre_component do
        columns do
          column { span "Hello World" }
          column { span "Hello World" }
        end
      end
    end

    it "should have two columns" do
      cols.children.size.should == 2
    end

    it "should have a first column with width 49% and margin 2%" do
      cols.children.first.attr(:style).should == "width: 49.0%; margin-right: 2%;"
    end

    it "should have a second column with width 49% and no right margin" do
      cols.children.last.attr(:style).should == "width: 49.0%;"
    end
  end

  describe "Rendering four columns" do
    let(:cols) do
      render_arbre_component do
        columns do
          column { span "Hello World" }
          column { span "Hello World" }
          column { span "Hello World" }
          column { span "Hello World" }
        end
      end
    end

    it "should have four columns" do
      cols.children.size.should == 4
    end


    (0..2).to_a.each do |index|
      it "should have column #{index + 1} with width 49% and margin 2%" do
        cols.children[index].attr(:style).should == "width: 23.5%; margin-right: 2%;"
      end
    end

    it "should have column 4 with width 49% and no margin" do
      cols.children[3].attr(:style).should == "width: 23.5%;"
    end
  end


  describe "Column Spans" do
    let(:cols) do
      render_arbre_component do
        columns do
          column(:span => 2){ "Hello World" }
          column(){ "Hello World" }
          column(){ "Hello World" }
        end
      end
    end

    it "should set the span when declared" do
      cols.children.first.attr(:style).should == "width: 49.0%; margin-right: 2%;"
    end

    it "should default to 1 if not passed in" do
      cols.children.last.attr(:style).should == "width: 23.5%;"
    end
  end

  describe "Column max width" do

    let(:cols) do
      render_arbre_component do
        columns do
          column(:max_width => "100px"){ "Hello World" }
          column(){ "Hello World" }
        end
      end
    end

    it "should set the max with if passed in" do
      cols.children.first.attr(:style).should == "width: 49.0%; max-width: 100px; margin-right: 2%;"
    end

    it "should omit the value if not presetn" do
      cols.children.last.attr(:style).should == "width: 49.0%;"
    end

  end

  describe "Column min width" do

    let(:cols) do
      render_arbre_component do
        columns do
          column(:min_width => "100px"){ "Hello World" }
          column(){ "Hello World" }
        end
      end
    end

    it "should set the min with if passed in" do
      cols.children.first.attr(:style).should == "width: 49.0%; min-width: 100px; margin-right: 2%;"
    end

    it "should omit the value if not presetn" do
      cols.children.last.attr(:style).should == "width: 49.0%;"
    end

  end

end
require 'spec_helper'

describe ActiveAdmin::Views::IndexList do

  describe "#index_list_renderer" do

    
    let(:index_classes) { [ActiveAdmin::Views::IndexAsTable, ActiveAdmin::Views::IndexAsBlock] }

    let(:helpers) do 
      helpers = mock_action_view
      helpers.stub! :url_for => "/"
      helpers.stub!(:params).and_return({:as => "table"})
      helpers
    end

    subject do
      render_arbre_component({:index_classes => index_classes}, helpers) do
        index_list_renderer(index_classes)
      end
    end

    its(:tag_name) { should == 'ul' }

    it "should contain the names of available indexes in links" do
      a_tags = subject.find_by_tag("a")
      a_tags.size.should == 2
      a_tags.first.to_s.should include("Table")
      a_tags.last.to_s.should include("List")
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Views::PaginatedCollection do
  describe "creating with the dsl" do

    before :all do
      load_defaults!
      reload_routes!
    end

    let(:view) do
      view = mock_action_view
      view.request.stub!(:query_parameters).and_return({:controller => 'admin/posts', :action => 'index', :page => '1'})
      view.controller.params = {:controller => 'admin/posts', :action => 'index'}
      view
    end

    # Helper to render paginated collections within an arbre context
    def paginated_collection(*args)
      render_arbre_component({:paginated_collection_args => args}, view) do
        paginated_collection(*paginated_collection_args)
      end
    end

    let(:collection) do
      posts = [Post.new(:title => "First Post"), Post.new(:title => "Second Post"), Post.new(:title => "Third Post")]
      Kaminari.paginate_array(posts).page(1).per(5)
    end

    before do
      collection.stub!(:reorder) { collection }
    end

    context "when specifying collection" do
      let(:pagination) do
        paginated_collection(collection)
      end

      it "should set :collection as the passed in collection" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 3</b> posts"
      end

      it "should raise error if collection has no pagination scope" do
        lambda {
          paginated_collection([Post.new, Post.new])
        }.should raise_error(StandardError, "Collection is not a paginated scope. Set collection.page(params[:page]).per(10) before calling :paginated_collection.")
      end
    end

    context "when specifying :param_name option" do
      let(:collection) do
        posts = 10.times.inject([]) {|m, _| m << Post.new }
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection, :param_name => :post_page) }

      it "should customize the page number parameter in pagination links" do
        pagination.children.last.content.should match(/\/admin\/posts\?post_page=2/)
      end
    end

    context "when specifying :download_links => false option" do
      let(:collection) do
        posts = 10.times.inject([]) {|m, _| m << Post.new }
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection, :download_links => false) }

      it "should not render download links" do
        pagination.find_by_tag('div').last.content.should_not match(/Download:/)
      end
    end

    context "when specifying :entry_name option with a single item" do
      let(:collection) do
        posts = [Post.new]
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection, :entry_name => "message") }

      it "should use :entry_name as the collection name" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>1</b> message"
      end
    end

    context "when specifying :entry_name option with multiple items" do
      let(:pagination) { paginated_collection(collection, :entry_name => "message") }

      it "should use :entry_name as the collection name" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 3</b> messages"
      end
    end

    context "when specifying :entry_name and :entries_name option with a single item" do
      let(:collection) do
        posts = [Post.new]
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection, :entry_name => "singular", :entries_name => "plural") }

      it "should use :entry_name as the collection name" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>1</b> singular"
      end
    end

    context "when specifying :entry_name and :entries_name option with a multiple items" do
      let(:pagination) { paginated_collection(collection, :entry_name => "singular", :entries_name => "plural") }

      it "should use :entries_name as the collection name" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 3</b> plural"
      end
    end

    context "when omitting :entry_name with a single item" do
      let(:collection) do
        posts = [Post.new]
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection) }

      it "should use 'post' as the collection name when there is no I18n translation" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>1</b> post"
      end

      it "should use 'Singular' as the collection name when there is an I18n translation" do
        I18n.stub(:translate) { "Singular" }
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>1</b> Singular"
      end
    end

    context "when omitting :entry_name with multiple items" do
      let(:pagination) { paginated_collection(collection) }

      it "should use 'posts' as the collection name when there is no I18n translation" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 3</b> posts"
      end

      it "should use 'Plural' as the collection name when there is an I18n translation" do
        I18n.stub(:translate) { "Plural" }
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 3</b> Plural"
      end
    end

    context "when specifying an empty collection" do
      let(:collection) do
        posts = []
        Kaminari.paginate_array(posts).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection) }

      it "should display 'No entries found'" do
        pagination.find_by_class('pagination_information').first.content.should == "No entries found"
      end
    end

    context "when collection comes from find with GROUP BY" do
      let(:collection) do
        %w{Foo Foo Bar}.each {|title| Post.create(:title => title) }
        Post.select(:title).group(:title).page(1).per(5)
      end

      let(:pagination) { paginated_collection(collection) }

      it "should display proper message (including number and not hash)" do
        pagination.find_by_class('pagination_information').first.content.should == "Displaying <b>all 2</b> posts"
      end
    end

    context "when collection with many pages comes from find with GROUP BY" do
      let(:collection) do
        %w{Foo Foo Bar Baz}.each {|title| Post.create(:title => title) }
        Post.select(:title).group(:title).page(1).per(2)
      end

      let(:pagination) { paginated_collection(collection) }

      it "should display proper message (including number and not hash)" do
        pagination.find_by_class('pagination_information').first.content.
          gsub('&nbsp;',' ').should == "Displaying posts <b>1 - 2</b> of <b>3</b> in total"
      end
    end

    context "when viewing the last page of a collection that has multiple pages" do
      let(:collection) do
        posts = [Post.new] * 81
        Kaminari.paginate_array(posts).page(3).per(30)
      end

      let(:pagination) { paginated_collection(collection) }

      it "should show the proper item counts" do
        pagination.find_by_class('pagination_information').first.content.
            gsub('&nbsp;',' ').should == "Displaying posts <b>61 - 81</b> of <b>81</b> in total"
      end
    end


  end
end
require 'spec_helper'

describe ActiveAdmin::Views::Panel do

  let(:the_panel) do
    render_arbre_component do
      panel "My Title" do
        span("Hello World")
      end
    end
  end

  it "should have a title h3" do
    the_panel.find_by_tag("h3").first.content.should == "My Title"
  end

  it "should have a contents div" do
    the_panel.find_by_tag("div").first.class_list.should include("panel_contents")
  end

  it "should add children to the contents div" do
    the_panel.find_by_tag("span").first.parent.should == the_panel.find_by_tag("div").first
  end

  it "should set the icon" do
    the_panel = render_arbre_component do
      panel("Title", :icon => :arrow_down)
    end
    the_panel.find_by_tag("h3").first.content.should include("span class=\"icon")
  end

  describe "#children?" do

    it "returns false if no children have been added to the panel" do
      the_panel = render_arbre_component do
        panel("A Panel")
      end
      the_panel.children?.should == false
    end

  end

end
require 'spec_helper'

describe ActiveAdmin::Views::Popover do

  let(:the_popover) do
    render_arbre_component do
      popover :id => "my_awesome_popover" do
        para "Hello World, this is popover content baby."
      end
    end
  end

  it "should have the class of 'sidebar_section'" do
    the_popover.class_list.should include("popover")
  end

  it "should have an inner content element class of 'popover_contents'" do
    the_popover.find_by_tag("div").first.class_list.should include("popover_contents")
  end

  it "should have the popover content in the inner content element" do
    the_popover.find_by_class("popover_contents").first.content.should include("Hello World, this is popover content baby.")
  end

  it "should have an id" do
    the_popover.id.should == "my_awesome_popover"
  end

  it "should be hidden" do
    the_popover.attributes.should include(:style => "display: none");
  end

end
require 'spec_helper'

describe ActiveAdmin::Views::SidebarSection do

  let(:section) do
    ActiveAdmin::SidebarSection.new("Help Section") do
      span "Help Me"
    end
  end

  let(:html) do
    render_arbre_component :section => section do
      sidebar_section(assigns[:section])
    end
  end

  it "should have a title h3" do
    html.find_by_tag("h3").first.content.should == "Help Section"
  end

  it "should have the class of 'sidebar_section'" do
    html.class_list.should include("sidebar_section")
  end

  it "should have an id based on the title" do
    html.id.should == "help-section_sidebar_section"
  end

  it "should have a contents div" do
    html.find_by_tag("div").first.class_list.should include("panel_contents")
  end

  it "should add children to the contents div" do
    html.find_by_tag("span").first.parent.should == html.find_by_tag("div").first
  end

end
require 'spec_helper'

describe ActiveAdmin::Views::SiteTitle do

  let(:helpers){ mock_action_view }

  def build_title(namespace)
    render_arbre_component({:namespace => namespace}, helpers) do
      insert_tag ActiveAdmin::Views::SiteTitle, assigns[:namespace]
    end
  end

  context "when a value" do

    it "renders the string when a string is passed in" do
      namespace = mock :site_title => "Hello World", 
                       :site_title_image => nil,
                       :site_title_link => nil

      site_title = build_title(namespace)
      site_title.content.should == "Hello World"
    end

    it "renders the return value of a method when a symbol" do
      helpers.should_receive(:hello_world).and_return("Hello World")

      namespace = mock :site_title => :hello_world,
                       :site_title_image => nil,
                       :site_title_link => nil

      site_title = build_title(namespace)
      site_title.content.should == "Hello World"
    end

    it "renders the return value of a proc" do
      namespace = mock :site_title => proc{ "Hello World" },
                       :site_title_image => nil,
                       :site_title_link => nil

      site_title = build_title(namespace)
      site_title.content.should == "Hello World"
    end

  end

  context "when an image" do

    it "renders the string when a string is passed in" do
      helpers.should_receive(:image_tag).
        with("an/image.png", {:alt => nil, :id => "site_title_image"}).
        and_return("<img src=\"/assets/an/image.png\" />".html_safe)

      namespace = mock :site_title => nil,
                       :site_title_image => "an/image.png",
                       :site_title_link => nil

      site_title = build_title(namespace)
      site_title.content.strip.should == "<img src=\"/assets/an/image.png\" />"
    end

  end

  context "when a link is present" do

    it "renders the string when a string is passed in" do
      namespace = mock :site_title => "Hello World", 
                       :site_title_image => nil,
                       :site_title_link => "/"

      site_title = build_title(namespace)
      site_title.content.should == "<a href=\"/\">Hello World</a>"
    end

  end



end
require 'spec_helper'

describe ActiveAdmin::Views::StatusTag do

  describe "#status_tag" do

    # Helper method to build StatusTag objects in an Arbre context
    def status_tag(*args)
      render_arbre_component(:status_tag_args => args) do
        status_tag(*assigns[:status_tag_args])
      end
    end

    subject { status_tag(nil) }


    its(:tag_name)    { should == 'span' }
    its(:class_list)  { should include('status_tag') }

    context "when status is 'completed'" do
      subject { status_tag('completed') }

      its(:tag_name)    { should == 'span' }
      its(:class_list)  { should include('status_tag') }
      its(:class_list)  { should include('completed') }
      its(:content)     { should == 'Completed' }
    end

    context "when status is 'in_progress'" do
      subject { status_tag('in_progress') }

      its(:class_list)  { should include('in_progress') }
      its(:content)     { should == 'In Progress' }
    end

    context "when status is 'In progress'" do
      subject { status_tag('In progress') }

      its(:class_list)  { should include('in_progress') }
      its(:content)     { should == 'In Progress' }
    end

    context "when status is an empty string" do
      subject { status_tag('') }

      its(:class_list)  { should include('status_tag') }
      its(:content)     { should == '' }
    end

    context "when status is nil" do
      subject { status_tag(nil) }

      its(:class_list)  { should include('status_tag') }
      its(:content)     { should == '' }
    end

    context "when status is 'Active' and type is :ok" do
      subject { status_tag('Active', :ok) }

      its(:class_list)  { should include('status_tag') }
      its(:class_list)  { should include('active') }
      its(:class_list)  { should include('ok') }
    end

    context "when status is 'Active' and class is 'ok'" do
      subject { status_tag('Active', :class => 'ok') }

      its(:class_list)  { should include('status_tag') }
      its(:class_list)  { should include('active') }
      its(:class_list)  { should include('ok') }
    end

    context "when status is 'Active' and label is 'on'" do
      subject { status_tag('Active', :label => 'on') }

      its(:content)     { should == 'on' }
      its(:class_list)  { should include('status_tag') }
      its(:class_list)  { should include('active') }
      its(:class_list)  { should_not include('on') }
    end

    context "when status is 'So useless', type is :ok, class is 'woot awesome' and id is 'useless'" do
      subject { status_tag('So useless', :ok, :class => 'woot awesome', :id => 'useless') }

      its(:content)     { should == 'So Useless' }
      its(:class_list)  { should include('status_tag') }
      its(:class_list)  { should include('ok') }
      its(:class_list)  { should include('so_useless') }
      its(:class_list)  { should include('woot') }
      its(:class_list)  { should include('awesome') }
      its(:id)          { should == 'useless' }
    end

  end # describe "#status_tag"
end
require 'spec_helper'

describe ActiveAdmin::Views::TableFor do
  describe "creating with the dsl" do

    let(:collection) do
      [Post.new(:title => "First Post"), Post.new(:title => "Second Post"), Post.new(:title => "Third Post")]
    end

    let(:assigns){ { :collection => collection } }
    let(:helpers){ mock_action_view }

    context "when creating a column with a symbol" do
      let(:table) do
        render_arbre_component assigns, helpers do
          table_for(collection) do
            column :title
          end
        end
      end

      it "should create a table header based on the symbol" do
        table.find_by_tag("th").first.content.should == "Title"
      end

      it "should create a table row for each element in the collection" do
        table.find_by_tag("tr").size.should == 4 # 1 for head, 3 for rows
      end

      ["First Post", "Second Post", "Third Post"].each_with_index do |content, index|
        it "should create a cell with #{content}" do
          table.find_by_tag("td")[index].content.should == content
        end
      end
    end

    context "when creating many columns with symbols" do
      let(:table) do
        render_arbre_component assigns, helpers do
          table_for(collection) do
            column :title
            column :created_at
          end
        end
      end

      it "should create a table header based on the symbol" do
        table.find_by_tag("th").first.content.should == "Title"
        table.find_by_tag("th").last.content.should == "Created At"
      end
      
      it "should add a class to each table header based on the col name" do
        table.find_by_tag("th").first.class_list.should include("title")
        table.find_by_tag("th").last.class_list.should  include("created_at")
      end

      it "should create a table row for each element in the collection" do
        table.find_by_tag("tr").size.should == 4 # 1 for head, 3 for rows
      end

      it "should create a cell for each column" do
        table.find_by_tag("td").size.should == 6
      end
      
      it "should add a class for each cell based on the col name" do
        table.find_by_tag("td").first.class_list.should include("title")
        table.find_by_tag("td").last.class_list.should  include("created_at")
      end
    end

    context "when creating a column with block content" do
      let(:table) do
        render_arbre_component assigns, helpers do
          table_for(collection) do
            column :title do |post|
              span(post.title)
            end
          end
        end
      end

      it "should add a class to each table header based on the col name" do
        table.find_by_tag("th").first.class_list.should include("title")
      end

      [ "<span>First Post</span>", 
        "<span>Second Post</span>", 
        "<span>Third Post</span>" ].each_with_index do |content, index|
        it "should create a cell with #{content}" do
          table.find_by_tag("td")[index].content.strip.should == content
        end
      end
    end

    context "when creating a column with multiple block content" do
      let(:table) do
        render_arbre_component assigns, helpers do
          table_for(collection) do
            column :title do |post|
              span(post.title)
              span(post.title)
            end
          end
        end
      end

      3.times do |index|
        it "should create a cell with multiple elements in row #{index}" do
          table.find_by_tag("td")[index].find_by_tag("span").size.should == 2
        end
      end
    end


    context "when creating many columns with symbols, blocks and strings" do
      let(:table) do
        render_arbre_component assigns, helpers do
          table_for(collection) do
            column "My Custom Title", :title
            column :created_at , :class=>"datetime"
          end
        end
      end


      it "should add a class to each table header  based on class option or the col name" do
        table.find_by_tag("th").first.class_list.should  include("my_custom_title")
        table.find_by_tag("th").last.class_list.should  include("datetime")
      end

      it "should add a class to each cell based  on class option or the col name" do
        table.find_by_tag("td").first.class_list.should include("my_custom_title")
        table.find_by_tag("td").last.class_list.should  include("datetime")
      end


    end


  end

  describe "column sorting" do

    def build_column(*args, &block)
      ActiveAdmin::Views::TableFor::Column.new(*args, &block)
    end

    subject { table_column }

    context "when default" do
      let(:table_column){ build_column(:username) }
      it { should be_sortable }
      its(:sort_key){ should == "username" }
    end

    context "when a block given with no sort key" do
      let(:table_column){ build_column("Username"){ } }
      it { should_not be_sortable }
    end

    context "when a block given with a sort key" do
      let(:table_column){ build_column("Username", :sortable => :username){ } }
      it { should be_sortable }
      its(:sort_key){ should == "username" }
    end

    context "when :sortable => false with a symbol" do
      let(:table_column){ build_column(:username, :sortable => false) }
      it { should_not be_sortable }
    end

    context "when :sortable => false with a symbol and string" do
      let(:table_column){ build_column("Username", :username, :sortable => false) }
      it { should_not be_sortable }
    end

    context "when :sortable column is an association" do
      let(:table_column){ build_column("Category", :category, Post) }
      it { should_not be_sortable }
    end
  end
end
require 'spec_helper'

describe ActiveAdmin::Views::Pages::Layout do

  let(:assigns){ {} }
  let(:helpers) do 
    helpers = mock_action_view

    helpers.stub :active_admin_application => active_admin_application,
                 :active_admin_config => mock('Config', :action_items? => nil, :breadcrumb => nil, :sidebar_sections? => nil),
                 :active_admin_namespace => active_admin_namespace,
                 :breadcrumb_links => [],
                 :content_for => "",
                 :csrf_meta_tag => "",
                 :current_active_admin_user => nil,
                 :current_active_admin_user? => false,
                 :current_menu => mock('Menu', :items => []),
                 :flash => {},
                 :javascript_path => "/dummy/",
                 :link_to => "",
                 :render_or_call_method_or_proc_on => "",
                 :stylesheet_link_tag => mock(:html_safe => ""),
                 :view_factory => view_factory,
                 :params => {:controller => 'UsersController', :action => 'edit'}

    helpers
  end

  let(:active_admin_namespace){ ActiveAdmin::Namespace.new(ActiveAdmin::Application.new, :myspace) }
  let(:active_admin_application){ ActiveAdmin.application }
  let(:view_factory) { ActiveAdmin::ViewFactory.new }

  let(:layout) do
    render_arbre_component assigns, helpers do
      insert_tag ActiveAdmin::Views::Pages::Layout
    end
  end

  it "should be the @page_title if assigned in the controller" do
    assigns[:page_title] = "My Page Title"

    layout.title.should == "My Page Title"
  end

  it "should be the default translation" do
    helpers.params[:action] = "edit"

    layout.title.should == "Edit"
  end

  describe "the body" do

    it "should have class 'active_admin'" do
      layout.build.class_list.should include 'active_admin'
    end

    it "should have namespace class" do
      layout.build.class_list.should include "#{active_admin_namespace.name}_namespace"
    end

  end

end
require 'spec_helper'


describe ActiveAdmin::Views::Pages::Show do

  describe "the resource" do
    let(:helpers) { mock(:resource => resource) }
    let(:arbre_context) { OpenStruct.new(:helpers => helpers) }

    context 'when the resource does not respond to #decorator' do
      let(:resource) { 'Test Resource' }

      it "normally returns the resource" do
        page = ActiveAdmin::Views::Pages::Show.new(arbre_context)
        page.resource.should == 'Test Resource'
      end
    end

  end

end
require 'spec_helper'

include ActiveAdmin
describe ActiveAdmin::Views::TabbedNavigation do

  let(:menu){ ActiveAdmin::Menu.new }

  let(:assigns){ { :active_admin_menu => menu } }
  let(:helpers){ mock_action_view }

  let(:tabbed_navigation) do 
    arbre(assigns, helpers) {
      insert_tag(ActiveAdmin::Views::TabbedNavigation, active_admin_menu)
    }.children.first
  end

  let(:html) { tabbed_navigation.to_s }

  before do
    helpers.stub!(:admin_logged_in?).and_return(false)
  end

  describe "rendering a menu" do

    before do
      menu.add :label => "Blog Posts", :url => :admin_posts_path

      menu.add :label => "Reports", :url => "/admin/reports" do |reports|
        reports.add :label => "A Sub Reports", :url => "/admin/a-sub-reports"
        reports.add :label => "B Sub Reports", :url => "/admin/b-sub-reports"
        reports.add :label => proc{ "Label Proc Sub Reports" }, :url => "/admin/label-proc-sub-reports", :id => "Label Proc Sub Reports"
      end

      menu.add :label => "Administration", :url => "/admin/administration" do |administration|
        administration.add :label => "User administration", 
                           :url => '/admin/user-administration', 
                           :priority => 10, 
                           :if => proc { false }
      end

      menu.add :label => "Management", :url => "#" do |management|
        management.add :label => "Order management", 
                       :url => '/admin/order-management', 
                       :priority => 10, 
                       :if => proc { false }
        management.add :label => "Bill management", 
                       :url => '/admin/bill-management', 
                       :priority => 10, 
                       :if => :admin_logged_in?
      end
    end

    it "should generate a ul" do
      html.should have_tag("ul")
    end

    it "should generate an li for each item" do
      html.should have_tag("li", :parent => { :tag => "ul" })
    end

    it "should generate a link for each item" do
      html.should have_tag("a", "Blog Posts", :attributes => { :href => '/admin/posts' })
    end

    it "should generate a nested list for children" do
      html.should have_tag("ul", :parent => { :tag => "li" })
    end

    it "should generate a nested list with li for each child" do
      html.should have_tag("li", :parent => { :tag => "ul" }, :attributes => {:id => "a_sub_reports"})
      html.should have_tag("li", :parent => { :tag => "ul" }, :attributes => {:id => "b_sub_reports"})
    end

    it "should generate a valid id from a label proc" do
      html.should have_tag("li", :parent => { :tag => "ul" }, :attributes => {:id => "label_proc_sub_reports"})
    end

    it "should not generate a link for user administration" do
      html.should_not have_tag("a", "User administration", :attributes => { :href => '/admin/user-administration' })
    end

    it "should generate the administration parent menu" do
      html.should have_tag("a", "Administration", :attributes => { :href => '/admin/administration' })
    end

    it "should not generate a link for order management" do
      html.should_not have_tag("a", "Order management", :attributes => { :href => '/admin/order-management' })
    end

    it "should not generate a link for bill management" do
      html.should_not have_tag("a", "Bill management", :attributes => { :href => '/admin/bill-management' })
    end

    it "should not generate the management parent menu" do
      html.should_not have_tag("a", "Management", :attributes => { :href => '#' })
    end

    describe "marking current item" do

      it "should add the 'current' class to the li" do
        assigns[:current_tab] = menu["Blog Posts"]
        html.should have_tag("li", :attributes => { :class => "current" })
      end

      it "should add the 'current' and 'has_nested' classes to the li and 'current' to the sub li" do
        assigns[:current_tab] = menu["Reports"]["A Sub Reports"]
        html.should have_tag("li", :attributes => { :id => "reports", :class => /current/ })
        html.should have_tag("li", :attributes => { :id => "reports", :class => /has_nested/ })
        html.should have_tag("li", :attributes => { :id => "a_sub_reports", :class => "current" })
      end

    end

  end

  describe "returning the menu items to display" do

    it "should return one item with no if block" do
      menu.add :label => "Hello World", :url => "/"
      tabbed_navigation.menu_items.should == menu.items
    end

    it "should not include menu items with an if block that returns false" do
      menu.add :label => "Don't Show", :url => "/", :priority => 10, :if => proc{ false }
      tabbed_navigation.menu_items.should be_empty
    end

    it "should not include menu items with an if block that calls a method that returns false" do
      menu.add :label => "Don't Show", :url => "/", :priority => 10, :if => :admin_logged_in?
      tabbed_navigation.menu_items.should be_empty
    end

    it "should not display any items that have no children to display" do
      menu.add :label => "Parent", :url => "#" do |p|
        p.add :label => "Child", :url => "/", :priority => 10, :if => proc{ false }
      end
      tabbed_navigation.menu_items.should be_empty
    end

    it "should display a parent that has a child to display" do
      menu.add :label => "Parent", :url => "#" do |p|
        p.add :label => "Hidden Child", :url => "/", :priority => 10, :if => proc{ false }
        p.add :label => "Child", :url => "/"
      end
      tabbed_navigation.should have(1).menu_items
    end

  end
end
